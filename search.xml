<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「CodeForces 735D」Taxes 解题报告]]></title>
    <url>%2F2019%2F05%2F13%2Fcodeforces-735D-solution%2F</url>
    <content type="text"><![CDATA[Taxes题意某人要交税，交的税钱是收入n的最大因子（!=n，若该数是质数则是1）， 但是现在这人为了避税，把钱拆成几份，使交税最少，输出税钱。 思路神奇的哥德巴赫猜想应用啊！哥德巴赫猜想虽然还没有被证明，但是反正是哥德巴赫说的，错了怪他哥德巴赫猜想的大概就是任一大于2的偶数都可写成两个质数之和。所以如果N本身是质数(或者是1)，答案就是1啦。如果N是偶数(&gt;2)，根据哥德巴赫猜想，直接分成两个质数，答案为2。如果N是奇数(&gt;2,非质数)，先变成3+(N-3)，很明显，(N-3)是&gt;2的偶数，所以答案为1+2=3。证明没有更优的方案十分easy（其实是我太懒懒得写证明，只会口头证明） 代码12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;#define u32 unsigned#define i64 long long#define u64 unsigned long long#define f80 long double#define rgt register//#define getchar() ( p1 == p2 &amp;&amp; ( p2 = bf + fread( bf, 1, 1 &lt;&lt; 21, stdin ), p1 = bf ) == p2 ? EOF : *p1++ )using namespace std;char bf[1 &lt;&lt; 21], *p1, *p2;template&lt;typename T&gt;inline void read( rgt T &amp;x )&#123; x = 0; rgt char t, flg(0); for ( t = getchar(); !isdigit(t); t = getchar() ) flg = t == '-'; for ( ; isdigit(t); t = getchar() ) x = x * 10 + ( t &amp; 15 ); x = flg ? -x : x;&#125;clock_t __t_bg, __t_ed;int N;char isprime( int x )&#123; for ( rgt int i = 2, I((int)sqrt(x)); i &lt;= I; ++i ) if ( x % i == 0 ) return 0; return 1;&#125;signed main()&#123; __t_bg = clock(); read(N); if ( isprime(N) ) printf( "1\n" ); else if ( !(N &amp; 1) || isprime(N - 2) ) printf( "2\n" ); else printf( "3\n" ); __t_ed = clock(), fprintf( stderr, "time: %.5lfs\n", double( __t_ed - __t_bg ) / CLOCKS_PER_SEC ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>CodeForces</tag>
        <tag>数学,数论</tag>
        <tag>哥德巴赫猜想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P2824」 [HEOI2016/TJOI2016]排序 解题报告]]></title>
    <url>%2F2019%2F05%2F05%2Fluogu2824-solution%2F</url>
    <content type="text"><![CDATA[P2824 [HEOI2016/TJOI2016]排序题目描述在2016年，佳媛姐姐喜欢上了数字序列。因而他经常研究关于序列的一些奇奇怪怪的问题，现在他在研究一个难题，需要你来帮助他。这个难题是这样子的：给出一个1到n的全排列，现在对这个全排列序列进行m次局部排序，排序分为两种：1:(0,l,r)表示将区间[l,r]的数字升序排序2:(1,l,r)表示将区间[l,r]的数字降序排序最后询问第q位置上的数字。 输入输出格式输入格式：输入数据的第一行为两个整数n和m。n表示序列的长度，m表示局部排序的次数。第二行为n个整数，表示1到n的一个全排列。接下来输入m行，每一行有三个整数op, l, r, op为0代表升序排序，op为1代表降序排序, l, r 表示排序的区间。最后输入一个整数q，q表示排序完之后询问的位置 输出格式：输出数据仅有一行，一个整数，表示按照顺序将全部的部分排序结束后第q位置上的数字。 输入输出样例输入样例#1：1234566 31 6 2 5 3 40 1 41 3 60 2 43 输出样例#1：15 说明河北省选2016第一天第二题。对于30%的数据，$n,m\leq 1000$对于100%的数据，$n,m\leq 10^5$ 且始终$1\leq q\leq n$ 思路线段树神仙题。当然要离线处理啦。 先二分答案$x$(至于为什么等下说)，然后对所有数进行如下操作： $&lt; x$的，修改成0 $\ge x$的，修改成1 然后对0/1串进行排序，最后第$q$位为1的check函数返回true,否则返回false。 为什么这样做是正确的呢？因为二分找到$ans$的一定是最小的能使第$q$位为1,或者说$check(ans)$为true的数。也就是说，当取到$ans-1$时，第$q$位为0，$check(ans-1)$返回的肯定是false。可以看出，$x$取值从$ans-1$转变为$ans$的结果是排序后第$q$位的值，换句话讲就是第$q$位原来就是$ans$。然后二分+线段树就OK啦。 还有一个问题，对0/1串排序。这个其实也很简单，直接查询区间内1的个数，区间覆盖即可。（如果你想用珂朵莉树的话我也没办法qwq P.S. 这题还可以实现$O(nlgn)$的复杂度qwq,是线段树合并/分裂 + set/线段树，看起来代码有点长qwq.P.S. 似乎这题桶排暴力都能过，但是还是资瓷正解的啦qwq. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;#define u32 unsigned#define i64 long long#define u64 unsigned long long#define f80 long double#define rgt register#define getchar() ( p1 == p2 &amp;&amp; ( p2 = bf + fread( bf, 1, 1 &lt;&lt; 21, stdin ), p1 = bf ) == p2 ? EOF : *p1++ )using namespace std;#define MAXN 100005char bf[1 &lt;&lt; 21], *p1, *p2;template&lt;typename T&gt;inline void read( rgt T &amp;x )&#123; x = 0; rgt char t, flg(0); for ( t = getchar(); !isdigit(t); t = getchar() ) flg = t == '-'; for ( ; isdigit(t); t = getchar() ) x = x * 10 + ( t &amp; 15 ); x = flg ? -x : x;&#125;clock_t __t_bg, __t_ed;int N, M, Q, a[MAXN], L[MAXN], R[MAXN], opt[MAXN], ans, x;int tr[MAXN &lt;&lt; 2], tg[MAXN &lt;&lt; 2];#define ls c &lt;&lt; 1#define rs c &lt;&lt; 1 | 1void build( int c, int l, int r )&#123; tg[c] = -1; if ( l == r ) return tr[c] = a[l] &gt;= x, void(); int mid((l + r) &gt;&gt; 1); build( ls, l, mid ), build( rs, mid + 1, r ), tr[c] = tr[ls] + tr[rs];&#125;inline void tag( int c, int l, int r, int x )&#123; tr[c] = x ? r - l + 1 : 0, tg[c] = x; &#125;inline void pushdown( int c, int l, int r )&#123; if ( tg[c] != -1 )&#123; rgt int mid((l + r) &gt;&gt; 1); tag( ls, l, mid, tg[c] ), tag( rs, mid + 1, r, tg[c] ), tg[c] = -1; &#125;&#125;void cover( int x, int y, char z, int c = 1, int l = 1, int r = N )&#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) return tag( c, l, r, z ); if ( x &gt; r || l &gt; y ) return; int mid((l + r) &gt;&gt; 1); pushdown( c, l, r ), cover( x, y, z, ls, l, mid ), cover( x, y, z, rs, mid + 1, r ), tr[c] = tr[ls] + tr[rs];&#125;int get( int c, int l, int r, int x, int y )&#123; if ( x &lt;= l &amp;&amp; r &lt;= y ) return tr[c]; if ( x &gt; r || l &gt; y ) return 0; int mid((l + r) &gt;&gt; 1); pushdown( c, l, r ); return get( ls, l, mid, x, y ) + get( rs, mid + 1, r, x, y );&#125;inline char check()&#123; build( 1, 1, N ); for ( rgt int i = 1, ct1; i &lt;= M; ++i )&#123; ct1 = get( 1, 1, N, L[i], R[i] ); if ( opt[i] ) cover( L[i], L[i] + ct1 - 1, 1 ), cover( L[i] + ct1, R[i], 0 ); else cover( L[i], R[i] - ct1, 0 ), cover( R[i] - ct1 + 1, R[i], 1 ); &#125; return get( 1, 1, N, Q, Q );&#125;signed main()&#123; __t_bg = clock(); read(N), read(M); for ( rgt int i = 1; i &lt;= N; ++i ) read(a[i]); for ( rgt int i = 1; i &lt;= M; ++i ) read(opt[i]), read(L[i]), read(R[i]); read(Q); rgt int l(1), r(N); while( l &lt;= r ) x = ( l + r ) &gt;&gt; 1, check() ? ans = x, l = x + 1 : r = x - 1; printf( "%d\n", ans ); __t_ed = clock(), fprintf( stderr, "time: %.5lfs\n", double( __t_ed - __t_bg ) / CLOCKS_PER_SEC ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P2167」[SDOI2009]Bill的挑战 解题报告]]></title>
    <url>%2F2019%2F04%2F15%2Fluogu2167-solution%2F</url>
    <content type="text"><![CDATA[P2167 [SDOI2009]Bill的挑战 题目描述比赛规则是这样的：给定N个长度相同的字符串（由小写英文字母和’?’组成），$S_1,S_2,\cdots S_N$ ，求与这N个串中的刚好$K$个串批评的字符串$T$的个数（答案模$1000003$）。若字符串$S_x(1\le x \le N)$和$T$匹配，满足以下条件：1.$S_x.length = T.length$2.对于任意的$1\le i \le S_x.length$ ，满足$S_x[i]=’?’$或者$S_x[i]=T[i]$其中$T$只包含小写英文字母。 Input Data第一行一个整数 $T$，表示数据的组数。对于每组数据：第一行：两个整数，$N$和$K$（含义如题目表述）。接下来$N$行：每行一个字符串。 Output Data$T$个整数，表示个数模$1000003$的结果。 Input Sample 112345678910111213141516171819202153 3???r?????????????????3 4????????????a????????3 3????????a??j??????aa?3 2a????????????????????3 2??????????a???????a?? Output Sample 1123459148520087123467018 Data Limit对于100%的数据，$T\le 5$，$M \le 15$ ，字符串长度$\le 50$ 。 思路$f[i][j]$表示第$i$位匹配$j$(二进制表示的)字符串。然后预处理一下每一位的每一个字符能匹配哪些字符串(还是二进制表示),下面代码中即为$mc$。状态转移方程即为 f[i][j]=\sum_{k \& mc[i]['a'...'z'] = j}f[i - 1][k]也许一般DP的写法并不是很好写,具体参考代码的写法好了。滚动数组速度会变快是什么鬼)我的代码目前大概是全谷写状压DP里面跑得最快的了,抢到rk2,rk1的巨佬看起来是写容斥的) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;ctime&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#define u32 unsigned#define i64 long long#define u64 unsigned long long#define f80 long double#define rgt registerusing namespace std;#define mod 1000003template&lt;typename T&gt;inline void read( rgt T &amp;x )&#123; x = 0; rgt char t, flg(0); for ( t = getchar(); !isdigit(t); t = getchar() ) flg = t == '-'; for ( ; isdigit(t); t = getchar() ) x = x * 10 + ( t &amp; 15 ); x = flg ? -x : x;&#125;clock_t __t_bg, __t_ed;int T, N, L, K, M;char s[17][55];int mc[55][30], f[2][1&lt;&lt;15], cr, nx, cnt[1&lt;&lt;15];inline void dec( rgt int &amp;x )&#123; x = x &gt;= mod ? x - mod : x; &#125;signed main()&#123; __t_bg = clock(); read(T), M = 1 &lt;&lt; 15; for ( rgt int i = 1; i &lt; M; ++i ) cnt[i] = cnt[i &gt;&gt; 1] + ( i &amp; 1 ); while( T-- )&#123; read(N), read(K), memset( mc, 0, sizeof mc ); for ( rgt int i = 0; i &lt; N; ++i ) scanf( "%s", s[i] + 1 ); L = strlen(s[0] + 1); for ( rgt int i = 0; i &lt; N; ++i ) for ( rgt int w = 1; w &lt;= L; ++w ) for ( rgt char j = 'a'; j &lt;= 'z'; ++j ) if ( s[i][w] == '?' || s[i][w] == j ) mc[w][j &amp; 31] |= 1 &lt;&lt; i; M = 1 &lt;&lt; N, memset( f[0], 0, M &lt;&lt; 2 ), f[0][M - 1] = 1, cr = 0, nx = 1; for ( rgt int l = 0; l &lt; L; ++l, cr = !cr, nx = !nx )&#123; memset( f[nx], 0, M &lt;&lt; 2 ); for ( rgt int i = 0; i &lt; M; ++i ) if ( f[cr][i] &amp;&amp; cnt[i] &gt;= K )&#123; for ( rgt char j = 'a'; j &lt;= 'z'; ++j ) dec( f[nx][i &amp; mc[l + 1][j &amp; 31]] += f[cr][i] ); &#125; &#125; rgt int ans(0); for ( rgt int i = 0; i &lt; M; ++i ) if ( cnt[i] == K ) dec( ans += f[cr][i] ); printf( "%d\n", ans ); &#125; __t_ed = clock(), fprintf( stderr, "time: %.5lfs\n", double( __t_ed - __t_bg ) / CLOCKS_PER_SEC ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ1417」Interconnect 解题报告]]></title>
    <url>%2F2019%2F04%2F15%2Fbzoj1417-solution%2F</url>
    <content type="text"><![CDATA[BZOJ4510 假摔 Description给出无向图G(V,E).每次操作任意加一条非自环的边(u,v),每条边的选择是等概率的.问使得G连通的期望操作次数. Input第一行两个整数N,M $1\le N\le30 0\le M\le1000$接下来M行,每行两个整数X,Y表示两者之间已修好一条道路.两点之间可以不止修了一条路,也有可能M条路已使N个点成为一个整体. Output输出一个小数,表示新修道路条数的期望值,保留六位小数. Sample Input1234 21 23 4 Sample Output11.500000 思路对于一幅图,我们只在乎连通块的状态,也就是连通块大小和数量,而连通块内部具体连接并没用什么用。 经过计算,不同的状态只有5千多种,所以可以直接用vector存储状态(由于与顺序无关,所以存的时候要先排序),然后跑DP即可。 很明显,这个状态很难按照顺序枚举,所以写成记忆化搜索的形式。 至于转移方程,也不难推。 首先,在连通块内部连边是毫无卵用的,先设总共有all种连边方式,有$ts$种情况是毫无卵用的。 先提取其他情况中的$\frac 1{all}$出来(原来是$\frac{XXXX}{all}$) $f[v] = f[v] \times \frac{ts}{all} + \frac 1{all} \times XXXX + 1$ 移项一下就可以得到 $f[v] \times \frac{all-ts}{all} = \frac 1{all} \times XXXX + 1$ 再同乘$\frac{all}{all-ts}$ $f[v] = \frac 1{all-ts} \times XXXX + \frac{all}{all-ts}$ 然后就可以根据每种状态的概率转移啦qwq. 最开始的状态直接用并查集瞎搞即可。 别忘了判断边界。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;#define u32 unsigned#define i64 long long#define u64 unsigned long long#define f80 long double#define rgt registerusing namespace std;#define MAXN 55clock_t __t_bg, __t_ed;int N, M, all;int fa[MAXN];typedef vector&lt;int&gt; vc;vc v;map&lt;vc, double&gt; mp;int find( int x )&#123; return fa[x] &gt; 0 ? fa[x] = find(fa[x]) : x; &#125;inline void merge( int x, int y )&#123; x = find(x), y = find(y); if ( x != y ) fa[x] &lt; fa[y] ? swap( x, y ), 1 : 1, fa[y] += fa[x], fa[x] = y;&#125;double DP( vc c )&#123; if ( mp.count(c) ) return mp[c]; int s(c.size()), ts(0); if ( s == 1 ) return mp[c] = 0; for ( rgt int i = 0; i &lt; s; ++i ) ts += c[i] * ( c[i] - 1 ) / 2; double p(1. * all / ( all - ts )); for ( rgt int i = 1; i &lt; s; ++i ) for ( rgt int j = 0; j &lt; i; ++j )&#123; vc t(c); t[j] += t[i], swap( t[i], t[s - 1] ), t.pop_back(), sort( t.begin(), t.end() ); p += 1. * c[i] * c[j] / ( all - ts ) * DP(t); &#125; return mp[c] = p;&#125;signed main()&#123; __t_bg = clock(); while( ~scanf( "%d%d", &amp;N, &amp;M ) )&#123; memset( fa, -1, sizeof fa ), all = N * ( N - 1 ) / 2; for ( rgt int i = 1, x, y; i &lt;= M; ++i ) scanf( "%d%d", &amp;x, &amp;y ), merge( x, y ); v.clear(); for ( rgt int i = 1; i &lt;= N; ++i ) if ( fa[i] &lt; 0 ) v.push_back(-fa[i]); printf( "%.6lf\n", DP(v) ); &#125; __t_ed = clock(), fprintf( stderr, "time: %.5lfs\n", double( __t_ed - __t_bg ) / CLOCKS_PER_SEC ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>期望DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ4716」假摔 解题报告]]></title>
    <url>%2F2019%2F04%2F15%2Fbzoj4716-solution%2F</url>
    <content type="text"><![CDATA[BZOJ4510 假摔 【题目背景】小Q最近喜欢上了一款游戏，名为《舰队connection》，在游戏中，小Q指挥强大的舰队南征北战，从而成为了一名dalao。在游戏关卡的攻略中，可能由于作战过程中某艘船受到严重损伤，为避免沉没而被迫进行返航，这种情况大家称为这艘船“假摔”。小Q最喜欢使用的一艘战舰代号为P01，但是最近这艘船总是用各种不同的姿势假摔，于是小Q打算研究一下原因。 【题意描述】P01的装甲可以近似看作一个$n\times m$的矩阵，每个位置上的数字代表这个位置装甲的强度。当受到炮击时，防御力为被炮击的部分的所有位置强度之和。最近小Q发现，敌方有一种船只被称为ENE，它可以发射不同形状的炮弹，以达到攻击装甲最薄弱处的目的。P01已经被连续k次用不同方式打成了严重损伤(假摔)，于是小Q打算分析一下ENE的攻击力。为了简单起见，我们作如下假设： 1、ENE的炮弹形状无论如何变化，火力值都为一个定值(整数，未知)2、ENE的炮弹形状只能是长方形(ENE:呵呵)，且由于口径的限制，炮弹不能太小(具体来说，对于每一发炮弹长xi宽yi，有$xmin\le xi\le n，ymin\le yi\le m$)3、 当ENE的炮击命中P01的某处装甲时，被命中部分的强度之和为P01的防御力，此时，ENE的火力必须严格大于P01的防御力，才能将其击穿并造成严重损伤(假摔)。 然而，小Q并没有得到详细的中弹数据，只知道P01用k种不同的方式假摔过。两种假摔方式不同，当且仅当受到炮击的位置不完全相同。因此，不同形状的炮弹击穿护甲时必定可以造成不同的假摔方式，而相同形状的炮弹在不同的位置击穿护甲也能造成不同的假摔方式。现在，小Q想估计ENE的火力最低是多少。于是，这个任务被交给了你。 举例而言，假设P01的护甲为$3\times4$：1230 1 3 71 1 5 57 6 9 6 如果ENE的口径至少为$2\times2$，那么直接使用$2\times2$的炮弹攻击左上角$2\times2$的装甲时，只要火力&gt;=4即可造成一种假摔。如果想造成k=3种不同的假摔方式，至少要拥有12的火力，此时可以造成如下三种假摔方式：1、$2\times2$炮弹，攻击有数字的部分，装甲值为31230 1 - -1 1 - -- - - - 2、$2\times2$炮弹，攻击有数字的部分，装甲值为10123- 1 3 -- 1 5 -- - - - 3、$2\times3$炮弹，攻击有数字的部分，装甲值为111230 1 3 -1 1 5 -- - - - 可以证明，火力小于12时，无法造成3种不同的假摔方式，所以ENE的火力至少应为12。 Input第一行，五个数n, m, xmin, ymin, k，空格分隔。接下来n行，每行m个数，空格分隔，表示P01的装甲。$1\le n,m\le1000，1\le xmin\le n, 1\le ymin\le m, 1\le k\le250000$，装甲值为不超过2000的非负整数。保证火力为无穷大的ENE可以造成k种不同的假摔方式。 Output仅一行，一个数，表示ENE的火力最低值。 Sample Input12343 4 2 2 30 1 3 71 1 5 57 6 9 6 Sample Output112 思路这道题可以暴力求解。 先二分火力,然后只要判断是否满足即可。 check函数里面可以直接四重循环枚举矩阵的两个端点,由于矩阵中没有负数,装甲值是满足单调性的,不满足时可以直接退出该层循环。 然后就可以做到每次都能找到一个满足条件的矩阵,所以事实上一旦满足条件就退出就只用做k次了。 然后外层循环是$n \times m$的,于是这样看似十分暴力的做法复杂度只有$O((n\times m + k)lg(maxans) )$,完全可以轻松水过此题。 (还有前缀和优化是少不了的。。。) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#pragma GCC optimize("Ofast")#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;ctime&gt;#include&lt;cmath&gt;#define u32 unsigned#define i64 long long#define u64 unsigned long long#define f80 long double#define rgt register#define getchar() ( p1 == p2 &amp;&amp; ( p2 = bf + fread( bf, 1, 1 &lt;&lt; 21, stdin ), p1 = bf ) == p2 ? EOF : *p1++ )using namespace std;#define MAXN 1005char bf[1 &lt;&lt; 21], *p1, *p2;template&lt;typename T&gt;inline void read( rgt T &amp;x )&#123; x = 0; rgt char t, flg(0); for ( t = getchar(); !isdigit(t); t = getchar() ) flg = t == '-'; for ( ; isdigit(t); t = getchar() ) x = x * 10 + ( t &amp; 15 ); x = flg ? -x : x;&#125;clock_t __t_bg, __t_ed;int n, m, xm, ym, k, xmin, a[MAXN][MAXN];int sum( int i, int j, int x, int y )&#123; return --i, --j, a[x][y] + a[i][j] - a[x][j] - a[i][y]; &#125;inline char check( int s )&#123; rgt int tot(0); for ( rgt int i = 1, I = xm; I &lt;= n; ++i, ++I ) for ( rgt int j = 1, J = ym; J &lt;= m; ++j, ++J ) for ( rgt int x = I; x &lt;= n &amp;&amp; sum( i, j, x, J ) &lt; s; ++x ) for ( rgt int y = J; y &lt;= m &amp;&amp; sum( i, j, x, y ) &lt; s; ++y ) if ( ++tot &gt;= k ) return 1; return 0;&#125;signed main()&#123;// freopen( "data", "r", stdin ); __t_bg = clock(); read(n), read(m), read(xm), read(ym), read(k); for ( rgt int i = 1; i &lt;= n; ++i ) for ( rgt int j = 1; j &lt;= m; ++j ) read(a[i][j]), a[i][j] += a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1]; rgt int l(1), r(a[n][m]), mid, ans(0); while( l &lt;= r ) mid = ( l + r ) &gt;&gt; 1, check(mid) ? r = mid - 1, ans = mid : l = mid + 1; printf( "%d\n", ans ); __t_ed = clock(), fprintf( stderr, "time: %.5lfs\n", double( __t_ed - __t_bg ) / CLOCKS_PER_SEC ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>暴力</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P3911」最小公倍数之和 解题报告]]></title>
    <url>%2F2019%2F04%2F15%2Fluogu3911-solution%2F</url>
    <content type="text"><![CDATA[P3911 最小公倍数之和题目描述对于$A_1,A_2,\cdots,A_N$求 \sum_{i=1}^N\sum_{j=1}^N lcm(A_i,A_j)的值。 $lcm(a,b)$ 表示$a$ 和$b$ 的最小公倍数 输入输出格式输入格式：第1行，1个整数N。第2行，N个整数$A_1,A_2,\cdots,A_N$ 输出格式：1个整数，表示所求的值。 输入输出样例输入样例#1：1222 3 输出样例#1：117 说明 对于30% 的数据，$1 \le N \le 1000; 1 \le A_i \le 50000$ 对于另外30% 的数据，$1 \le N \le 50000; 1 \le A_i \le 1000$ 对于100% 的数据，$1 \le N \le 50000; 1 \le A_i \le 50000$ 思路我们先用c数组预处理出每个数出现的次数,那么原问题变为求解 \sum_{i=1}^n\sum_{j=1}^n lcm(i,j)\times c_i \times c_j其中n表示最大的数。 然后？莫比乌斯反演来一发 为了避免麻烦,这里先使$T=kd$ \begin{aligned} & \sum_{i=1}^n\sum_{j=1}^n lcm(i,j)\times c_i \times c_j\\ =& \sum_{i=1}^n\sum_{j=1}^n \frac{i \times j\times c_i \times c_j}{\gcd(i,j)} \\ =& \sum_{d=1}^n\sum_{i=1}^{\lfloor n/d \rfloor}\sum_{j=1}^{\lfloor n/d \rfloor}[\gcd(i,j)=1]d\times i \times j \times c_{id} \times c_{jd} \\ =& \sum_{d=1}^n\sum_{i=1}^{\lfloor n/d \rfloor}\sum_{j=1}^{\lfloor n/d \rfloor}\sum_{k|\gcd(i,j)}\mu(k) \times d\times i \times j \times c_{id} \times c_{jd} \\ =& \sum_{d=1}^n\sum_{k=1}^{\lfloor n/d\rfloor}\sum_{i=1}^{\lfloor n/kd\rfloor}\sum_{j=1}^{\lfloor n/kd\rfloor}\mu(k)\times d \times i \times j \times k^2 \times c_{idk} \times c_{jdk} \\ =& \sum_{T=1}^{n}T\times(\sum_{i=1}^{\lfloor n/T \rfloor}i\times c_{iT})^2\sum_{k|T}\mu(k)\times k \end{aligned}看起来十分可怕,其实都是莫比乌斯反演题的基本操作。 然后就可以开心地预处理出$\sum_{k|T}\mu(k)\times k$,暴力求解啦！ 这样的复杂度为$O(\sum^n_{i=1}\frac ni)$,即$O(n \ln n)$,可以轻松过此题。 代码123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define MAXN 50005#define rgt registerint N, M, cnt[MAXN], mu[MAXN], p[MAXN], tot, v[MAXN];LL s[MAXN];LL ans(0);int main()&#123; scanf( "%d", &amp;N ); for ( rgt int i = 1, x; i &lt;= N; ++i ) scanf( "%d", &amp;x ), ++cnt[x], M = max( M, x ); N = M, mu[1] = 1; for ( rgt int i = 2; i &lt;= N; ++i )&#123;//线性筛出mu if ( !v[i] ) p[++tot] = i, mu[i] = -1; for ( rgt int j = 1; j &lt;= tot &amp;&amp; i * p[j] &lt;= N; ++j )&#123; v[i * p[j]] = 1; if ( i % p[j] == 0 )&#123; mu[i * p[j]] = 0; break; &#125; else mu[i * p[j]] = -mu[i]; &#125; &#125; for ( rgt int i = 1; i &lt;= N; ++i ) for ( rgt int j = i; j &lt;= N; j += i ) s[j] += 1ll * mu[i] * i;//预处理提到过的那玩意 for ( rgt int T = 1; T &lt;= N; ++T )&#123; rgt LL cur(0); for ( rgt int i = 1, I = N / T; i &lt;= I; ++i ) cur += 1ll * cnt[i * T] * i;//暴力求解 ans += T * cur * cur * s[T]; &#125; printf( "%lld\n", ans ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>数学,数论</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SP26045」GCDMAT2 - GCD OF MATRIX (hard) 解题报告]]></title>
    <url>%2F2019%2F04%2F13%2Fspoj26045-solution%2F</url>
    <content type="text"><![CDATA[GCDMAT2 - GCD OF MATRIX (hard)题意简述求 \sum_{i=a1}^{a2} \sum_{j=b1}^{b2} \gcd(i,j) 这大概是我做过的最毒瘤的卡常题了。。。 膜拜区膜一发Min_25跑得最快 orz 膜一发liouzhou_101跑得第二快 orz 膜一发@Judge_Cheung 洛谷此题一血 orz 思路为了方便叙述,先进行以下处理: 1--a1,--b1 如果你来做这道题,说明你已经把GCDMAT简单版切了。 你会得到这样的柿子—— s(x,y)=\sum^{x}_{i=1} \sum_{j=1}^{y}\gcd(i,j)=\sum_{i=1}^{\min(x,y)}\varphi(i)\times\lfloor x/i\rfloor\times\lfloor y/i \rfloorans=s(a2,b2)+s(a1,b1)-s(a2,b1)-s(a1,b2)这是$O(T\sqrt n)$的算法,但是常数呢？ 首先做一次$s$有4倍常数。 然后调用4次就是4倍常数。 这16倍常数谁顶得住啊,还进行那么多次除法运算,常数当然得高到爆炸。 我们先来进行最基础的优化,优化掉一半的常数。 n=\min(a2, b2)ans=\sum_{i=1}^{n}\varphi(i)\times(\lfloor a2/i \rfloor-\lfloor a1/i \rfloor)\times(\lfloor b2/i \rfloor-\lfloor b1/i \rfloor)算一算可以发现,这样常数已经减少到8倍常数了。 但是仍然高到爆炸。/ll 先放个代码—— 1234567891011121314151617181920inline int dec( rgt int x )&#123; return x &gt;= mod ? x - mod : x; &#125;inline int rec( rgt int x )&#123; return x &lt; 0 ? x + mod : x; &#125;inline int get( int n, int x )&#123; return ( n / x ) ? n / ( n / x ) : INT_MAX; &#125; int main()&#123; rgt int i, j; for ( scanf( "%d%d%d", &amp;T, &amp;N, &amp;M ), N = max( N, M ), phi[1] = 1, i = 2; i &lt;= N; ++i )&#123; !phi[i] ? p[++tot] = i, phi[i] = i - 1 : 0; for ( j = 1; j &lt;= tot &amp;&amp; i * p[j] &lt;= N; ++j )&#123; phi[i * p[j]] = i % p[j] ? phi[i] * phi[p[j]] : phi[i] * p[j]; if ( i % p[j] == 0 ) break; &#125; &#125; for ( rgt int i = 2; i &lt;= N; ++i ) phi[i] = dec( phi[i - 1] + phi[i] ); rgt int a1, b1, a2, b2, n, ans(0); while( T-- ) for ( ans = 0, scanf( "%d%d%d%d", &amp;a1, &amp;b1, &amp;a2, &amp;b2 ), --a1, --b1, n = max( a2, b2 ), i = 1; i &gt; n ? printf( "%d\n", ans ), 0 : 1; i = j + 1 ) j = min( min( get( a1, i ), get( b1, i ) ), min( get( a2, i ), get( b2, i ) ) ), ans = dec( ans + rec( phi[j] - phi[i - 1] ) * (LL)rec( a2 / i - a1 / i ) % mod * (LL)rec( b2 / i - b1 / i ) % mod ); return 0;&#125; 这份代码的卡常程度还是十分naive的,极限数据大概要跑10s~20s左右,根本不能卡进时限。 咋办？ SPOJ上跑的最快的两位神仙——Min_25与liouzhou_101 我在推特问了Min_25,Judge用QQ问了liouzhou_101,得到两种神奇的卡常方式(都是优化除法的)—— liouzhou_101每次先预处理出所有除法,归并排序、去重,可以减少很多次除法运算。 Min_25最开始预处理出1~N的倒数,然后把除法改成乘法。然后再尽量减小运算的次数就OK了。(为了卡常数码风变得十分鬼畜,我都认不出我的代码了/xk) 代码1234567891011121314151617181920212223242526272829303132333435363738394041#pragma GCC optimize("Ofast")#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#define mod 1000000007#define LL long long#define rgt register//常数能咋省就咋省，代码不能看不是问题，常数小就行char bf[1500000],*p;inline void read(rgt int&amp;x)&#123;for (x=0;!isdigit(*p);++p);for (;isdigit(*p);++p)x=x*10+(*p&amp;15);&#125;//减小一点快读的常数//感觉快写没必要int T, N, M, pr[100005], tot, t;LL s[1000005], phi[1000005];double invs[1000005];inline int min( rgt int x, rgt int y )&#123; return x &gt; y ? y : x; &#125;//手写min(位运算似乎还不如三元运算符#define div(x,y) (int)(x*invs[y])//改成乘法优化除法signed main()&#123; bf[fread(bf,1,1500000,stdin)]='\0',p=bf; rgt int i, j; for ( invs[1] = 1, read(T), read(N), read(M), N = N &gt; M ? N : M, phi[1] = 1, i = 2; i &lt;= N; ++i )&#123; !phi[i] ? pr[++tot] = i, phi[i] = i - 1 : 0, invs[i] = 1. / i * ( 1 + 1e-15 ); for ( j = 1; j &lt;= tot &amp;&amp; i * pr[j] &lt;= N; ++j ) phi[i * pr[j]] = i % pr[j] ? phi[i] * phi[pr[j]] : phi[i] * pr[j], ( i % pr[j] == 0 ) ? j = 2000000000 : 0; &#125; rgt int n, m, a1, b1, a2, b2, at1, ta1, at2, ta2, bt1, tb1, bt2, tb2; rgt LL ans(0), tmp, *pt; for ( i = 1, tmp = 0, pt = s; i &lt;= N; ++i ) tmp = *++pt = tmp + phi[i]; while( T-- )&#123; ans = at1 = ta1 = at2 = ta2 = bt1 = tb1 = bt2 = tb2 = 0, read(a1), read(b1), read(a2), read(b2), --a1, --b1, n = a2 &lt; b2 ? a2 : b2, m = sqrt(n); for ( i = 1, pt = phi; i &lt;= m; ++i ) ans += *++pt *(div(a2,i)-div(a1,i))*(div(b2,i)-div(b1,i));//前sqrt(n)直接循环,因为数论分块得到的区间长度也都是1,直接算可以减少0.3~0.4的常数 for ( i = m + 1, tmp = s[m]; i &lt;= n; at1 &lt; i ? ta1 = div(a1,i), at1 = ta1 ? div(a1,ta1) : 2000000000, 0 : 0,//没必要重新算的千万不要重新算 at2 &lt; i ? ta2 = div(a2,i), at2 = ta2 ? div(a2,ta2) : 2000000000, 0 : 0, bt1 &lt; i ? tb1 = div(b1,i), bt1 = tb1 ? div(b1,tb1) : 2000000000, 0 : 0, bt2 &lt; i ? tb2 = div(b2,i), bt2 = tb2 ? div(b2,tb2) : 2000000000, 0 : 0, j = min(min(at1,at2),min(bt1,bt2)), ans+=(s[j]-tmp)*(ta2-ta1)*(tb2-tb1), tmp=s[j], i = j + 1 ); printf( "%lld\n", ans % mod );//最后取模减小常数 &#125; return 0;&#125; 写完这道题,你就能体会到将常数从20s卡到2.5s内的乐趣。但是我还是卡不到Min_25和liouzhou_101那么快 /ll Update on 2019.4.13发现一种更神奇的卡常方式,再加上原先的代码,可以跑得比Min_25还快!直接说出来没意思对不对。。。。 来意会一下免得那么多人来抢rk1这是一份检验某个性质是否成立的代码。 1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int N = 1000000;int main()&#123;// freopen( "out", "w", stdout ); for ( int n = 1, m; n &lt;= N; ++n )&#123; m = sqrt(n) + 1; for ( int i = m, j, cur(n / i); i &lt;= n; i = j + 1, --cur )&#123; if ( n / i != cur ) return printf( "Wrong on %d!\n", n ), 0; j = n / ( n / i ); &#125;// printf( "%d is OK\n", n ); &#125; return 0;&#125; 如果发现了什么,您就可以跑到1.5s左右,甚至可以直接抢到rk1 然后不要说出来,然别人意会去吧qwq がんばれ! 结尾彩蛋最后放上目前我最快的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#pragma GCC optimize("Ofast")#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cctype&gt;#include&lt;ctime&gt;#define mod 1000000007#define LL long long#define rgt register#define div(x,y) (int)(x*invs[y])double invs[1000005];char bf[1500000],*p;inline void read(rgt int&amp;x)&#123;for (x=0;!isdigit(*p);++p);for (;isdigit(*p);++p)x=x*10+(*p&amp;15);&#125;char ot[600000],*pp=ot; char stk[100], tp;inline void write( rgt int x )&#123; tp = 0; rgt int t; while( t=div(x,10), stk[++tp]=x-10*t, x=t ); while( *pp = stk[tp] | 48, ++pp, --tp ); *pp = '\n', ++pp;&#125;int T, N, M, pr[100005], tot, t;LL s[1000005], phi[1000005];inline int min( rgt int x, rgt int y )&#123; return x &gt; y ? y : x; &#125;int bg, ed;signed main()&#123;// freopen( "data", "r", stdin );// freopen( "out", "w", stdout ); bg = clock(); bf[fread(bf,1,1500000,stdin)]='\0',p=bf; rgt int i, j; for ( invs[1] = 1, read(T), read(N), read(M), N = N &gt; M ? N : M, phi[1] = 1, i = 2; i &lt;= N; ++i )&#123; !phi[i] ? pr[++tot] = i, phi[i] = i - 1 : 0, invs[i] = 1. / i * ( 1 + 1e-15 ); for ( j = 1; j &lt;= tot &amp;&amp; i * pr[j] &lt;= N; ++j ) phi[i * pr[j]] = i % pr[j] ? phi[i] * phi[pr[j]] : phi[i] * pr[j], ( i % pr[j] == 0 ) ? j = 2000000000 : 0; &#125; rgt int n, m, a1, b1, a2, b2, at1, ta1, at2, ta2, bt1, tb1, bt2, tb2; rgt LL ans(0), tmp, *pt; for ( i = 1, tmp = 0, pt = s; i &lt;= N; ++i ) tmp = *++pt = tmp + phi[i]; while( T-- )&#123; ans = at1 = ta1 = at2 = ta2 = bt1 = tb1 = bt2 = tb2 = 0, read(a1), read(b1), read(a2), read(b2), --a1, --b1, n = a2 &lt; b2 ? a2 : b2, m = sqrt(a2 &gt; b2 ? a2 : b2); for ( i = 1, pt = phi; i &lt;= m; ++i ) ans += *++pt *(div(a2,i)-div(a1,i))*(div(b2,i)-div(b1,i)); ta1 = div(a1,m), at1 = ta1 ? div(a1,ta1) : 2000000000, ta2 = div(a2,m), at2 = ta2 ? div(a2,ta2) : 2000000000, tb1 = div(b1,m), bt1 = tb1 ? div(b1,tb1) : 2000000000, tb2 = div(b2,m), bt2 = tb2 ? div(b2,tb2) : 2000000000; for ( i = m + 1, tmp = s[m]; i &lt;= n; at1 &lt; i ? --ta1, at1 = ta1 ? div(a1,ta1) : 2000000000 : 0, at2 &lt; i ? --ta2, at2 = ta2 ? div(a2,ta2) : 2000000000 : 0, bt1 &lt; i ? --tb1, bt1 = tb1 ? div(b1,tb1) : 2000000000 : 0, bt2 &lt; i ? --tb2, bt2 = tb2 ? div(b2,tb2) : 2000000000 : 0, j = min(min(at1,at2),min(bt1,bt2)), ans+=(s[j]-tmp)*(ta2-ta1)*(tb2-tb1), tmp=s[j], i = j + 1 ); write( ans % mod ); &#125; ed = clock(); fprintf( stderr, "%d ms", ed - bg ); return fwrite(ot,1,pp-ot,stdout),0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>数学,数论</tag>
        <tag>莫比乌斯反演</tag>
        <tag>卡常数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「黑科技」透明化应用程序]]></title>
    <url>%2F2019%2F03%2F11%2Fblack-technology-transparency%2F</url>
    <content type="text"><![CDATA[如果你想要某个应用程序变得透明,使用的同时还能看到桌面,那该咋办呢? 给出代码(C++的哦)—— 123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;#include&lt;windows.h&gt; using namespace std;#define rgt registerinline void Set( HWND hwnd, int x )&#123; SetWindowLong( hwnd, GWL_EXSTYLE, GetWindowLong( hwnd, GWL_EXSTYLE ) | WS_EX_LAYERED ); SetLayeredWindowAttributes( hwnd, RGB( 255, 255, 255 ), x, LWA_ALPHA );&#125; int main()&#123; rgt int x; printf( "Please Put The Transparency of Windows You Want To Set:(0~255)" ); scanf( "%d", &amp;x ); printf( "The Transparency is %d/255.\n", x ); Sleep(100); printf( "Please Click The .exe You Want To Set The Transparency.\n" ); printf( "1 seconds.\n" ); Sleep(1000); printf( "2 seconds.\n" ); Sleep(1000); printf( "3 seconds.\n" ); Sleep(1000); Set( (HWND)GetForegroundWindow(), x ); printf( "Finished Successfully!\n" ); system( "pause" ); return 0;&#125; 使用很easy,直接运行,输入透明度(0-255,越小越透明),然后在3s内点击某个应用程序窗口,就变透明啦！然后你就可以透明化你的Google,Dev-C++等好多东西。。。。。想变回去的话直接把透明度改为255即可。]]></content>
      <tags>
        <tag>黑科技</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SP19985」GCDEX2 - GCD Extreme (hard) 解题报告]]></title>
    <url>%2F2019%2F03%2F10%2Fspoj19985-solution%2F</url>
    <content type="text"><![CDATA[SP19985 GCDEX2 - GCD Extreme (hard) This problem is a harder version of GCDEX. Let G(n) = \sum_ {i=1}^{n} \sum_ {j=i+1}^{n} \gcd(i, j).For example, $G(1) = 0$, $G(2) = \gcd(1, 2) = 1$, $G(3) = \gcd(1, 2) + \gcd(1, 3) + \gcd(2, 3) = 3$. Given $N$, find $G(N)$ modulo 2^{64}.​ InputFirst line of contains $T$ ($1 \le T \le 10000$), the number of test cases. Each of the next $T$ lines contains a single integer $N$. ($1 \le N \le 235711131719$) OutputFor each number $N$, output a single line containing $G(N)$ modulo $2^{64}$. ExampleInput1234565141001000000100000000000 Output12345071301540716286739125482289417216306300 Explanation for Input $G(4) = \gcd(1, 2) + \gcd(1, 3) + \gcd(1, 4) + \gcd(2, 3) + \gcd(2, 4) + \gcd(3, 4) = 7$ $G(10^{11}) = 75710919967921216138364 \equiv 5482289417216306300 \pmod{2^{64}}$ InformationThere are 7 Input files. Input #0: $1 \le T \le 10000$, $1 \le N \le 10000$, TL = 1s. Input #1: $1 \le T \le 1000$, $1 \le N \le 10^{7}$, TL = 20s. Input #2: $1 \le T \le 200$, $1 \le N \le 10^{8}$, TL = 20s. Input #3: $1 \le T \le 40$, $1 \le N \le 10^{9}$, TL = 20s. Input #4: $1 \le T \le 10$, $1 \le N \le 10^{10}$, TL = 20s. Input #5: $1 \le T \le 2$, $1 \le N \le 10^{11}$, TL = 20s. Input #6: $T = 1$, $1 \le N \le 235711131719$, TL = 20s. My solution runs in 10.7 sec. (total time) Source Limit is 10 KB. First of all,建议去康康SPOJ原题的数据范围,洛谷没把数据范围搬上来。如果你是大佬但是没有看见原题数据范围,不用往下看我瞎**了,直接秒了这题。 做这道题前你需要的 脑子电脑及其配件线性筛莫比乌斯反演杜教筛数论分块 然后你就会发现这是很裸的杜教筛。。。。 思路(由于题目需要 这里$\varphi(1)=0$) \sum^n_{i=1}\sum^n_{j=i+1}\gcd(i,j) =\sum^n_{i=1}\sum^{i-1}_ {j=1}\gcd(i,j) =\sum^n_{d=1}d\sum^{n/d}_ {i=1}\sum^{i-1}_ {j=1}[\gcd(i,j)=1] =\sum^n_{d=1}d\sum^{n/d}_ {i=1}\varphi(i)然后就可以愉快地杜教筛+数论分块辣 $\varphi * 1=ID$不用我说了吧。。 接下来是代码(C++14)——(SPOJ的C++似乎不能tr1,也没有C++11,所以就用C++14算了) 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;#define LMT 20000000#define ULL unsigned long long#define UI unsigned int#define rgt registerUI T;UI n(LMT);UI p[LMT / 10 + 5], tot;ULL phi[LMT + 5], N; bool vis[LMT + 5];unordered_map&lt;ULL, ULL&gt; mp;inline ULL sum( ULL x )&#123; return ( x &amp; 1 ) ? ( ( x + 1 ) / 2 * x ) : ( x / 2 * ( x + 1 ) ); &#125;//由于2^64与2不互质,不方便用乘法逆元,直接乘再取余会爆,所以就来一波玄学操作。。。。ULL GetSum( ULL x )&#123; if ( x &lt;= n ) return phi[x]; if ( mp.count(x) ) return mp[x]; rgt ULL ans(sum(x)); for ( rgt ULL i = 2, j; i &lt;= x; i = j + 1 ) j = x / ( x / i ), ans -= ( j - i + 1 ) * GetSum( x / i ); return mp.insert( make_pair( x, ans ) ), ans;&#125;int main()&#123; scanf( "%u", &amp;T ); if ( T &gt; 200 ) n = 10000000;//避免数据小而时限小时筛完耗费太多时间 if ( T &gt; 1000 ) n = 10000; phi[1] = 1; //不要直接0了。。。否则就不是积性函数了。。。鬼知道会发生啥 for ( rgt UI i = 2; i &lt;= n; ++i )&#123; if ( !vis[i] ) p[++tot] = i, phi[i] = i - 1; for ( rgt UI j = 1; j &lt;= tot &amp;&amp; i * p[j] &lt;= n; ++j )&#123; vis[i * p[j]] = 1; if ( i % p[j] ) phi[i * p[j]] = phi[i] * phi[p[j]]; else &#123; phi[i * p[j]] = phi[i] * p[j]; break; &#125; &#125; &#125; for ( rgt UI i = 2; i &lt;= n; ++i ) phi[i] += phi[i - 1]; while( T-- )&#123; scanf( "%lld", &amp;N ); ULL ans(0); for ( rgt ULL i = 1, j; i &lt;= N; i = j + 1 ) j = N / ( N / i ),//由于我们这里的phi(1)=0,前缀和要减去1 ans += ( GetSum( N / i ) - 1 ) * ( sum(j) - sum(i - 1) ); printf( "%llu\n", ans ); &#125; return 0;&#125; 有兴趣的童鞋可以康康https://projecteuler.net/problem=625 (除了膜数几乎一样。。。。。。。。)]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>数学,数论</tag>
        <tag>莫比乌斯反演</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「整理」数学杂项]]></title>
    <url>%2F2019%2F02%2F22%2Fnotes-maths-miscellaneous%2F</url>
    <content type="text"><![CDATA[数学这种东西细小的芝士太多了。。。 一些公式与定理平方和公式 \sum^n_{i=1}i^2= \frac {n\times(n + 1)\times(2n + 1)} 6(如果要$k$次的话应该用拉格朗日插值) N方和/差公式 (a-b)^n = (a-b) \times \sum_{i=0}^{n-1}(a^{n-i-1}\times b^i) \text{(n为奇数或偶数)} \\ (a+b)^n = (a+b) \times \sum_{i=0}^{n-1}(a^{n-i-1}\times b^i \times (-1)^i ) \text{(n为奇数)} \\ (a-b)^n = (a+b) \times \sum_{i=0}^{n-1}(a^{n-i-1}\times b^i \times (-1)^i ) \text{(n为偶数)} \\Wilson定理例题:UVA1434 YAPTCHA \text{若} (p - 1)! \equiv -1 (\mod p) \text{当且仅当} p \in Prime这可以分成两个命题: $\forall p \in Prime, (p - 1)! \equiv -1 (\mod p)$(充分性) $\forall (p - 1)! \equiv -1 (\mod p), p \in Prime$(必要性) 命题1证明: 当$p=2$时,$(p-1)! \equiv 1 \equiv -1 (\mod p)$,显然成立。 当$p&gt;2$时,$p-1$为偶数,$(2 \times 3 \times \cdots \times (p-1))$显然有奇数个数。将原式转换为$2 \times 3 \times 4 \times \cdots \times (p-2) \equiv 1(\mod p)$我们记$x’ \times x \equiv 1(\mod p)$(就是乘法逆元啦)可以发现,对于每个数$x$,$x’$必然存在并只有一个,并且,$\forall a \neq b,a’ \neq b’$。(比较好证,这里不再赘述)所以$2 \times 3 \times 4 \times \cdots \times (p-2) \equiv 1(\mod p)$ 命题2证明: 假设$p$不为质数,设$p = a \times b(a &gt; 1, b &gt; 1)$。 $a \neq b$$(p-1)! = 1 \times 2 \times 3 \times 4 \cdots \times a \times \cdots \times b \cdots \times \cdots \times (p-1)$很明显$(p-1)! \equiv 0 (\mod ab)$,因此不成立。 $a = b$由$a &gt; 1,b &gt; 1$可知,$p \le 4$,因此$(p-1)! = 1 \times 2 \times 3 \times 4 \cdots \times a \times \cdots \times 2a \cdots \times \cdots \times (p-1)$很明显$(p-1)! \equiv 0 (\mod ab)$,因此不成立。 综上所述,原命题成立。 QED. 数论分块例题:洛谷P2261 [CQOI2007]余数求和 题意简述求 \sum^n_{i=1}k \mod i我们可以做一些转换—— $k\mod i = k - i \times \left \lfloor \frac ki \right \rfloor$ 原式即可转换为 $\sum k - \sum(i \times \left \lfloor \frac ki \right \rfloor)$ 我们可以$O(1)$求$\sum k$ 对于后半部分,可以证明$\left \lfloor \frac ki \right \rfloor$最多只有$\sqrt{n}$级别个取值。 为什么呢？这里给出一种不是很严谨的证法。(以下$\sqrt n$均为向下取整) 对于$i\in[1,\sqrt{n}]$中的所有数,很明显$\left \lfloor \frac ki \right \rfloor$有$\sqrt{n}$种取值。(因为总共就只有$\sqrt{n}$个数) 很明显,如果$i &lt; j$,$\left \lfloor \frac ki \right \rfloor \ge \left \lfloor \frac kj \right \rfloor$。 当$i$取$\sqrt{n}$时,$\left \lfloor \frac ki \right \rfloor$等于$\sqrt{n}$。(可能有误差,但是不会相差很大,可以忽略不计) 所以对于$i\in[\sqrt{n}+1,n]$,$\left \lfloor \frac ki \right \rfloor \in[0,\sqrt{n}]$,也是有$\sqrt{n}+1$种取值。 这样,$\left \lfloor \frac ki \right \rfloor$总共只有$O(\sqrt n)$取值,而且不难证明,对于同一种取值,$i$对应的值也是连续的。 这样就可以按$\left \lfloor \frac ki \right \rfloor$的值分成一块一块处理。 接下来怎么处理每一块的左右边界呢？ 左边界可以由上一块的右边界+1推出来。对于$s = \left \lfloor \frac ki \right \rfloor$,i最大能取的值,即右边界为$\left \lfloor \frac ks \right \rfloor$。感性理解 代码短的不行。 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long longLL N, K, ans(0), c(1), p;int main()&#123; scanf( "%lld%lld", &amp;N, &amp;K ); ans = N * K; while( c &lt;= N )&#123; p = ( K / c ) ? min( N, K / ( K / c ) ) : N; ans -= ( K / c ) * ( c + p ) * ( p - c + 1 ) / 2; c = p + 1; &#125; printf( "%lld\n", ans ); return 0;&#125; 现在我更喜欢写成for循环。 1234for ( int i = 1, j; i &lt;= N &amp;&amp; i &lt;= K; i = j + 1 )&#123; j = min( N, K / ( K / i ) ); ans -= ( K / i ) * ( i + j ) * ( j - i + 1 ) / 2;&#125; 练习洛谷P2260 [清华集训2012]模积和 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define mod 19940417#define inv_6 3323403#define MOD(x) ( ( (x) % mod + mod ) % mod )LL Work( LL N )&#123; LL ans(0), c(1), p; while( c &lt;= N )&#123; p = min( N, N / ( N / c ) ); ans += ( N / c ) * ( c + p ) * ( p - c + 1 ) / 2; c = p + 1; &#125; return ans % mod;&#125;#define fun(x) ( (x) * ((x) + 1) % mod * ((x) * 2 + 1) % mod * inv_6 % mod )LL Work2( LL N, LL M )&#123; LL ans(N * N % mod * M % mod), c(1), p; while( c &lt;= N )&#123; p = min( min( N, N / ( N / c ) ), M / ( M / c ) ); ans = ( ans + ( N / c ) * ( M / c ) % mod * MOD( fun(p) - fun(c - 1) ) % mod ) % mod; ans = MOD( ans - MOD( ( N / c ) * ( c + p ) * ( p - c + 1 ) / 2 ) * M % mod ); ans = MOD( ans - MOD( ( M / c ) * ( c + p ) * ( p - c + 1 ) / 2 ) * N % mod ); c = p + 1; &#125; return MOD(ans);&#125;LL N, M;int main()&#123; scanf( "%lld%lld", &amp;N, &amp;M ); if ( N &gt; M ) swap( N, M ); printf( "%lld\n", MOD( MOD(MOD( N * N - Work(N) ) * MOD( M * M - Work(M) )) - Work2(N, M) ) ); return 0;&#125; Update 数论分块由于有许多除法导致常数较大,我们应该进行优化。 优化比对代码放在这里。]]></content>
      <tags>
        <tag>数学,数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「学习笔记」莫比乌斯反演]]></title>
    <url>%2F2019%2F02%2F22%2Fnotes-mobius-inversion-formula%2F</url>
    <content type="text"><![CDATA[懵逼钨丝莫比乌斯反演可猥琐了QwQ 莫比乌斯反演可以用来计算一些难以用其他方法转换,数据又特别大的式子,就像下面这种—— \sum^N_i\sum^M_j \gcd(i, j)(洛谷P1447 [NOI2010]能量采集) 通过莫比乌斯反演,就可以把它变成一道可做题。 前置芝士请先学习以下芝士 数论分块线性筛 积性函数如果函数$f$满足$\forall \gcd(i,j) = 1, f(i\times j) = f(i)\times f(j)$,那么$f$为积性函数。 积性函数还可以分出一类完全积性函数。即满足$\forall i,j, f(i\times j)=f(i)\times f(j)$。 常见的积性函数有 \qquad \begin{array} \text{约数个数函数}&d(n)=\displaystyle\sum_{d\mid n}1 \\ \text{约数和函数}&\displaystyle\sigma(n)=\sum_{d\mid n}d \\ \text{约数 $k$ 次幂函数}&\displaystyle\sigma_k(n)=\sum_{d\mid n}d^k \\ \text{欧拉函数}&\displaystyle\varphi(n)=\sum_{i=1}^n [\gcd(i,n)=1] \\ \text{莫比乌斯函数}&\displaystyle\mu(n)\text{下面会介绍} \\ \end{array} P.S.[\text{逻辑表达式}]\text{表示当逻辑表达式为真,值为1,否则为0}常见完全积性函数有 \qquad \begin{array} \text{1函数}&1(n)=1 \\ \text{ID函数}&ID(n)=n \\ \epsilon\text{函数}&\epsilon(n)=[n=1] \\ \end{array}若 $f$ 和 $g$ 均为积性函数，则以下函数也为积性函数： \begin{aligned} h(x)&=f(x^p)\\ h(x)&=f^p(x)\\ h(x)&=f(x)g(x)\\ h(x)&=\sum_{d\mid x}f(d)g(\frac{x}{d}) \end{aligned}积性函数一般都可以用线性筛筛出。(这个比较简单,请自行查找资料) 莫比乌斯函数 \mu(n)= \begin{cases} 1 & n=1\\ (-1)^k & c_{1,2,\cdots,k}=1\quad(n=\displaystyle\prod_{i=1}^k {p_i}^{c_i})\\ 0 & c_i>1 \end{cases}简单地说,就是当$n$为1,函数值为1;当$n&gt;1$,若$n$为某数的平方的倍数,函数值为0;否则设$k$为$n$的质因数个数,函数值为$(-1)^k$ Dirichlet卷积(狄利克雷卷积)Dirichlet卷积可以看成函数之间的一种运算。对于两个数论函数(即定义域为正整数的函数)$f$,$g$,它们的Dirichlet卷积为 (f * g)(n) = \sum_{d|n}f(d) \times g(\frac nd)$\varepsilon$为Dirichlet卷积的单位元,即$f * \varepsilon = f$ 若$f$,$g$为积性函数,$f * g$也为积性函数。 证明: \text{设n,m,gcd(n,m)=1} \\ (f * g)(n)\times (f * g)(m) = \sum_{i|n}f(i) \times g(\frac ni) \times ( \sum_{j|m}f(j) \times g(\frac mj) ) \\ \text{变换循环顺序} \\ (f * g)(n)\times (f * g)(m) = \sum_{i|n}\sum_{j|m}f(i) \times g(\frac ni) \times f(j) \times g(\frac mj)\\ = \sum_{i|n}\sum_{j|m}f(ij) \times g(\frac {nm}{ij})\\ \text{由于n,m互质,i|n,j|m,则nm的所有因数都可以表示成ij,设k=ij}\\ (f * g)(n)\times (f * g)(m) = \sum_{k|(nm)}f(k) \times g(\frac {nm}{k}) = (f * g)(nm)Dirichlet卷积满足交换律和结合律。 前者很好证,这里省略。后者全部展开就好了,这里省略。 常见的Dirichlet卷积: \epsilon=\mu * 1 \\ d=1 * 1 \\ \varphi=\mu * ID \\我们先证明第一个,第三个(第二个这么简单就算了)也给出来,但是建议先看莫比乌斯反演。 证明$\epsilon=\mu * 1$: \epsilon(n)=\sum_{d|n}\mu(d)根据唯一分解定理,我们可以用$n$的质因数($p_1,p_2,p_3…$)来组成$d$。 很明显,每个$p_i$取两个或以上对答案是没有影响的(根据定义,$\mu$函数值为0)。可以得出以下式子 \text{设n有t个质因数} \\ \epsilon(n)=\sum_{i=0}^t (-1)^i \times C_t^i根据二项式定理,如果n为1,值为1,否则为0说实话我从二项式定理看不出这点。(大概是我太菜了吧)我们可以从排列组合方面考虑。我们设$f(i,j)=(-1)^i \times C_i^j$则$f(i,j) = f(i - 1,j) - f(i - 1, j - 1)$ \sum_{i=0}^t f(t,i) = f(t - 1, 0) + ( \sum_{i=1}^{t-1}(f(t-1,i)-f(t-1,i-1))) - f(t - 1,t - 1)很明显这是可以两两消去的。(当然,t = 0时除外) 可以得出 \epsilon(n)=\sum_{i=0}^t (-1)^i \times C_t^i = [n = 1]接下来的证明请先学习莫比乌斯反演。 证明$\varphi=\mu * ID$: 可以利用欧拉函数的定义+莫比乌斯反演来证。 我们先在等式两边同时卷1 \varphi * 1 = 1 * \mu * ID \\ \varphi * 1 = \varepsilon * ID \\ \varphi * 1 = ID \\ (\varphi * 1)(n) = \sum_{d|n}\varphi(d) = \sum_{d|n}\varphi(n / d)可以认为上面柿子中$\varphi(n / d)$表示$\sum_i=1^n[gcd(n,i)=d]$,很明显,每个数与$n$的公约数不变,对答案有且仅有$1$的贡献,最终的值即为$n$ 莫比乌斯反演总算写到这里了(掩面痛哭 对于两个数论函数$f$,$g$ f = g * 1 \Leftrightarrow f * \mu = g直接用Dirichlet卷积即可。 f = g * 1 \\ \text{两边同时卷} \mu \\ f * \mu = g * 1 * \mu \\ f * \mu = g * \varepsilon \\ f * \mu = g例题洛谷P2522 [HAOI2011]Problem b 题意对于给出的$n$个询问,每次求有多少个数对$(x,y)$,满足$a\le x\le b,c\le y\le d$,且$\gcd(x,y)=k$,$\gcd(x,y)$函数为$x$和$y$的最大公约数。 思路我们可以求$x \le n,y \le m$,差分处理即可。我们认为n &lt; m,否则交换即可。以下/均表示整除 Ans = \sum_{i=1}^n\sum_{j=1}^m[gcd(i, j) = k] \\ Ans = \sum_{i=1}^{n/k}\sum_{j=1}^{m/k}[gcd(i,j)=1] \\ \text{设n/k=a,m/k=b} \\ Ans = \sum_{i=1}^{a}\sum_{j=1}^{b}\varepsilon(gcd(i,j)) \\ Ans = \sum_{i=1}^{a}\sum_{j=1}^{b}(\mu * 1)(gcd(i,j)) \\ Ans = \sum_{i=1}^{a}\sum_{j=1}^{b}\sum_{d|gcd(i,j)}\mu(d) \\ Ans = \sum_{i=1}^{a}\sum_{j=1}^{b}\sum_{d|i,d|j}\mu(d) \\ Ans = \sum_{d=1}^{a}\sum_{i=1}^{a/d}\sum_{j=1}^{b/d}\mu(d) \\ Ans = \sum_{d=1}^{a}\mu(d) \times (a/d) \times (b/d)然后我们就可以筛出$\mu$ -&gt; 前缀和 -&gt; 数论分块啦 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 50000int T, a, b, c, d, k;int mu[MAXN + 5], p[MAXN + 5], tot;bool vis[MAXN + 5];int Work( int N, int M )&#123; int ans(0); if ( N &gt; M ) swap( N, M ); for ( int i = 1, j; i &lt;= N; i = j + 1 )&#123; j = min( N / ( N / i ), M / ( M / i ) ); ans += ( N / i ) * ( M / i ) * ( mu[j] - mu[i - 1] ); &#125; return ans;&#125;int main()&#123; scanf( "%d", &amp;T ); mu[1] = 1; for ( int i = 2; i &lt;= MAXN; ++i )&#123; if ( !vis[i] ) p[++tot] = i, mu[i] = -1; for ( int j = 1; j &lt;= tot &amp;&amp; p[j] * i &lt;= MAXN; ++j )&#123; vis[p[j] * i] = 1; if ( i % p[j] ) mu[p[j] * i] = -mu[i]; else &#123; mu[p[j] * i] = 0; break; &#125; &#125; &#125; for ( int i = 1; i &lt;= MAXN; ++i ) mu[i] += mu[i - 1]; while( T-- )&#123; scanf( "%d%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d, &amp;k ); --a; --c; a /= k; b /= k; c /= k; d /= k; printf( "%d\n", Work( b, d ) - Work( a, d ) - Work( c, b ) + Work( a, c ) ); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数学,数论</tag>
        <tag>学习笔记</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「学习笔记」欧几里得算法gcd/扩展欧几里得算法exgcd]]></title>
    <url>%2F2019%2F02%2F09%2Fnotes-gcd-exgcd%2F</url>
    <content type="text"><![CDATA[前面部分面向初学者,会gcd的跳过 如果让你求两个数的公约数,你会怎么做?枚举?这显然太慢了。如果数据规模达到1e9就完蛋。这有2种方法解决。我们用gcd(x,y)表示x与y的最大公约数,lcm(x,y)表示x,y的最小公倍数。 九章算术·更相减损术$\forall a,b \in N, a \ge b,\text{有} \gcd(a,b) = \gcd(a-b,a) = \gcd(a-b,b)$这个定理很好证明,这里就省略了。其实是我懒然后利用这个定理,就可以写出代码了。 递归写法1int gcd( int x, int y )&#123; return x == y ? x : ( x &gt; y ? gcd( y, x - y ) : gcd( x, y - x ) ) &#125; 非递归写法1int gcd( int x, int y )&#123; while ( x != y ) if ( x &gt; y ) x -= y; else y -= x; return x; &#125; 这种算法的缺陷是显而易见的。当两个数相差较大时,这种算法就吃不消了。比如这组数据11 1000000 能卡掉递归写法(爆栈) 这组数据11 1000000000 连非递归写法也会TLE 不过有一个小优化:当x % 2 == 0 &amp;&amp; y % 2 == 0可以同除以2,并最后结果乘2。 123456int gcd( int x, int y )&#123; int ans(1); while( !(x &amp; 1) &amp;&amp; !( y &amp; 1 ) ) x &gt;&gt;= 1, y &gt;&gt;= 1, ans &lt;&lt;= 1; while ( x != y ) if ( x &gt; y ) x -= y; else y -= x; return x * ans;&#125; 不过还是通不过上面那组数据。我们要引入更niubi的算法。 欧几里得算法/辗转相除法根据更相减损术,我们可以进行变形。$\gcd(x,y)=\gcd(y,x%y)$看看上面那组数据,能卡掉更相减损术的原因就是1000000000连续减了999999999次1,这可以简化成1步——取余不过我们发现有一个会变成0,这时候直接返回另一个就行了。 直接上代码。1int gcd( int x, int y )&#123; return y ? gcd( y, x % y ) : x; &#125; 好像它的复杂度是log级别的,具体我也不会证明。反正快得多就行了。一般我们都用这种方法。由于递归层数也是log级别的,没必要改成非递归。 Stein算法如果要求高精度最大公约数咋办?用Python或Java 高精度取余十分麻烦。这意味着不能方便地使用欧几里得算法。 一般我们可以用更相减损术,但是如果遇上毒瘤出题人咋办？直接把你卡到O(N)级别。 由J. Stein 1961年提出的Stein算法很好的解决了以上算法中的缺陷,Stein算法只有整数的移位和加减法。]]></content>
      <tags>
        <tag>数学,数论</tag>
        <tag>同余</tag>
        <tag>gcd,exgcd</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「学习笔记」中国剩余定理crt/扩展中国剩余定理excrt]]></title>
    <url>%2F2019%2F02%2F09%2Fnotes-crt-excrt%2F</url>
    <content type="text"><![CDATA[学了好久才会QAQ 我真的好菜呀]]></content>
      <tags>
        <tag>数学,数论</tag>
        <tag>同余</tag>
        <tag>crt,excrt</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HEXO插件」嵌入pdf文件 hexo-pdf]]></title>
    <url>%2F2019%2F02%2F09%2Fhexo-pdf%2F</url>
    <content type="text"><![CDATA[闲着没事逛了逛hexo插件,偶然发现hexo-pdf,就顺便整了个…. 如果你需要在你的博客里加入pdf文件,怎么办?当然,你可以用&lt;iframe&gt;标签,但那一串东西实在记不住QAQ…. 不扯了,直接进入正题吧。 先下载下来1npm install hexo-pdf 在_post中加入一个md文件test.md(或者根据喜好随便取名,当然后缀还得是md) 如果是在网上的pdf文件,就例如 http://XXX.com/...../test.pdf 这样的,可以这么干——1&#123;% pdf http://XXX.com/...../test.pdf %&#125; 如果要本地上传,可以自己找个位置一起上传就好了。(注意我在source新建一个images的文件专门用来放图片等东西) 1&#123;% pdf \images\test.pdf %&#125; 效果是这样的手动滑稽 没了。。。。]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>博客美化</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my aims]]></title>
    <url>%2F2019%2F02%2F09%2Fmy-aims%2F</url>
    <content type="text"><![CDATA[猜猜看密码吧,我才不告诉你 Incorrect Password! No content to display! U2FsdGVkX19h4Gd+PmhEfRm7qSfCeVd9E5ouVC6oBU+mlo7ry/zN95ROw92TdXJitY1XQe7xeYo/na2eNYZDuhx3ph5KbjJHvkyOOwEaJTMXcCTIGUCPj6fcfQkHkC8MDNlGpID+RWso/VI57Gyx7j68RIi6ZSXQrdejA7RT0kvjqAc3CQEzDsPAu0q20VzJW/HNgOck4iVwVit8ESZbzxR8EsoCCPHznCUac/8l8rCXQLf1CQm8UoJQN00GQs/U2XO27sw113JNsnzO8UdyztHa9Uelwii+oec1xD9MWnyLMz6k3byeW8EgT3BhVOpkOuN9rmdbZaulqcqzGQcr/X/YdouDvp5lirwLQZ3RT2w8thtaTnUZz7tFbJ60G1B7bq1FESOzc+ehrO3SZQyG2nynMZ9R9XfmgQrmb5G4qaBbTkTN4tEnd9U1XfsPY43lOjouDahIuglusYpjoMQEzeuzon1Aos75GfVnT8Y9mub5Wr0B7Qx87W+gCaw4pgET84TGwDKgovZYfrE10EiHBuVPo4K8DkUPTHyZP2bLokqtUdp0pKWQJfLSXm/Bsw8/rsWo22tMBEoPZFuDVuF1PWY8G8tK2tk/GL6fBnIddoCAVmgMafgMVqidHHl/traKSUPwsDRJeaqFRvkAXW9+7ZO34NxTj6TnrwYxVIRqhVOzdUR/V84+h1sCqSO9/SYXHXottt+2ZGeaTASteVr6ask3SwJGqoRNWXhRJHUIp2N1dzGnBFjLfmzgLiQU5zwz1IT8PG8bvvcZYr8/o1t+ex/sunzvS5lFtpCDBuR8ITGsZtwBQkQdoTI6lMVgsGgiuQx682CxrMs1+h4oyqE+fLI30As+hD0T59xmoHn35GnFA0aPfUqNaR8L8kSdhtmUD28aicqDqbdPxLOYqT0FzvP05G9FMcky2fuB8vpQ5npvtoTn3B/CoCubWStuT3pZDQAfPg9H224BQMRxMgCXTsqvRRHnSmsa+a68RBHu4C5xjj750YAfWYoFEVzRwh1505bElMWOD/rRp8tz7kDzdWUpYYJER0gpmEDv06BqqgoNPP3dZTb0RFFYcUKZvHpEK+ubw6KgaanIXENJ4+bottNMHTgvX7OTDkS/wywbmFMcbPreSyAVeMdNRq1S9KcQSD77eB4OWb08ZhGE2yhodN/XzyrmWin9XB8XhbQLDfFEy/ECY5Y8DqbBCZt8o9Ao6YF5tc41wdYF1zMv3aftB2W6p0kuwtmvHxM1IYGHuY/YuKDXakCfygWxrmVBrCYS4iz1Ot+aRJL01FBHhf43Ycacc41sPz8KR2LEGXJmQKfPAMXyiNobNRcPppfCo6pHKaKYGebAGrcIZA+/sxIXBRLO+tJYr5QxG3Kmus4ex5+fCg4gwOUWX8sludoFQWKQHFxwQnOa+XAAvjFaiOI+2pERO+fgvW165Adc2XWsHLfFz1mzk6cjhpVtMTTO86PEsHQz/RQvnCkmZZO6W0GKwmfukMyA18MHRPbeheCF1z7aKPot8RPHPZFX5x3MNItEF/V1yu666fZejAYG3XZrFjCWUWq9ZoRiEE54tR6dxq74XaQRemO4R7dbSObzGckbFD4Jc02Dh6ki+iBGyzQ+1ym9+GIEt2RuAnbArh8C5D6YPzDqCyfHUTHxpjttcLx+iEdtiVLUaTI087Xgme2+V0XqM0SnitnNz2geN46UInJWwF1kPhwPv3miOxFv+g/7dF/X1PaWY9miLbhEMEqeYBxFvzrXzM8awGqnruKUhOQ40zTq2nZOa7WbKo0HMxjfQ5jKAQ9SLRfaMaSqememAvougKPlvxeJL1VrAJGvX2ua2K30fa68keDotVuXIPDynw2kZoteTemh/LTK7ndsQNG7ficm3df+/nkptWVYuevStCo4ytJUBlXG6QxCMMsHj2MEkiIalQEzDVvxIwYat14mprqAo2J4B92az1t6zEW7nkpqq3hFkejsASFbh/F0ISNTkH5/idhT5Cgw8UnSgEYTw5bMLDnDXUmXOwD6sNDl/Iz7eMKWFXxJ69PgO/3C6jyuPBj760XjLxAH7SiSlDZMQmDnEbQ2OtLr9xiDtUXrQtxX/J9Eo2xkVcn2mLghrlmB00DK90ZoOoVAOjtaRLcosIYJHL/8hKLvQVFBAJ3dn9oiQBM7v0R0pItMOIqDmiZ9LF6UeHLnQOkqWJTSkFmqNKxnSbdiam+7CRjBnTGUnxjkwXVfnCPCrsA2W0ricVI8Osh1UtyycNHSIDMSJxZ/mkrOzmAN5i2GCi3S8biDdN1jhauurGz96tohd+yP6Zb47wjl8mV0U8+oHQ/uOjU7OuPb14gYsm0zIr/luwLaIubbN7IOORHVpr65TmvdvcTV6gNECF0+zgrrFo33mjznQoj+YLevs/pyxJz+mPEDAD8HKHJDhwy3SxG0190xmxdlHTO4WN9Yky+T8QR3nDeigJ2ScGsKcDBNtSvZ8AXcdeh6uyCkeSE2IgyImyKFmOIhPWQByLBm5eN2VyAZZ+Gg1gMPR+n1ZDk3F1GAiVSsokANmWTIVgVnEF6RbdXoXaTi3yCt2m+U+vi++s134sUlZlsAKNomoUDJJHsnt0n9fivDmnhGhpTPudvxIL/yxSdE4AZ2C2Fmx3ccfxLJ2e5i7O/mBDaRSJOgvdMeCf0aLFBcPYYoBoXj0MaabOKvlKWxvd9jHaTeXX/OscfA3d1tMBelmqfogyLrOkxboiKe9UB8GqJrkqVZEyBXIE34sOGOX0T7DWSBeCqzaVk8Xdf2F3CWEtPVw17yk/wdldIeinac5mRBrHmNBD+NXxW5d3p/TihnkBhk3kDXIGVuh57/pIBeCgrnjE8RzaO907/eqsB8yanUkRsYR8sW3b//RlUaC4Nxhu+vPlmkTGGQg4MMTi7UefLkBndiPVPgPwNdlMEv2ukteTsVRtj8o9XFMlDR+IQwfnUPWGq7BetbW7bB05NnKeLgYe65FU+zvLUPeLpkz0u5Yefb8LELYdNiX9mHGn3aEVpZ6OCfiSusXBbQc+iEBuo7aS1+/fota8pYN7ZesfovePeFr2e4OkJIUSPQe92Xeof+rWBUe6Vo2xK0AiM7ieiR5i4747AcUj73MoPEZ1BCXIRsAio8xAm8xOIlJJmi4R6v54gH4kLX2NNZB/uVi/mCQZZx5uziyX4Sj0ijmqMjlqXy8jBNjtZ8IPZqSD1rV0OC9s0FSlAfxyc2UKAnG0EEGkhmHtvE+ieUJx+9Dgq7zoPGoRMeMA0zjqqZ8MTpC3KaboMAY1OKkRjSKeYNm0rSrgQft8XSu9y3syhK+XRsPYEELXJIS/283DBrE3+MWKq2oIOBISGf+3nODio928tGxhsE6awXUopXvkze3227xXmJUITgR+52RQRj5CrDqskpj4w4yPEb+UXBOXxswkFc7O/r7fmWJdhILHQwt1qkFRCA0vRVVNeueb78TqgpKZabuznHE8BottA8Zh6Z1FHb1uGaPWaRIW3+WbqxEsj4u5yCDiHg+lp7Wy59kSrAZ/vvKJbQlxh+og+tppv6l+cw+RqZIpUV0aRjy37d+9ZDbgMgKZuXltkPYlBQQ+HvcDO3th1QFVMo8F2WcsYFkHDMan0Sn5YdMqsb0ZS34ca014iI57RT+ajYzBMmeTav+d3AiZLAuf1UT4qcsZEskzoCQks+DUPKTw2i30nYAqUQvfHQSGMBC5ABSeOwdP5UrQ5xiLA3gMLscSang3LQA7Lstuap1OJJOD4URnqeghfhrBlOf1i77QPWcULA4m0Q2m7IQUI5fDWx7u2F39b57AYWwta+UAro0Q5i8kgGWH4EPJJwD29To4P+0ApTHWZn4p2eFG5l63w12tHmPkiIGtiq8V1nZbuiOQKpqrA+9N7YIJYqhv2whmi7Fp/SKPOxCJgb2p6JKRtLqdFTlKxCzAXx8Gz47Utpb1w3sQ4Ui47N4U+BzxQ+t9bsfs/SuI62ORVEb1C25X640wFEHT4INtnfDGet5d2l5nG4w7Wm1EkO7xF+qUDmY1A/KiCRjG6S+iGvAkzrmdZsFNzgKoqSj5eTz1PwoOSffD+U7JJCatAAAbEEP+52IV6Pu7aQIPJsCgW9c1mBitRht2OvVmtqEja7ITjFej+jQUl2WGuZ1VfPL9pSIX5hjNZDRgcwP+wL0aasC/9MflzFfvm1ilxRQAlJIdTfYUjB7H4=]]></content>
      <tags>
        <tag>你看不得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「博客美化」添加live2d看板娘]]></title>
    <url>%2F2019%2F02%2F09%2Fhexo-live2d%2F</url>
    <content type="text"><![CDATA[在cmd中先进入博客根目录(以我自己的博客为例)1cd louhc 安装npm包1npm install --save hexo-helper-live2d 再选择一个喜欢的看板娘！预览可以看这里。我用的是z16啦 如果你玩过碧蓝航线肯定知道(好吧我刚开始也不知道) 123456789101112131415161718192021npm install live2d-widget-model-chitosenpm install live2d-widget-model-epsilon2_1npm install live2d-widget-model-gfnpm install live2d-widget-model-harunpm install live2d-widget-model-harutonpm install live2d-widget-model-hibikinpm install live2d-widget-model-hijikinpm install live2d-widget-model-izuminpm install live2d-widget-model-koharunpm install live2d-widget-model-mikunpm install live2d-widget-model-ni-jnpm install live2d-widget-model-niconpm install live2d-widget-model-nietzschenpm install live2d-widget-model-nipsilonnpm install live2d-widget-model-nitonpm install live2d-widget-model-shizukunpm install live2d-widget-model-tororonpm install live2d-widget-model-tsumikinpm install live2d-widget-model-unitychannpm install live2d-widget-model-wankonpm install live2d-widget-model-z16 然后在根目录中的_config.yml文件中改一改。在最后面把下面这些复制进去就好了 12345678910111213141516171819# Live2D## https://github.com/EYHN/hexo-helper-live2dlive2d: enable: true # enable: false scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-z16 # &lt;-把你喜欢的看板娘名称复制到这里 # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url 如果你想自定义的话(很烦的QAQ)右转百度我也不会 然后就完了。简单吧。。。。]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>博客美化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SP26368」PWRANDMOD - Power and Mod 解题报告]]></title>
    <url>%2F2019%2F02%2F03%2Fspoj26368-solution%2F</url>
    <content type="text"><![CDATA[PWRANDMOD - Power and Mod Exponentiation is a mathematical operation, written as $b^n$, involving two numbers, the base $b$ and the exponent $n$. When $n$ is a positive integer, exponentiation corresponds to repeated multiplication of the base: that is, $b^n$ is the product of multiplying n bases: $b^n = b \times b \times b \times ………. \times b$ In computing, the modulo operation finds the remainder after division of one number by another (sometimes called modulus). Given two positive numbers, $a$ (the dividend) and $n$ (the divisor), $a$ modulo $n$ (abbreviated as $a$ mod $n$) is the remainder of the Euclidean division of $a$ by $n$. For instance, the expression “5 mod 2” would evaluate to 1 because 5 divided by 2 leaves a quotient of 2 and a remainder of 1, while “9 mod 3” would evaluate to 0 because the division of 9 by 3 has a quotient of 3 and leaves a remainder of 0; there is nothing to subtract from 9 after multiplying 3 times 3. Now, you are given the value of a,b and m. print the value of $a^b \mod m$ InputFirst line contains the number of test cases $t (1 &lt;= t &lt;= 10^4)$. Next $t$ line contains three integers $a$, $b$ and $m$. where $1 &lt;= a, b &lt;= 10^9$ and $1 &lt;= m &lt;= 2^{64}$ OutputFor each test case print the answer of the problem. Sample input12322 3 43 4 5 Sample output1201 思路很沙比的快速幂。。。。但是数据范围十分坑，刚好long long存不下。。。咋办？__int128！但是__int128不能直接用cin或scanf读入，要自己手写（习惯写快读的童鞋就没关系了）还有，不知道怎么回事__int128也WA了，于是还写了个龟速乘，然后就过了？？？个人认为不写龟速乘也不会爆。（可能写炸了吧？）下面就是代码辣该讲的都放在注释里 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;#define LL __int128LL T, a, b, m, ans;char bf[1 &lt;&lt; 25], *p;LL read()&#123;//快读 LL x(0); while( !isdigit(*p) ) ++p; while( isdigit(*p) ) x = ( x * 10 ) + ( *p ^ '0' ), ++p; return x;&#125;void write( LL x, bool flg = 1 )&#123;//快写(懒得用fwrite if ( x == 0 )&#123; if ( flg ) putchar('0'); return; &#125; write( x / 10, 0 ); putchar( x % 10 + '0' );&#125;LL Mul( LL x, LL y )&#123; LL ans(0); for ( x %= m; y; x = ( x + x ) % m, y &gt;&gt;= 1 ) if ( y &amp; 1 ) ans = ( ans + x ) % m; return ans; &#125;//龟速乘LL Pow( LL x, LL y )&#123; LL ans(1); for ( x %= m; y; x = Mul( x, x ), y &gt;&gt;= 1 ) if ( y &amp; 1 ) ans = Mul( ans, x ); return ans; &#125;//快速幂//我这里用位运算方法实现，当然如果你喜欢二分也完全没有问题int main()&#123; bf[fread( bf, 1, 1 &lt;&lt; 25, stdin )] = '\0'; p = bf; T = read(); while( T-- )&#123; a = read(); b = read(); m = read(); ans = 1;//别忘了初值 write(Pow( a, b )); putchar('\n');//调用函数即可 &#125; return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>数学,数论</tag>
        <tag>快速幂</tag>
        <tag>sb题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 1107B」Digital root 解题报告]]></title>
    <url>%2F2019%2F01%2F31%2Fcodeforces-1107B-solution%2F</url>
    <content type="text"><![CDATA[思路这题看上去很不可做的样子,实际上找到规律就炒鸡简单。 先打表找规律 12345678S(1)=1S(2)=2..S(10)=1S(11)=2..S(18)=9S(19)=1 不管怎么说吧,根据从1到1000所有的数(自己写个代码验证就好了)Digital root都是从1到9不断循环的。 咋证明呢？我们先来证明一个引理： 设$F(N)$表示$N$每位数的和。$F(N)\equiv N(\mod 9)$ 证明：($\LaTeX$打的手酸) \text{设N的各位数字为}a_1,a_2...a_p\text{(p表示N有几位数)} \\ \because N=a_1+a_2\times10+a_3\times10^2...+a_p\times10^{p-1}\\ \therefore N=a_1+a_2\times(9+1)+a_3\times(99+1)+..a_p\times(999..9+1)\\=a_1+a_2+a_3+...+a_p+(a_2\times9+a_3\times99+a_4\times999+...a_p\times999..9)\\ = F(N)+(a_2\times1+a_3\times11+a_4\times111+...a_p\times111..1)\\ \therefore N\equiv F(N)(\mod 9)\\QED.实际上,$S(N)$就是若干$F$运算嵌套在一起。 即$S(N)=F(F(F(…F(N))))$ 而根据上述结论来看$N\equiv F(N) \equiv F(F(N))\equiv F(F(F(N)))….(\mod 9)$ 所以,$S(N)\equiv N(\mod 9)$ 而$S(N)$不为0且为个位数,因此$S(N)=(N-1)\mod 9+1$ 代码123456789101112#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long longint T;LL k; int x;int main()&#123; scanf( "%d", &amp;T ); while( T-- ) scanf( "%I64d%d", &amp;k, &amp;x ), printf( "%I64d\n", ( k - 1 ) * 9 + x ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>打表</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Claris’ Contest #2 Day 2 解题报告]]></title>
    <url>%2F2019%2F01%2F28%2FClaris'-Contest-2-Day-2-solution%2F</url>
    <content type="text"><![CDATA[题目、标程等 只有100+0+20 QAQ T2 MLE完美爆零 QAQ我不应该开long long的 QAQ 膜拜把我吊打的巨佬们 T1 Divisors题意简述给出大小为$M$的正整数序列$A$，对于每个K$0 \le K \le M$，求出在[1,N]中有多少数恰好是序列$A$中$K$个数的约数。数据范围$1\le M \le 200$，$1\le N \le 10^9$ 思路枚举出序列$A$中的所有约数并统计个数、去重即可。我们用一个map来统计个数。时间复杂度为$O(M\sqrt{N}logN)$如果用unordered_map可以更快。时间复杂度为$O(M\sqrt{N})$。但这里用map就够了。 代码123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;#define open(s) freopen( s".in", "r", stdin ), freopen( s".out", "w", stdout )#define MAXN 205int N, M;int a[MAXN], cnt[MAXN];int v[100005], s;map&lt;int, int&gt; mp;int main()&#123; open("div"); scanf( "%d%d", &amp;N, &amp;M ); for ( int i = 1; i &lt;= M; ++i ) scanf( "%d", &amp;a[i] );//读入 for ( int i = 1; i &lt;= M; ++i )&#123; for ( int j = 1; j * j &lt;= a[i]; ++j )&#123; if ( a[i] % j == 0 )&#123; v[++s] = j; mp[j]++;//找出所有因数 并统计个数 if ( j * j != a[i] ) v[++s] = a[i] / j, mp[a[i] / j]++; &#125; &#125; &#125; sort( v + 1, v + s + 1 );//排序去重 s = unique( v + 1, v + s + 1 ) - v - 1; cnt[0] = N; for ( int i = 1; i &lt;= s; ++i ) if ( v[i] &lt;= N ) cnt[mp[v[i]]]++, cnt[0]--;//注意判断是否在区间内 for ( int i = 0; i &lt;= M; ++i ) printf( "%d\n", cnt[i] );//输出 return 0;&#125; unordered_map优化代码123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;#include&lt;tr1/unordered_map&gt;using namespace std;using namespace tr1;#define open(s) freopen( s".in", "r", stdin ), freopen( s".out", "w", stdout )#define MAXN 205#define Re registerint N, M;int a[MAXN], cnt[MAXN];int v[100005], s;unordered_map&lt;int, int&gt; mp;int main()&#123; open("div"); scanf( "%d%d", &amp;N, &amp;M ); Re int i, j; for ( i = 1; i &lt;= M; ++i ) scanf( "%d", &amp;a[i] ); for ( i = 1; i &lt;= M; ++i )&#123; for ( j = 1; j * j &lt;= a[i]; ++j )&#123; if ( a[i] % j == 0 )&#123; if ( j &lt;= N ) v[++s] = j, mp[j]++; else break; if ( j * j != a[i] &amp;&amp; a[i] / j &lt;= N ) v[++s] = a[i] / j, mp[a[i] / j]++; &#125; &#125; &#125; sort( v + 1, v + s + 1 ); s = unique( v + 1, v + s + 1 ) - v - 1; cnt[0] = N; for ( i = 1; i &lt;= s; ++i ) cnt[mp[v[i]]]++, cnt[0]--; for ( i = 0; i &lt;= M; ++i ) printf( "%d\n", cnt[i] ); return 0;&#125; T2 Market题意简述有$N$件物品，每个物品$i$有一个价值$v_i$与花费$c_i$，每个物品$i$在时间$T_i$后才能取用且最多只能取用一次。多次询问，给出时间$T$、钱数$M$，求能得到的最多价值。数据范围$1\le N,v_i,T_i,T \le 300$，$0\le c_i,M \le 10^9$ 思路这题可以离线做，也可以在线做。先讲在线做法。先按照$T_i$给每个物品排序。排序后如果物品$i$能取到，物品$1 ~ i-1$也都能取到（开始取的时间在它之前）。然后考虑用动态规划解决这一问题。很显然，这是一个背包问题。但是如果以通常思路，把花费作为背包容量，无论是空间复杂度还是时间复杂度都无法承受。所以要把价值作为背包容量。 先定义1int f[305][300*300+5];//f[i][j]表示取物品i后能得到j价值的最小花费 然后是基本的0/1背包，这里不再赘述。1234for ( int i = 1; i &lt;= N; ++i )&#123; for ( int j = 0; j &lt; s[i].v; ++j ) f[i][j] = f[i - 1][j]; for ( int j = s[i].v; j &lt;= 90000; ++j ) f[i][j] = min( f[i - 1][j], (int)min( 1ll * f[i - 1][j - s[i].v] + s[i].c, 2000000000ll ) );&#125; 注意下数据范围，花费可能超过int范围，本来要开long long，但是由于内存限制，只能开int。很显然，超过$M$的花费都是没用的。因此只要大于(注意是大于不是大于等于)$1\times10^9$的都是没用的，效果都是相同的。因此与$10^9+1$或更大的数取min即可。 （HINT:这里由于有多次询问，在线做法不能滚动数组，同时没必要倒序循环） 查询时当然不能暴力枚举，我们得用二分。但是很显然，得出的f数组不一定是单调递增的。不过，我们可以再来一次循环，把f[i][j]的意义修改为取物品i后能至少得到j价值的最小花费。倒序循环一次即可。这样就可以维持f数组的单调性。 1for ( int i = 1; i &lt;= N; ++i ) for ( int j = 89999; j &gt;= 0; --j ) f[i][j] = min( f[i][j], f[i][j + 1] ); 查询时，先二分找出最后一个能取到的（时间能满足要求的） 123456l = 1; r = N; sp = 0;while( l &lt;= r )&#123; mid = ( l + r ) &gt;&gt; 1; if ( s[mid].t &lt;= T ) sp = mid, l = mid + 1; else r = mid - 1;&#125; 然后再来一次二分，找出最大的满足要求的价值。（价钱不能大于$m$） 123456l = 1; r = 90000; ans = 0;while( l &lt;= r )&#123; mid = ( l + r ) &gt;&gt; 1; if ( f[sp][mid] &lt;= m ) ans = mid, l = mid + 1; else r = mid - 1;&#125; 最后输出$ans$即可。事实上，f[i][j]中$i$表示时间点的话可以省掉前一个二分。 离线做法直接把询问按照$T$排序,依次加入物品就好了。加上滚动数组可以把f数组降一维。 速度不是很可观,最慢的点整整跑了0.81s 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;#define open(s) freopen( s".in", "r", stdin ), freopen( s".out", "w", stdout )#define LL long longint N, M;struct shop&#123; int c, v, t; inline void input()&#123; scanf( "%d%d%d", &amp;c, &amp;v, &amp;t ); &#125; bool operator &lt; ( const shop &amp;x )&#123; return t &lt; x.t; &#125;&#125;s[305];int f[305][90005];int T, m;int main()&#123; open("market"); scanf( "%d%d", &amp;N, &amp;M ); for ( int i = 1; i &lt;= N; ++i ) s[i].input(); sort( s + 1, s + N + 1 ); memset( f, 0x3f, sizeof f ); f[0][0] = 0; for ( int i = 1; i &lt;= N; ++i )&#123; for ( int j = 0; j &lt; s[i].v; ++j ) f[i][j] = f[i - 1][j]; for ( int j = s[i].v; j &lt;= 90000; ++j ) f[i][j] = min( f[i - 1][j], (int)min( 1ll * f[i - 1][j - s[i].v] + s[i].c, 2000000000ll ) ); &#125; for ( int i = 1; i &lt;= N; ++i ) for ( int j = 89999; j &gt;= 0; --j ) f[i][j] = min( f[i][j], f[i][j + 1] ); int l, r, mid, sp, ans; for ( int i = 1; i &lt;= M; ++i )&#123; scanf( "%d%d", &amp;T, &amp;m ); l = 1; r = N; sp = 0; while( l &lt;= r )&#123; mid = ( l + r ) &gt;&gt; 1; if ( s[mid].t &lt;= T ) sp = mid, l = mid + 1; else r = mid - 1; &#125; l = 1; r = 90000; ans = 0; while( l &lt;= r )&#123; mid = ( l + r ) &gt;&gt; 1; if ( f[sp][mid] &lt;= m ) ans = mid, l = mid + 1; else r = mid - 1; &#125; printf( "%d\n", ans ); &#125; return 0;&#125; 离线代码速度优化了许多,最慢的点只跑了0.50s 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;#define open(s) freopen( s".in", "r", stdin ), freopen( s".out", "w", stdout )#define Re registerint N, M;struct shop&#123; int c, v, t; inline void input()&#123; scanf( "%d%d%d", &amp;c, &amp;v, &amp;t ); &#125; bool operator &lt; ( const shop &amp;x )&#123; return t &lt; x.t; &#125;&#125;s[305];struct Query&#123; int T, M, id, ans; inline void input( int x )&#123; scanf( "%d%d", &amp;T, &amp;M ); id = x; &#125; bool operator &lt; ( const Query &amp;t )&#123; return id &lt; t.id; &#125;&#125;q[100005];bool cmp( Query x, Query y )&#123; return x.T &lt; y.T; &#125;int f[90005], T;int main()&#123; open("market"); scanf( "%d%d", &amp;N, &amp;M ); for ( int i = 1; i &lt;= N; ++i ) s[i].input(), T += s[i].v; sort( s + 1, s + N + 1 ); for ( int i = 1; i &lt;= M; ++i ) q[i].input(i); sort( q + 1, q + M + 1, cmp ); Re int p(1), l, r, mid; memset( f, 0x3f, sizeof f ); f[0] = 0; for ( int i = 1; i &lt;= M; ++i )&#123; while( p &lt;= N &amp;&amp; s[p].t &lt;= q[i].T )&#123; for ( int j = T; j &gt;= 1; --j ) f[j] = min( min( f[j], f[j + 1] ), ( j &gt;= s[p].v ? f[j - s[p].v] + s[p].c : INT_MAX ) ); p++; &#125; l = 1; r = T; q[i].ans = 0; while( l &lt;= r )&#123; mid = ( l + r ) &gt;&gt; 1; if ( f[mid] &lt;= q[i].M ) l = mid + 1, q[i].ans = mid; else r = mid - 1; &#125; &#125; sort( q + 1, q + M + 1 ); for ( int i = 1; i &lt;= M; ++i ) printf( "%d\n", q[i].ans ); return 0;&#125; T3 Dash Speed题意简述给定一棵$N$个节点的树，每条树边有两个权值L[i]、R[i],给出$M$次询问,每次询问给出一个权值$v$,取所有$L[i]\le v \le R[i]$的边,求最长链。 先给出两个暴力代码(加起来能得40分) 就不详细解释了。 想看正解的直接忽略吧。 暴力代码前20暴力分。暴力枚举即可。 +20 points 12345678910111213141516namespace task1&#123; int C; int dl[22][22], dr[22][22], dd[22][22]; void DFS( int x, int fa )&#123; for ( int i = hd[x]; i; i = nxt[i] ) if ( to[i] != fa ) dl[C][to[i]] = max( dl[C][x], L[i] ), dr[C][to[i]] = min( dr[C][x], R[i] ), dd[C][to[i]] = dd[C][x] + 1, DFS( to[i], x ); &#125; inline void solve()&#123; for ( C = 1; C &lt;= N; ++C ) dl[C][C] = INT_MIN, dr[C][C] = INT_MAX, DFS( C, C ); int x; for ( int i = 1; i &lt;= M; ++i )&#123; scanf( "%d", &amp;x ); int ans(0); for ( int j = 1; j &lt;= N; ++j ) for ( int k = 1; k &lt;= N; ++k ) if ( dl[j][k] &lt;= x &amp;&amp; x &lt;= dr[j][k] ) ans = max( ans, dd[j][k] ); printf( "%d\n", ans ); &#125; &#125;&#125; li = 1，且 ui = i; vi = i + 1倒序加边,并查集维护最长链即可。 +20 points 1234567891011121314151617181920212223242526272829303132namespace task2&#123; int fa[MAXN], sz[MAXN], ans; struct node&#123; int v, id, ans; &#125;a[MAXN]; bool cmp( node x, node y )&#123; return x.v &gt; y.v; &#125; int find( int x )&#123; return fa[x] == x ? x : ( fa[x] = find(fa[x]) ); &#125; inline void Merge( int x, int y )&#123; x = find(x); y = find(y); if ( x != y ) fa[x] = y, sz[y] += sz[x], ans = max( ans, sz[y] ); &#125; inline void solve()&#123; for ( int i = 1; i &lt;= N; ++i ) fa[i] = i, sz[i] = 1; for ( int i = 1; i &lt; N; ++i ) a[i].v = R[i * 2], a[i].id = i; sort( a + 1, a + N + 1, cmp ); ans = 1; for ( int i = 1; i &lt; N; ++i ) Merge( a[i].id, a[i].id + 1 ), a[i].ans = ans - 1; int x, l, r, mid, ans; for ( int i = 1; i &lt;= M; ++i )&#123; scanf( "%d", &amp;x ); l = 1; r = N - 1; ans = 0; while( l &lt;= r )&#123; mid = ( l + r ) &gt;&gt; 1; if ( a[mid].v &gt;= x ) l = mid + 1, ans = a[mid].ans; else r = mid - 1; &#125; printf( "%d\n", ans ); &#125; &#125;&#125; 思路边权的范围是$1\le L \le R \le N$,我们考虑对边权进行分治。就像这个样子(注:do something表示还有一些这里省略的代码)-&gt; 1234567891011void Work( int l, int r, int res )&#123; //do something //Work( 1, N, 0 )时图为空 //处理完do something后,所有l~r间的速度都能经过取到的所有边 //顺便把答案res(即最长链,或者叫做树的直径的最大值)进行修改 if ( l == r ) return ans[l] = res, void();//记录答案 do something int mid((l + r) &gt;&gt; 1); Work( l, mid, res );//对左区间进行处理 Work( mid + 1, r, res );//对右区间进行处理 //do something&#125; 再次强调一遍,我们分治的是边权。这样分治后,我们可以处理出速度为$1$至$N$时树(或者森林)上的最长链。询问时直接输出答案即可。1for ( int i = 1; i &lt;= M; ++i ) scanf( "%d", &amp;x ), printf( "%d\n", ans[x] ); 然后,我们面临几个问题 $Q1$:如何处理加进那几条边? $Q2$:如何快速地得出答案? 先来考虑$Q1$。 还记得线段树是怎样处理区间修改/查询吗?如果你深刻理解了这一过程,$Q1$就迎刃而解了。 123456789101112131415161718192021222324252627#define open(s) freopen( s".in", "r", stdin ), freopen( s".out", "w", stdout )int N, M;int fr[MAXN], to[MAXN], L[MAXN], R[MAXN];//存储一条边i,其两个端点为fr[i]和to[i],在这条边上速度必须在L[i]与R[i]之间/*do something*/int hd[MAXN &lt;&lt; 2], nx[MAXN * 20], v[MAXN * 20], tot;void _add( int x, int y )&#123; nx[++tot] = hd[x]; hd[x] = tot; v[tot] = y; &#125;#define ls c &lt;&lt; 1#define rs c &lt;&lt; 1 | 1void Ins( int c, int l, int r, int t )&#123;//类似于线段树的思想，把边插到满足要求的区间 if ( L[t] &lt;= l &amp;&amp; r &lt;= R[t] ) return _add( c, t ), void(); if ( L[t] &gt; r || l &gt; R[t] ) return; int mid((l + r) &gt;&gt; 1); Ins( ls, l, mid, t ); Ins( rs, mid + 1, r, t );&#125;int main()&#123; open("speed");//文件输入输出 scanf( "%d%d", &amp;N, &amp;M ); for ( int i = 1; i &lt; N; ++i ) scanf( "%d%d%d%d", &amp;fr[i], &amp;to[i], &amp;L[i], &amp;R[i] ), Ins( 1, 1, N, i ); /*do something*/ int x; for ( int i = 1; i &lt;= M; ++i ) scanf( "%d", &amp;x ), printf( "%d\n", ans[x] ); return 0;&#125; 看起来很难理解的样子。。。实际上十分简单。线段树的节点c(左边界为l,右边界为r)存储的是边i,满足L[i] \le l \le r \le R[i]。我们用链式前向星或者vector存储。 这样处理,分治时保留该节点已有的边,其子孙节点就会受该边的影响,不用重新再添加一遍。然后分治时再传一个参——该区间对应的线段树编号。就完美地解决了$Q1$。123456789void Work( int c, int l, int r, int res )&#123; /*do something*/ for ( int i = hd[c]; i; i = nx[i] ) Merge( fr[v[i]], to[v[i]], res );//添加完全包含该区间的边 Merge内部如何实现,那是Q2要处理的。 if ( l == r ) return ans[l] = res, void();//记录答案 do something int mid((l + r) &gt;&gt; 1); Work( ls, l, mid, res ); Work( rs, mid + 1, r, res ); //do something &#125; $Q2$的处理方式更灵活了。 我们用并查集维护哪些点在同一个连通块。当然这需要支持撤销。幸运的是,我们只需要撤销上一步操作。就比如,这次合并2和3,如果下一次是撤销的话,肯定是撤销合并2和3,而用不着先去撤销前面的。(请自行思考)因此,我们只要一个栈就能维护.1234567struct node&#123; int *t, x;//用指针维护显得更加方便 node()&#123;&#125; node( int *a, int b ):t(a), x(b)&#123;&#125;//构造函数 inline void work()&#123; *t = x; return; &#125;//撤销一次操作 &#125;s[MAXN * 4]; int tp;//用一个栈维护修改前的的值。(这样就够了！别傻乎乎地去写可持久化并查集！//因为这里只需要倒序撤销，不用随时查询历史版本 #define pop() s[tp--].work()//就上这样↑ 撤销一次操作并把它弹出栈 (栈都要调用STL太没面子了 还有,别忘了原来的问题——怎么维护最长链? 我们用两个数组$a$,$b$表示某一最长链的端点。 现在要合并$u$,$v$所在的树(find(u)=i,find(v)=j)。 最长链有如下几种可能: 原来的最长链,即$a[i]b[i]$或$a[j]b[j]$ $a[i]a[j]$ $a[i]b[j]$ $b[i]a[j]$ $b[i]b[j]$ 为什么呢？我们用反证法证明。 这里证明暂时留个坑。 然后我们解决了所有问题,上代码！(P.S.这里用了命名空间namespace,请自行查阅相关资料,或者可以理解为避免变量名冲突的手段,这里的主要目的是将程序分割成若干块,Debug时更清晰) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;bits/stdc++.h&gt;using namespace std;#define open(s) freopen( s".in", "r", stdin ), freopen( s".out", "w", stdout )#define MAXN 70007int N, M;int fr[MAXN], to[MAXN], L[MAXN], R[MAXN];namespace TrainSplit&#123; int hd[MAXN], nxt[MAXN &lt;&lt; 1], to[MAXN &lt;&lt; 1], tot; int dep[MAXN], tp[MAXN], sn[MAXN], sz[MAXN], fa[MAXN]; void add( int x, int y )&#123; nxt[++tot] = hd[x]; hd[x] = tot; to[tot] = y; nxt[++tot] = hd[y]; hd[y] = tot; to[tot] = x; &#125; void DFS1( int x )&#123;//求出dep深度,sz大小,sn重儿子,fa父亲 dep[x] = dep[fa[x]] + 1; sz[x] = 1; sn[x] = 0; for ( int i = hd[x]; i; i = nxt[i] )&#123; if ( to[i] == fa[x] ) continue; fa[to[i]] = x; DFS1( to[i] ); sz[x] += sz[to[i]]; if ( sz[to[i]] &gt; sz[sn[x]] ) sn[x] = to[i]; &#125; &#125; void DFS2( int x )&#123;//由于这里的树剖功能要求不多，不用求出seg,rev if ( sn[x] ) tp[sn[x]] = tp[x], DFS2( sn[x] ); for ( int i = hd[x]; i; i = nxt[i] ) if ( !tp[to[i]] ) tp[to[i]] = to[i], DFS2(to[i]); &#125; inline void init()&#123; DFS1(1); tp[1] = 1; DFS2(1); &#125;//初始化 inline int LCA( int x, int y )&#123; //树剖LCA 当然如果你不会也可以写倍增 #define fx tp[x] #define fy tp[y] while( fx != fy ) if ( dep[fx] &lt; dep[fy] ) y = fa[fy]; else x = fa[fx]; return dep[x] &gt; dep[y] ? y : x; &#125; inline int dis( int x, int y )&#123; return dep[x] + dep[y] - ( dep[LCA( x, y )] &lt;&lt; 1 ); &#125;//求出距离(写这么长一串代码就是为了这个 &#125;;//树剖LCA虽然代码比较长,空间比较大,但是应用范围更广,常数更小 namespace UFS&#123; int fa[MAXN], a[MAXN], b[MAXN], dep[MAXN], len; struct node&#123; int *t, x;//用指针维护显得更加方便 node()&#123;&#125; node( int *a, int b ):t(a), x(b)&#123;&#125;//构造函数 inline void work()&#123; *t = x; return; &#125;//撤销一次操作 &#125;s[MAXN * 4]; int tp;//用一个栈维护修改前的的值。(这样就够了！别傻乎乎地去写可持久化并查集！ //因为这里只需要倒序撤销，不用随时查询历史版本 #define pop() s[tp--].work() //就上这样↑ 撤销一次操作并把它弹出栈 inline void init()&#123; for ( int i = 1; i &lt;= N; ++i ) fa[i] = a[i] = b[i] = i, dep[i] = 1; &#125;//初始化 int find( int x )&#123; return x == fa[x] ? fa[x] : find(fa[x]); &#125;//因为需要要支持撤销，不能路径压缩，只能按秩合并 inline void Merge( int u, int v, int &amp;res )&#123; int x(find(u)), y(find(v)), ans_a, ans_b, ans_l(0), t; if ( x == y ) return;//事实上这句不用加 因为我们之前的操作已经保证每条边不可能加两次，除非撤销一条边后再加上一条边 using namespace TrainSplit;//TrainSplit::dis(x,y);太长了 直接using namespace Split;可以减少代码长度 t = dis( a[x], b[x] ); if ( t &gt; ans_l ) ans_a = a[x], ans_b = b[x], ans_l = t;//适当压行也不是不可以对伐(逃 t = dis( a[y], b[y] ); if ( t &gt; ans_l ) ans_a = a[y], ans_b = b[y], ans_l = t;//最长链这有可能出现在这6种情况 t = dis( a[x], a[y] ); if ( t &gt; ans_l ) ans_a = a[x], ans_b = a[y], ans_l = t;//分别统计，并找出最大值即可 t = dis( a[x], b[y] ); if ( t &gt; ans_l ) ans_a = a[x], ans_b = b[y], ans_l = t; t = dis( b[x], a[y] ); if ( t &gt; ans_l ) ans_a = b[x], ans_b = a[y], ans_l = t; t = dis( b[x], b[y] ); if ( t &gt; ans_l ) ans_a = b[x], ans_b = b[y], ans_l = t; if ( dep[x] &gt; dep[y] ) swap( x, y );//按秩合并 最深深度小的合并到最深深度大的 if ( dep[x] == dep[y] ) s[++tp] = node( &amp;dep[y], dep[y] ), dep[y]++;//如果最深深度相等，记得+1 s[++tp] = node( &amp;fa[x], x ); fa[x] = y;//记录原来信息（以备撤销）再修改 s[++tp] = node( &amp;a[y], a[y] ); a[y] = ans_a; s[++tp] = node( &amp;b[y], b[y] ); b[y] = ans_b; res = max( res, ans_l );//记录最大值 &#125; inline void Back( int pos )&#123; while( tp &gt; pos ) pop(); &#125;&#125; int ans[MAXN];namespace SGT&#123; int hd[MAXN &lt;&lt; 2], nx[MAXN * 20], v[MAXN * 20], tot; void _add( int x, int y )&#123; nx[++tot] = hd[x]; hd[x] = tot; v[tot] = y; &#125; #define ls c &lt;&lt; 1 #define rs c &lt;&lt; 1 | 1 void Ins( int c, int l, int r, int t )&#123;//类似于线段树的思想，把边插到满足要求的区间 if ( L[t] &lt;= l &amp;&amp; r &lt;= R[t] ) return _add( c, t ), void(); if ( L[t] &gt; r || l &gt; R[t] ) return; int mid((l + r) &gt;&gt; 1); Ins( ls, l, mid, t ); Ins( rs, mid + 1, r, t ); &#125; void Work( int c, int l, int r, int res )&#123; using namespace UFS; int cur(tp);//记录当前栈顶位置 for ( int i = hd[c]; i; i = nx[i] ) Merge( fr[v[i]], to[v[i]], res );//添加完全包含该区间的边 if ( l == r ) return ans[l] = res, Back(cur);//记录答案 int mid((l + r) &gt;&gt; 1); Work( ls, l, mid, res ); Work( rs, mid + 1, r, res ); Back(cur);//撤销到原来位置 &#125;&#125;//线段树 int main()&#123; open("speed"); scanf( "%d%d", &amp;N, &amp;M ); for ( int i = 1; i &lt; N; ++i ) scanf( "%d%d%d%d", &amp;fr[i], &amp;to[i], &amp;L[i], &amp;R[i] ), TrainSplit::add( fr[i], to[i] ), SGT::Ins( 1, 1, N, i ); TrainSplit::init(); UFS::init(); SGT::Work( 1, 1, N, 0 ); int x; for ( int i = 1; i &lt;= M; ++i ) scanf( "%d", &amp;x ), printf( "%d\n", ans[x] ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Claris’ Contest #2 Day 1 解题报告]]></title>
    <url>%2F2019%2F01%2F27%2FClaris'-Contest-2-Day-1-solution%2F</url>
    <content type="text"><![CDATA[题目、标程等 只有标配分数100+70+40,看来还是太弱了QAQ 膜拜把我吊打的巨佬们 T1 String Master题意简述两个字符串$A$,$B$,有$K$次修改机会,求能得到的最长公共子串。数据范围1~300 思路十分简单的暴力。注意这是子串而不是子序列,位置必须是连续的。因此我们只要$O(n^2)$枚举公共子串$S$在$A$与$B$中的起始位置,顺序枚举$S$长度即可。 代码123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;#define open(s) freopen( s".in", "r", stdin ), freopen( s".out", "w", stdout )#define MAXN 305int N, K, ans;char a[MAXN], b[MAXN];int main()&#123; open("master"); scanf( "%d%d", &amp;N, &amp;K ); scanf( "%s", a + 1 ); scanf( "%s", b + 1 ); int p, r, ans(0); for ( int i = 1; i &lt;= N; ++i ) for ( int j = 1; j &lt;= N; ++j )&#123; p = 0; r = K; while( max( i, j ) + p &lt;= N )&#123; if ( a[i + p] != b[j + p] )&#123; if ( r ) r--; else break; &#125; p++; &#125; ans = max( ans, p ); &#125; printf( "%d\n", ans ); return 0;&#125; T2 Tourist Attractions题意简述求一个图中有多少条恰好经过4个点的简单路径。（不能经过一个点2次或以上，4的点的经过顺序不同也算2条路径）数据范围1~1500 思路设经过的点分别为$P_1,P_2,P_3,P_4$。$O(N^2)$暴力枚举$P_2,P_3$,接下来就只要处理$P_1,P_4$就可以了。如何处理？$P_1,P_4$需要满足如下条件: $P_1$与$P_2$有一条边相连 $P_3$与$P_4$有一条边相连 $P_1$不等于$P_4$ 如果没有条件3,直接加上$(f[P_2]-1)\times(f[P_3]-1)$即可($f[i]\text{表示点i的度数}$)。 接下来只要减去满足条件3的组数(容斥原理)。 设与$P_2$相连的点集为$A$,与$P_3$相连的点集为$B$,满足条件3的组数即为$card(A\cap B)$(就是A与B的并集的大小啦)。 我们可以用bitset求出这一信息。(不会的去问度娘)1bitset&lt;MAXN&gt; v; 若有一条边$(u,v)$,$v[u][v]=1$ $card(A\cap B)$就是$(v[A] \&amp; v[B]).count()$ bitset优化了时间复杂度,这样的复杂度为$O(N^3/32)$,可以过。 代码1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;#define open(s) freopen( s".in", "r", stdin ), freopen( s".out", "w", stdout )#define MAXN 1555#define LL long long#define Re registerint N; char t;bitset&lt;MAXN&gt; v[MAXN];vector&lt;int&gt; vc[MAXN];LL ans, f[MAXN];int main()&#123; open("tour"); scanf( "%d", &amp;N ); for ( Re int i = 1; i &lt;= N; ++i ) for ( Re int j = 1; j &lt;= N; ++j )&#123; while( ( t = getchar() ) != '0' &amp;&amp; t != '1' ); if ( t == '1' ) v[i][j] = 1, f[i]++, vc[i].push_back(j); &#125; Re int j; for ( int i = 1; i &lt;= N; ++i ) for ( int jj = 0; jj &lt; (int)vc[i].size(); ++jj ) j = vc[i][jj], ans += ( f[i] - 1 ) * ( f[j] - 1 ) - ( ( v[i] &amp; v[j] ).count() ); printf( "%lld\n", ans ); return 0;&#125; T3 Walk题意简述给出有向图$G$,每个点$i$有一个权值$v_i$,除了给定的$M$条有向边外,若$v_i \&amp; v_j=v_j$,则存在有向边$i-&gt;j$。求$1$到$N$的最短路径。 思路新建(1&lt;&lt;20)个点($P_1$至$P_{1&lt;&lt;20}$),点$i$向$P_{vi}$连一条长度为1的有向边,$P_{vi}$向$i$连一条长度为0的有向边。这样以后，就只要处理$P$之间的连边关系就可以了。如何处理？我们可以把$v_i$转换成二进制后中的一个1变成0,然后连一条长度为0的有向边。例如$(100110)2$与$(100100)2$、$(100010)2$、$(000110)2$连边。这样建图，就可以实现权值之间的连边。因为和$(100100)2$、$(100010)2$、$(000110)2$与运算为本身的权值和$(100110)2$与运算也为本身。这样由$(100110)2$可以到达$(100100)2$、$(100010)2$、$(000110)2$、$(100000)2$、$(000100)2$、$(000010)2$。其中$(100000)2$、$(000100)2$、$(000010)2$是“转站”过才能到达的。这样就得到了一个边权只有0/1的有向图。找最短路可以用双端队列BFS实现，也可以用BFS+DFS实现。由于deque比较慢，这里用BFS+DFS实现。具体请参考代码。 代码1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;#define open(s) freopen( s".in", "r", stdin ), freopen( s".out", "w", stdout )#define MAXN 1300005#define MAXM 700005 //hd0[i]表示与i相连的、边权为0的点,hd1[i]表示与i相连的、边权为1的点,q是手打的队列。注意这里根据权值连的边没有用链式前向星存储。int N, M, T, d[MAXN], hd0[MAXN], hd1[MAXN], nxt[MAXM], to[MAXM], tot, q[MAXN], hd, tl, x, y;void Add( int hd[], int x, int y )&#123; nxt[++tot] = hd[x]; hd[x] = tot; to[tot] = y; &#125;void ext( int x, int w )&#123;//扩展所有距离不变的点。 if ( d[x] &gt;= 0 ) return; d[q[++tl] = x] = w; for ( int i = hd0[x]; i; i = nxt[i] ) ext( to[i], w );//把边权为0的继续扩展。 if ( x &gt; T || ( ( x &amp; -x ) == x ) ) return; for ( int i = x; i; i -= i &amp; -i ) ext( x - ( i &amp; -i ), w );//处理权值之间的连边。&#125;int main()&#123; open("walk"); scanf( "%d%d", &amp;N, &amp;M ); T = 1 &lt;&lt; 20; for ( int i = 1; i &lt;= N; ++i ) scanf( "%d", &amp;x ), Add( hd1, i + T, x ), Add( hd0, x, i + T );//处理权值与点的边 for ( int i = 1; i &lt;= M; ++i ) scanf( "%d%d", &amp;x, &amp;y ), Add( hd1, x + T, y + T );//处理原来的边。 memset( d, -1, sizeof d ); q[hd = tl = 1] = 1 + T; d[1 + T] = 0; ext( 1 + T, 0 ); while( hd &lt;= tl ) for ( int i = hd1[x = q[hd++]]; i; i = nxt[i] ) ext( to[i], d[x] + 1 ); for ( int i = 1; i &lt;= N; ++i ) printf( "%d\n", d[T + i] ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>模拟赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P4879」ycz的妹子 解题报告]]></title>
    <url>%2F2019%2F01%2F26%2Fluogu4879-solution%2F</url>
    <content type="text"><![CDATA[P4879 ycz的妹子题目背景$ycz$有很多很多的妹子（$ycz$：瞎说） 题目描述机房神犇$ycz$有$n$个青梅竹马，她们分别住在1~n号城市中。小时候的她们美丽可爱，但是由于女大十八变，有些妹子的颜值发生了变化，但是十分重感情的$ycz$神犇不忍心抛弃她们，于是记录下来了她们颜值变化的值，我们用$C\, x\, y$表示第$x$个城市的妹子的颜值下降了$y$。长大之后的$ycz$非常有魅力，有许多妹子被$ycz$迷得神魂颠倒，我们用$I\, x\, y$表示第$x$个城市有一个妹子喜欢上了$ycz$，她的颜值为$y$（$y$有可能是负数，但是$ycz$来者不拒）。但在中途有一些妹子和$ycz$吵架了，于是就分手了，我们用$D\, x$表示第$x$个妹子和$ycz$分手了。 最近神犇$ycz$要去全国各地找他的妹子们，为了方便计算，我们珂以把$ycz$的妹子所在的城市当作是一条直线，并且挨在一起。神犇$ycz$由于忙于和他的妹子们联系此时已经很累了，于是交给你一个这样的任务：他想知道他在某个时间去找他的所有妹子们珂以获得多大的愉悦度，这个愉悦度为他找的妹子的颜值数，你要做的就是求出这个愉悦度之和（注意长大后妹子们的颜值可能为负数/滑稽）。 注意：每个城市只允许有一个妹子，也就是说后来喜欢上$ycz$的妹子会赶走之前这个城市喜欢$ycz$的妹子（一城不容二女）。 UPD: 青梅竹马都是喜欢$ycz$的。 分手的第$x$个妹子不是第$x$城市的妹子，是指从前往后数第$x$个有妹子的城市的妹子 青梅竹马长大后就是妹子 修改的值$y$不为负数，但是颜值减去之后可能为负数 输入输出格式输入格式：第一行两个正整数$n$和$m$ $(1&lt;=n&lt;=100000)$ 第二行为$n$个整数$a_i$，表示小时候$ycz$的青梅竹马的颜值$(1&lt;=a_i&lt;=10^9)$ 接下来$m$行，每行为一条信息，每条信息可能是下面的一种: $C\, x\, y$表示第$x$个城市的妹子的颜值下降了$y$ $I\, x\, y$表示在第$x$个城市有一个颜值为$y$的妹子迷上了$ycz$ $D\, x$表示第$x$个妹子和$ycz$分手了 QQ表示$ycz$现在想知道如果现在去找他所有的妹子们珂以获得多大的愉悦度 说明：妹子们居住的城市编号最大为$5\times 10^5$ 输出格式：对于每一个QQ输出一个整数 输入输出样例输入样例#1：1234567891011125 101 2 3 4 5QC 3 2QI 6 6QD 4QC 5 2I 7 9Q 输出样例#1：123451513191522 说明样例解释： 妹子颜值变化如下，删除的就没写在下面了。 123451 2 1 4 51 2 1 4 5 61 2 1 5 61 2 1 3 61 2 1 3 6 9 对于30%的数据$1&lt;=n,m&lt;=10$ 对于70%的数据$1&lt;=n,m&lt;=1000$ 对于100%的数据$1&lt;=n,m&lt;=100000,1&lt;=a_i,y&lt;=10^9$ 这题为啥要搞线段树平衡树分块呀？树状数组多好QAQ 两种思路—— 思路I——树状数组+二分我们用树状数组维护妹子个数的前缀和。 当和妹子分手时二分查找第一个妹子出现的城市即可（即Get(an) == x的第一个位置）。 其他操作$O(1)$都可以完成，这里不解释。 复杂度为$O(nlog^2n)$ 至少比分块要快 这大家应该都会，代码就不给了。 思路II——树状数组+倍增树状数组简直与倍增是天生一对呀~ 虽然一般来说，倍增、二分的复杂度是一样的，但在这里，树状数组+倍增做到了$O(nlogn)$复杂度。 还记得树状数组是怎么求前缀和的吗？比如$1101100$ $ans=c[(1000000)_2]+c[(1100000)_2]+c[(1101000)_2]+c[(1101100)_2]$ 很清楚了吧？ 所以直接从高位到低位顺序枚举，如果加上这一位答案还没大于等于所求值，就加上去。最后答案$+1$即可。具体看代码。 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;#define Re register#define MAXN 500005#define LL long longint N, M, n;int c[MAXN];LL ans, a[MAXN];bool v[MAXN];void Add( int x, int k )&#123; for ( ; x &lt;= 500000; x += x &amp; -x ) c[x] += k; &#125;int main()&#123; scanf( "%d%d", &amp;N, &amp;M ); for ( int i = 1; i &lt;= N; ++i ) scanf( "%lld", &amp;a[i] ), ans += a[i], Add( i, 1 ), v[i] = 1; char opt[5]; int x, y; for ( int i = 1; i &lt;= M; ++i )&#123; scanf( "%s", opt ); if ( *opt == 'C' )&#123; scanf( "%d%d", &amp;x, &amp;y ); if ( v[x] ) a[x] -= y, ans -= y; &#125; else if ( *opt == 'I' )&#123; scanf( "%d%d", &amp;x, &amp;y ); if ( !v[x] ) v[x] = 1, Add( x, 1 ), ans += y, a[x] = y; else ans -= a[x] - y, a[x] = y; &#125; else if ( *opt == 'D' )&#123; scanf( "%d", &amp;x ); int cur(0); for ( int j = 18; j &gt;= 0; --j ) if ( ( cur | ( 1 &lt;&lt; j ) ) &lt;= 500000 &amp;&amp; c[cur | ( 1 &lt;&lt; j )] &lt; x ) cur |= 1 &lt;&lt; j, x -= c[cur]; cur++; if ( v[cur] ) ans -= a[cur], a[cur] = v[cur] = 0, Add( cur, -1 ); &#125; else if ( *opt == 'Q' ) printf( "%lld\n", ans ); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>二分答案</tag>
        <tag>倍增</tag>
        <tag>线段树</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeForces 260C」Balls and Boxes 解题报告]]></title>
    <url>%2F2019%2F01%2F25%2Fcodeforces-260C-solution%2F</url>
    <content type="text"><![CDATA[CF260C Balls and Boxes题目描述Little Vasya had nn boxes with balls in the room. The boxes stood in a row and were numbered with numbers from $1$ to $n$ from left to right. Once Vasya chose one of the boxes, let’s assume that its number is $i$ , took all balls out from it (it is guaranteed that this box originally had at least one ball), and began putting balls (one at a time) to the boxes with numbers $i+1$ , $i+2$ , $i+3$ and so on. If Vasya puts a ball into the box number $n$ , then the next ball goes to box 11 , the next one goes to box $2$ and so on. He did it until he had no balls left in his hands. It is possible that Vasya puts multiple balls to the same box, and it is also possible that one or more balls will go to the box number ii . If $i=n$ , Vasya puts the first ball into the box number $1$, then the next ball goes to box $2$ and so on. For example, let’s suppose that initially Vasya had four boxes, and the first box had $3$ balls, the second one had $2$ , the third one had $5$ and the fourth one had $4$ balls. Then, if $i=3$ , then Vasya will take all five balls out of the third box and put them in the boxes with numbers: $4,1,2,3,4$ . After all Vasya’s actions the balls will lie in the boxes as follows: in the first box there are $4$ balls, $3$ in the second one, $1$ in the third one and 66 in the fourth one. At this point Vasya has completely forgotten the original arrangement of the balls in the boxes, but he knows how they are arranged now, and the number $x$ — the number of the box, where he put the last of the taken out balls. He asks you to help to find the initial arrangement of the balls in the boxes. 输入输出格式输入格式：The first line of the input contains two integers nn and xx ( 2&lt;=n&lt;=10^{5}2&lt;=n&lt;=105 , $1\le x\le n$ ), that represent the number of the boxes and the index of the box that got the last ball from Vasya, correspondingly. The second line contains nn space-separated integers $a_{1},a_{2},…,a_{n}$ , where integer $a_{i}$ ( $0\le a_{i}\le10^{9} x \ne 0$ ) represents the number of balls in the box with index $i$ after Vasya completes all the actions. Please, do not use the %lld specifier to read or write 64-bit integers in С++. It is preferred to use the cin, cout streams or the %I64d specifier. 输出格式：Print $n$ integers, where the $i$ -th one represents the number of balls in the box number ii before Vasya starts acting. Separate the numbers in the output by spaces. If there are multiple correct solutions, you are allowed to print any of them. 输入输出样例输入样例#1：124 44 3 1 6 输出样例#1：13 2 5 4 输入样例#2：125 23 2 0 2 7 输出样例#2：12 1 4 1 6 输入样例#3：123 32 3 1 输出样例#3：11 2 3 题意简述有$N$个盒子，每个盒子中有若干个球（也可能为空），从某个盒子$i$中取出所有球，依次放到$i+1,i+2…N-1,N,1,2…$中，（每次放一个），直至球放完。注意：盒子中可能会放多次球，$i$号盒子中也有可能放球。现在已知盒子的个数、最后一个放球的位置，求出最开始每个盒子中放的球的个数。（输出任意一组即可） 思路由于一开始盒子$i$被取空，最后盒子$i$中球的个数肯定是最少的（当然也有可能有的盒子球的个数和它一样少，但绝对不可能比它还小）。所以，找出最小值$t$，所有元素先减去$t$。如果不考虑最后一个放的位置$x$，直接任意选一个$0$变成$t\times N$即可，但是若要考虑$x$，我们可以从$x$不断向前枚举，直至找到第一个$0$。具体处理过程请看代码。 代码1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;#define Re register#define MAXN 100005#define LL long longint N, x;LL a[MAXN], t(0x7f7f7f7f7f7f7f7f);void pre( int &amp;x )&#123;//找前一个元素 x--; if ( x == 0 ) x = N;&#125;int main()&#123; scanf( "%d%d", &amp;N, &amp;x ); for ( int i = 1; i &lt;= N; ++i ) scanf( "%I64d", &amp;a[i] ), t = min( t, a[i] );//最小值 for ( int i = 1; i &lt;= N; ++i ) a[i] -= t;//先减去t t *= N; while( a[x] ) a[x]--, t++, pre(x);//a序列中减去后t要加上 a[x] = t; for ( int i = 1; i &lt;= N; ++i ) printf( "%I64d ", a[i] ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>水题</tag>
        <tag>CodeForces</tag>
        <tag>枚举</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SP104」HIGH - Highways 解题报告]]></title>
    <url>%2F2019%2F01%2F25%2Fspoj104-solution%2F</url>
    <content type="text"><![CDATA[SP104 HIGH - Highways题意翻译题目描述给定一张无向图，求出其生成树的个数 (请使用Matrix定理求解) 输入输出格式输入格式：第一行一个整数T，表示测试数据的个数 每个测试数据第一行给出$n,m$ 分别表示点数与边数 接下来$m$行，每行给出两个数$a,b$ ，表示$a,b$ 之间有一条无向边 输出格式：每个测试数据，输出一个整数，表示给出的无向图的生成树的个数 题目描述In some countries building highways takes a lot of time… Maybe that’s because there are many possiblities to construct a network of highways and engineers can’t make up their minds which one to choose. Suppose we have a list of cities that can be connected directly. Your task is to count how many ways there are to build such a network that between every two cities there exists exactly one path. Two networks differ if there are two cities that are connected directly in the first case and aren’t in the second case. At most one highway connects two cities. No highway connects a city to itself. Highways are two-way. 输入输出格式输入格式：The input begins with the integer t, the number of test cases (equal to about 1000). Then t test cases follow. The first line of each test case contains two integers, the number of cities (1&lt;=n&lt;=12) and the number of direct connections between them. Each next line contains two integers a and b, which are numbers of cities that can be connected. Cities are numbered from 1 to n. Consecutive test cases are separated with one blank line. 输出格式：The number of ways to build the network, for every test case in a separate line. Assume that when there is only one city, the answer should be 1. The answer will fit in a signed 64-bit integer. 输入输出样例输入样例#1：123456789101112131415161744 53 44 22 31 21 32 12 11 03 31 22 33 1 输出样例#1：12348113 前置芝士高斯消元，矩阵相关。 思路有一种神奇的定理——Matrix-Tree定理！ 大概内容如下： 邻接矩阵$A$，若有一条边$(u,v)$，$A_{u,v}+1,A_{v,u}+1$ 度数矩阵$D$，$D_{i,i}=$点$i$的度数 基尔霍夫矩阵$C=D-A$ 该图的生成树个数就是$C_{i,i}$的余子式（$1\le i \le N$都可以）下面我选择的是$C_{N,N}$，所以直接N—即可 若该图不连通，$C_{i,i}$的余子式肯定是$0$ 具体证明去问度娘，因为我也不会。 然后只要用高斯消元求出行列式即可。 代码123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;#define Re register#define MAXN 20#define LD long doubleint T, N, M, x, y;LD a[MAXN][MAXN];int main()&#123; scanf( "%d", &amp;T ); while( T-- )&#123; scanf( "%d%d", &amp;N, &amp;M ); N--; memset( a, 0, sizeof a ); for ( int i = 1; i &lt;= M; ++i ) scanf( "%d%d", &amp;x, &amp;y ), a[x][x] += 1, a[y][y] += 1, a[x][y] -= 1, a[y][x] -= 1; bool flg(1); for ( int i = 1; i &lt;= N; ++i )&#123; int mx(i); for ( int j = i + 1; j &lt;= N; ++j ) if ( a[mx][i] &lt; a[j][i] ) mx = j; if ( i != mx ) for ( int j = i; j &lt;= N; ++j ) swap( a[i][j], a[mx][j] ); if ( a[i][i] &lt; 1e-8 &amp;&amp; a[i][i] &gt; -1e-8 )&#123; printf( "0\n" ); flg = 0; break; &#125; for ( int j = i + 1; j &lt;= N; ++j )&#123; LD t(a[j][i] / a[i][i]); for ( int k = i; k &lt;= N; ++k ) a[j][k] -= a[i][k] * t; &#125; &#125; if ( flg )&#123; LD ans(1); for ( int i = 1; i &lt;= N; ++i ) ans *= a[i][i]; printf( "%.0Lf\n", ans &gt;= 0 ? ans : -ans ); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>数学,数论</tag>
        <tag>高斯消元</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「题单」高斯消元]]></title>
    <url>%2F2019%2F01%2F25%2Fproblemset-gaussian-elimination%2F</url>
    <content type="text"><![CDATA[高斯消元的一些毒瘤题，我只会两道。 模板洛谷P3389 【模板】高斯消元法 OK 其他洛谷P4035 [JSOI2008]球形空间产生器 OK洛谷P3211 [HNOI2011]XOR和路径洛谷P3232 [HNOI2013]游走洛谷P3706 [SDOI2017]硬币游戏]]></content>
      <tags>
        <tag>数学,数论</tag>
        <tag>高斯消元</tag>
        <tag>题单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P4035」[JSOI2008]球形空间产生器 解题报告]]></title>
    <url>%2F2019%2F01%2F25%2Fluogu4035-solution%2F</url>
    <content type="text"><![CDATA[P4035 [JSOI2008]球形空间产生器题目描述有一个球形空间产生器能够在 $n$维空间中产生一个坚硬的球体。现在，你被困在了这个 $n$维球体中，你只知道球面上 $n+1$ 个点的坐标，你需要以最快的速度确定这个 $n$ 维球体的球心坐标，以便于摧毁这个球形空间产生器。 输入输出格式输入格式：第一行是一个整数 $n$ ($1&lt;=N=10$)。接下来的 $n+1$ 行，每行有 $n$ 个实数，表示球面上一点的 $n$ 维坐标。每一个实数精确到小数点后 $6$ 位，且其绝对值都不超过 $20000$。 输出格式：有且只有一行，依次给出球心的 $n$ 维坐标（ $n$ 个实数），两个实数之间用一个空格隔开。每个实数精确到小数点后 $3$ 位。数据保证有解。你的答案必须和标准输出一模一样才能够得分。 输入输出样例输入样例#1：123420.0 0.0-1.0 1.01.0 0.0 输出样例#1：10.500 1.500 说明提示：给出两个定义： 球心：到球面上任意一点距离都相等的点。 距离：设两个n为空间上的点A, B的坐标为$(a_1, a_2, \cdots , a_n), (b_1, b_2, \cdots , b_n)$，则AB的距离定义为：$dist = \sqrt{ (a_1-b_1)^2 + (a_2-b_2)^2 + \cdots + (a_n-b_n)^2 }$ 思路我们可以列出等式：($o_i$表示圆心坐标) \sum(a_i-o_i)^2=R^2\sum(b_i-o_i)^2=R^2\sum(c_i-o_i)^2=R^2… 将式子全部展开。以第一个为例。 \sum(a_i-o_i)^2=\sum(a_i^2-2a_io_i+o_i^2)\therefore \sum(2a_io_i)=\sum(a_i^2)-(R^2-\sum o_i)对于第$i$个式子($1\le i\le N$)，将其与$i+1$个式子相减(但是由于某种不可抗拒的力量，我代码中写成了第$i+1$个式子减第$i$个式子，但是效果是一样的，只不过两边都取反而已)。以第1个与第2个为例。（wow，$-(R^2-\sum o_i)$相互抵消啦 \sum(2(a_i-b_i)o_i)=\sum(a^2-b^2)这样就得到了$N$个$N$元一次方程。 然后？高斯消元！$o_i$就是$N$个未知数，$2(a_i-b_i)$就是系数，解$N$元一次方程组即可。 代码123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;#define Re register#define MAXN 15#define LD long doubleint N;LD a[MAXN][MAXN], b[MAXN][MAXN];int main()&#123; scanf( "%d", &amp;N ); for ( int i = 1; i &lt;= N + 1; ++i ) for ( int j = 1; j &lt;= N; ++j ) scanf( "%Lf", &amp;a[i][j] ); for ( int i = 1; i &lt;= N; ++i ) for ( int j = 1; j &lt;= N; ++j ) b[i][j] = 2 * ( a[i + 1][j] - a[i][j] ), b[i][N + 1] += a[i + 1][j] * a[i + 1][j] - a[i][j] * a[i][j]; for ( int i = 1; i &lt;= N; ++i ) for ( int j = i + 1; j &lt;= N; ++j )&#123; LD t( b[j][i] / b[i][i] ); for ( int k = i; k &lt;= N + 1; ++k ) b[j][k] -= t * b[i][k]; &#125; for ( int i = N; i &gt;= 1; --i )&#123; b[i][N + 1] /= b[i][i]; for ( int j = i - 1; j &gt;= 1; --j ) b[j][N + 1] -= b[i][N + 1] * b[j][i]; &#125; for ( int i = 1; i &lt;= N; ++i ) printf( "%.3Lf ", b[i][N + 1] ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>数学,数论</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「学习笔记」线性代数]]></title>
    <url>%2F2019%2F01%2F25%2Fnotes-linear-algebra%2F</url>
    <content type="text"><![CDATA[线性代数真的猥琐 行列式行列式(determinant)是一个函数，将$n\times n$的矩阵$A$映射到一个标量行列式。可以看做是有向面积或体积的概念在一般的欧几里得空间中的推广。或者说，在$n$维欧几里得空间中，行列式描述的是一个线性变换对“体积”所造成的影响。 （一头雾水_(¦3」∠)_ 记法矩阵$A$的行列式记作$det(A)$或者$|A|$，对于一个矩阵 A= \left[\begin{matrix}a & b & c \\d & e & f \\g & h & i\end{matrix}\right]其行列式也记作 |A|=\left|\begin{matrix}a & b & c \\d & e & f \\g & h & i\end{matrix}\right|性质 如果交换两行(列)，行列式取反。 \left|\begin{matrix}a & b & c \\d & e & f \\g & h & i\end{matrix}\right|=-\left|\begin{matrix}a & b & c \\g & h & i\\d & e & f \end{matrix}\right|\left|\begin{matrix}a & b & c \\d & e & f \\g & h & i\end{matrix}\right|=-\left|\begin{matrix}b & a & c \\e & d & f\\ h & g & i\end{matrix}\right| 某行(列)减某行(列)的$n$倍，行列式不变。 \left|\begin{matrix}a & b & c \\d & e & f \\g & h & i\end{matrix}\right|=\left|\begin{matrix}a & b & c \\d-n\times a & e-n\times b & f-n\times c\\g & h & i\end{matrix}\right| 两行(列)相同或成比例时，行列式为0。 \left|\begin{matrix}a & b & c \\d & e & f \\a & b & c\end{matrix}\right|=0计算方法对于2\times 2矩阵 \left|\begin{matrix}a & b \\c & d \\\end{matrix}\right|=ad-bc对于$3\times 3$的呢？ \left|\begin{matrix}a & b & c \\d & e & f \\g & h & i\end{matrix}\right|=a(\left|\begin{matrix}e & f \\h & i\end{matrix}\right|)-b(\left|\begin{matrix}d & f \\g & i\end{matrix}\right|)+c(\left|\begin{matrix}d & e \\f & h\end{matrix}\right|)对于$4\times4$的？ \left|\begin{matrix}a & b & c & d \\e & f & g & h \\i & j & k & l\\m & n & o & p\end{matrix}\right|=a(\left|\begin{matrix}f & g & h \\j & k & l\\ n & o & p\end{matrix}\right|)-b(\left|\begin{matrix}e & g & h \\i & k & l\\ m & o & p\end{matrix}\right|)+c(\left|\begin{matrix}e & f & h \\i & j & l\\ m & n & p\end{matrix}\right|)-d(\left|\begin{matrix}e & f & g \\i & j & k\\ m & n & o\end{matrix}\right|)实际上这是有规律可循的。 如果矩阵更大，就不好算了QAQ]]></content>
      <tags>
        <tag>数学,数论</tag>
        <tag>待填坑</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeForces 1108C」Nice Garland 解题报告]]></title>
    <url>%2F2019%2F01%2F24%2Fcodeforces-1108C-solution%2F</url>
    <content type="text"><![CDATA[CF1108C Nice Garland题目描述You have a garland consisting of $n$ lamps. Each lamp is colored red, green or blue. The color of the $i$ -th lamp is $s_i$ (‘R’, ‘G’ and ‘B’ — colors of lamps in the garland). You have to recolor some lamps in this garland (recoloring a lamp means changing its initial color to another) in such a way that the obtained garland is nice. A garland is called nice if any two lamps of the same color have distance divisible by three between them. I.e. if the obtained garland is $t$ , then for each $i, j$ such that $t_i = t_j$ should be satisfied $|i-j|~ mod~ 3 = 0$ . The value $|x|$ means absolute value of $x$, the operation $x~ mod~ y$ means remainder of $x$ when divided by $y$ . For example, the following garlands are nice: “RGBRGBRG”, “GB”, “R”, “GRBGRBG”, “BRGBRGB”. The following garlands are not nice: “RR”, “RGBG”. Among all ways to recolor the initial garland to make it nice you have to choose one with the minimum number of recolored lamps. If there are multiple optimal solutions, print any of them. 输入输出格式输入格式：The first line of the input contains one integer $n$ ( $1 \le n \le 2 \cdot 10^5$ ) — the number of lamps.The second line of the input contains the string $s$ consisting of $n$ characters ‘R’, ‘G’ and ‘B’ — colors of lamps in the garland. 输出格式：In the first line of the output print one integer $r$ — the minimum number of recolors needed to obtain a nice garland from the given one. In the second line of the output print one string $t$ of length $n$ — a nice garland obtained from the initial one with minimum number of recolors. If there are multiple optimal solutions, print any of them. 输入输出样例输入样例#1：123BRB 输出样例#1：121GRB 输入样例#2：127RGBGRBB 输出样例#2：123RGBRGBR 题意简述给定一个长度为N的字符串（只包含’R’,’G’,’B’），修改最少的字符，使字符串满足当$s[i]=s[j]$时必有$i \equiv j(\mod 3)$ 思路我们可以想到，要满足条件，必须要有$s[0]\ne s[1]\ne s[2]$，$s[i]=s[i\% 3]$（很好理解吧？） 所以$s[0],s[1],s[2]$分别选取$’R’,’G’,’B’$（可打乱顺序），这可以用全排列解决；然后处理出要修改的个数，记录最优答案即可。时间复杂度为$O(3!\times n)$，稳得很。 代码123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;#define Re register#define MAXN 200005int N;char s[MAXN], cur[MAXN], ans[MAXN];int res(INT_MAX);int m[] = &#123; 1, 2, 3 &#125;;char a1, a2, a3;int main()&#123; scanf( "%d", &amp;N ); scanf( "%s", s ); do&#123; int c(0); a1 = m[0] == 1 ? 'R' : ( m[0] == 2 ? 'G' : 'B' ); a2 = m[1] == 1 ? 'R' : ( m[1] == 2 ? 'G' : 'B' ); a3 = m[2] == 1 ? 'R' : ( m[2] == 2 ? 'G' : 'B' ); for ( int i = 0; i &lt; N; i += 3 )&#123; cur[i] = a1; if ( s[i] != a1 ) c++; &#125; for ( int i = 1; i &lt; N; i += 3 )&#123; cur[i] = a2; if ( s[i] != a2 ) c++; &#125; for ( int i = 2; i &lt; N; i += 3 )&#123; cur[i] = a3; if ( s[i] != a3 ) c++; &#125; if ( c &lt; res )&#123; res = c; memcpy( ans, cur, sizeof ans ); &#125; &#125;while( next_permutation( m, m + 3 ) ); printf( "%d\n%s\n", res, ans ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>暴力</tag>
        <tag>水题</tag>
        <tag>CodeForces</tag>
        <tag>全排列</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeForces 1108D」Diverse Garland 解题报告]]></title>
    <url>%2F2019%2F01%2F24%2Fcodeforces-1108D-solution%2F</url>
    <content type="text"><![CDATA[CF1108D Diverse Garland题目描述You have a garland consisting of $n$ lamps. Each lamp is colored red, green or blue. The color of the $i$-th lamp is $s_i$ (‘R’, ‘G’ and ‘B’ — colors of lamps in the garland). You have to recolor some lamps in this garland (recoloring a lamp means changing its initial color to another) in such a way that the obtained garland is diverse. A garland is called diverse if any two adjacent (consecutive) lamps (i. e. such lamps that the distance between their positions is $1$ ) have distinct colors. In other words, if the obtained garland is $t$ then for each $i$ from $1$ to $n-1$ the condition $t_i \ne t_{i + 1}$should be satisfied. Among all ways to recolor the initial garland to make it diverse you have to choose one with the minimum number of recolored lamps. If there are multiple optimal solutions, print any of them. 输入输出格式输入格式：The first line of the input contains one integer $n$ ( $1 \le n \le 2 \cdot 10^5$ ) — the number of lamps. The second line of the input contains the string $s$ consisting of $n$ characters ‘R’, ‘G’ and ‘B’ — colors of lamps in the garland. 输出格式：In the first line of the output print one integer $r$ — the minimum number of recolors needed to obtain a diverse garland from the given one. In the second line of the output print one string $t$ of length $n$ — a diverse garland obtained from the initial one with minimum number of recolors. If there are multiple optimal solutions, print any of them. 输入输出样例输入样例#1：129RBGRRBRGG 输出样例#1：122RBGRGBRGR 输入样例#2：128BBBGBRRR 输出样例#2：122BRBGBRGR 输入样例#3：1213BBRRRRGGGGGRR 输出样例#3：126BGRBRBGBGBGRG 题意简述一个只包含三种字符’R’,’G’,’B’的字符串，修改最少的字符，使任意两个相邻的字符互不相等。 思路顺序枚举从2到N的所有字符，如果与之前的字符相等，就根据前后字符修改这个字符。 为什么呢？如果碰到一对相邻且相同的元素$i,i+1$，后一个元素$i+2$可能与$i+1$相等，但是$i$不可能与$i-1$相等（因为前面的元素已经过修改调整），因此，修改$i+1$可能会更优于$i$（因为如果修改$i$的话，可能还需要修改$i+1$或$i+2$）。 代码1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;#define Re register#define MAXN 200005int N, ans;char s[MAXN];int main()&#123; scanf( "%d", &amp;N ); scanf( "%s", s + 1 ); for ( int i = 2; i &lt;= N; ++i )&#123; if ( s[i] == s[i - 1] )&#123; ans++; char t('R'); if ( s[i - 1] == 'R' || s[i + 1] == 'R' )&#123; t = 'G'; if ( s[i - 1] == 'G' || s[i + 1] == 'G' ) t = 'B'; &#125; s[i] = t; &#125; &#125; printf( "%d\n%s\n", ans, s + 1 ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>CodeForces</tag>
        <tag>枚举</tag>
        <tag>贪心</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeForces 1108F」MST Unification 解题报告]]></title>
    <url>%2F2019%2F01%2F24%2Fcodeforces-1108F-solution%2F</url>
    <content type="text"><![CDATA[CF1108F MST Unification题目描述You are given an undirected weighted connected graph with $n$ vertices and $m$ edges without loops and multiple edges. The $i$ -th edge is $e_i = (u_i, v_i, w_i)$ ; the distance between vertices $u_i$ and $v_i$along the edge $e_i$ is $w_i$ ( $1 \le w_i$ ). The graph is connected, i. e. for any pair of vertices, there is at least one path between them consisting only of edges of the given graph. A minimum spanning tree (MST) in case of positive weights is a subset of the edges of a connected weighted undirected graph that connects all the vertices together and has minimum total cost among all such subsets (total cost is the sum of costs of chosen edges). You can modify the given graph. The only operation you can perform is the following: increase the weight of some edge by $1$ . You can increase the weight of each edge multiple (possibly, zero) times. Suppose that the initial MST cost is $k$. Your problem is to increase weights of some edges with minimum possible number of operations in such a way that the cost of MST in the obtained graph remains $k$ , but MST is unique (it means that there is only one way to choose MST in the obtained graph). Your problem is to calculate the minimum number of operations required to do it. 输入输出格式输入格式：The first line of the input contains two integers $n$ and $m$( $1 \le n \le 2 \cdot 10^5, n - 1 \le m \le 2 \cdot 10^5$ ) — the number of vertices and the number of edges in the initial graph. The next $m$ lines contain three integers each. The $i$ -th line contains the description of the $i$ -th edge $e_i$. It is denoted by three integers $u_i, v_i$ and $w_i$ ( $1 \le u_i, v_i \le n, u_i \ne v_i, 1 \le w \le 10^9$ ), where $u_i$ and $v_i$are vertices connected by the $i$ -th edge and $w_i$ is the weight of this edge. It is guaranteed that the given graph doesn’t contain loops and multiple edges (i.e. for each $i$ from $1$ to $m$ $u_i \ne v_i$ and for each unordered pair of vertices $(u, v)$ there is at most one edge connecting this pair of vertices). It is also guaranteed that the given graph is connected. 输出格式：Print one integer — the minimum number of operations to unify MST of the initial graph without changing the cost of MST. 输入输出样例输入样例#1：12345678910118 101 2 12 3 22 4 51 4 26 3 36 1 33 5 23 7 14 8 16 2 4 输入样例#2：11 输入样例#2：12344 32 1 34 3 42 4 1 输出样例#2：10 输入样例#3：12343 31 2 12 3 21 3 3 输出样例#3：10 输入样例#4：12343 31 2 12 3 31 3 3 输出样例#4：11 输入样例#5：11 0 输出样例#5：10 输入样例#6：12345675 61 2 22 3 14 5 32 4 21 4 21 5 3 输出样例#6：12 说明The picture corresponding to the first example: You can, for example, increase weight of the edge $(1, 6)$ or $(6,3)$ by $1$ to unify MST. The picture corresponding to the last example: You can, for example, increase weights of edges $(1,5)$ and $(2, 4)$ by $1$ to unify MST. 题意简述给出一个无向图（无重边自环，保证连通，边有权），其最小生成树边权总和为$K$，在保证最小生成树边权总和为仍$K$的前提下，增加一些边的边权，使最小生成树唯一确定，并最小化增加的总值。输出这个总值。 思路先求出最小生成树，对于那些没被选中的边$(u,v)$，我们设最小生成树中$u$到$v$的路径为$S$,由于要保证最小生成树唯一确定，我们要使$(u,v)$不能替换$S$路径中的任何一条边。因此，求出最小生成树中$(u,v)$路径中边权最大的边$e$。只要让这条边的边权$&gt;v_e$即可。可行性与最优性不难证明，请自行思考。 至于怎么求，我们用倍增LCA实现。总的时间复杂度为$O(nlgn)$。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 200005#define LL long longstruct edge&#123; int x, y, v; bool c; inline void input()&#123; scanf( "%d%d%d", &amp;x, &amp;y, &amp;v ); c = 0; &#125; bool operator &lt; ( const edge &amp;t )const&#123; return v &lt; t.v; &#125;&#125;a[MAXN];int N, M;int fa[MAXN];int hd[MAXN], nxt[MAXN &lt;&lt; 1], to[MAXN &lt;&lt; 1], val[MAXN &lt;&lt; 1], tot;int ft[MAXN][20], mx[MAXN][20], dep[MAXN];void Add( int x, int y, int z )&#123; nxt[++tot] = hd[x]; hd[x] = tot; to[tot] = y; val[tot] = z; nxt[++tot] = hd[y]; hd[y] = tot; to[tot] = x; val[tot] = z;&#125;int find( int x )&#123; return fa[x] == x ? x : ( fa[x] = find(fa[x]) ); &#125;//LCA和并查集都不会的去问度娘void DFS( int x )&#123; dep[x] = dep[ft[x][0]] + 1; for ( int i = 1; i &lt;= 17; ++i ) ft[x][i] = ft[ft[x][i - 1]][i - 1], mx[x][i] = max( mx[x][i - 1], mx[ft[x][i - 1]][i - 1] ); for ( int i = hd[x]; i; i = nxt[i] ) if ( to[i] != ft[x][0] ) ft[to[i]][0] = x, mx[to[i]][0] = val[i], DFS(to[i]);&#125;int LCA( int x, int y )&#123; int ans(INT_MIN); if ( dep[x] &lt; dep[y] ) swap( x, y ); for ( int i = 17; i &gt;= 0; --i ) if ( dep[ft[x][i]] &gt; dep[y] ) ans = max( ans, mx[x][i] ), x = ft[x][i]; if ( dep[x] &gt; dep[y] ) ans = max( ans, mx[x][0] ), x = ft[x][0]; for ( int i = 17; i &gt;= 0; --i ) if ( ft[x][i] != ft[y][i] ) ans = max( ans, max( mx[x][i], mx[y][i] ) ), x = ft[x][i], y = ft[y][i]; if ( x != y ) ans = max( ans, max( mx[x][0], mx[y][0] ) ), x = ft[x][0], y = ft[y][0]; return ans;&#125;int main()&#123; scanf( "%d%d", &amp;N, &amp;M ); for ( int i = 1; i &lt;= M; ++i ) a[i].input(), fa[i] = i;//读入并初始化求最小生成树用的并查集 sort( a + 1, a + M + 1 );//排序 int c(0); for ( int i = 1; i &lt;= M; ++i )&#123; int x(find(a[i].x)), y(find(a[i].y)); if ( x != y )&#123; fa[x] = y; c++; a[i].c = 1; Add( a[i].x, a[i].y, a[i].v );//最小生成树部分。a[i].c表示是否为最小生成树上的边 if ( c &gt;= N - 1 ) break;//已构成生成树，退出 &#125; &#125; ft[1][0] = 1; mx[1][0] = INT_MIN; DFS(1);//深搜预处理ft父亲与最大边权mx LL ans(0);//注意开long long for ( int i = 1; i &lt;= M; ++i )&#123; if ( !a[i].c )&#123;//不是最小生成树上的边，进行处理 int t(LCA( a[i].x, a[i].y )); if ( a[i].v &lt;= t ) ans += t + 1 - a[i].v;//可以替换某一条边，增大它 &#125; &#125; printf( "%lld\n", ans ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>CodeForces</tag>
        <tag>最小生成树</tag>
        <tag>LCA,最近公共祖先</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P4377」[USACO18OPEN]Talent Show 解题报告]]></title>
    <url>%2F2019%2F01%2F24%2Fluogu4377-solution%2F</url>
    <content type="text"><![CDATA[P4377 [USACO18OPEN]Talent Show题目描述Farmer John要带着他的NN头奶牛，方便起见编号为$1 \ldots N$，到农业展览会上去，参加每年的达牛秀！他的第$i$头奶牛重量为$w_i$，才艺水平为$t_i$，两者都是整数。 在到达时，Farmer John就被今年达牛秀的新规则吓到了： （一）参加比赛的一组奶牛必须总重量至少为WW（这是为了确保是强大的队伍在比赛，而不仅是强大的某头奶牛），并且 （二）总才艺值与总重量的比值最大的一组获得胜利。 FJ注意到他的所有奶牛的总重量不小于$W$，所以他能够派出符合规则（一）的队伍。帮助他确定这样的队伍中能够达到的最佳的才艺与重量的比值。 输入输出格式输入格式：输入的第一行包含$N$（$1 \leq N \leq 250$）和$W$（$1 \leq W \leq 1000$）。下面$N$行，每行用两个整数$w_i$（$1 \leq w_i \leq 10^6$）和$t_i$（$1 \leq t_i \leq 10^3$）描述了一头奶牛。 输出格式：请求出Farmer用一组总重量最少为WW的奶牛最大可能达到的总才艺值与总重量的比值。如果你的答案是AA，输出1000A1000A向下取整的值，以使得输出是整数（当问题中的数不是一个整数的时候，向下取整操作在向下舍入到整数的时候去除所有小数部分）。 输入输出样例输入样例#1：12343 1520 2110 1130 31 输出样例#1：11066 说明在这个例子中，总体来看最佳的才艺与重量的比值应该是仅用一头才艺值为11、重量为10的奶牛，但是由于我们需要至少15单位的重量，最优解最终为使用这头奶牛加上才艺值为21、重量为20的奶牛。这样的话才艺与重量的比值为(11+21)/(10+20) = 32/30 = 1.0666666…，乘以1000向下取整之后得到1066。 供题：Brian Dean 思路I很简单的0/1分数规划与背包DP结合。。。 0/1分数规划老套路（安利机房巨佬zzq博客_还上了洛谷日报$QAQ$_）——&gt;二分答案，条件$\sum (ti \times Ans - wi) \ge 0$ 但是，我们注意到$\sum wi$可能会很大，所以我们不能直接弄动态规划。 我们引入一些贪心的思想。 若$t\times Ans-w\ge 0$直接选来。因为这样只会更优化答案。 若1不满足，若$w\ge W$，只有$t\times Ans - w$最大的有可能成为答案。 若2再不满足，背包DP即可。只要把容量设为$2\times W$即可。（请自行思考 然后就是代码啦 代码I123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;using namespace std;#define Re register#define MAXN 255#define LD long doubleint N, W, WW;int w[MAXN], T[MAXN];LD f[2005], v;bool check( LD t )&#123; int c(0); LD r(0), tmp(-1e12); for ( int i = 1; i &lt;= WW; ++i ) f[i] = -1e12; for ( int i = 1; i &lt;= N; ++i )&#123; v = T[i] - w[i] * t; if ( v &gt;= 0 ) c += w[i], r += v; else&#123; if ( w[i] &gt;= W )&#123; tmp = max( tmp, v ); continue; &#125; for ( int j = WW; j &gt;= w[i]; --j ) f[j] = max( f[j], f[j - w[i]] + v ); &#125; &#125; if ( c &gt;= W || r + tmp &gt;= 0 ) return 1; for ( int i = W - c; i &lt;= WW; ++i ) if ( f[i] + r &gt;= 0 ) return 1; return 0;&#125;int main()&#123; scanf( "%d%d", &amp;N, &amp;W ); WW = W &lt;&lt; 1; for ( int i = 1; i &lt;= N; ++i ) scanf( "%d%d", &amp;w[i], &amp;T[i] ); LD l(0), r(1000000), mid; for ( int i = 1; i &lt;= 40; ++i )&#123; mid = ( l + r ) / 2; if ( check( mid ) ) l = mid; else r = mid; &#125; printf( "%d\n", (int)floor(l * 1000) ); return 0;&#125; 思路II实际上，好像另一种写法更简洁？容量设为W空间还要更小？（我太弱了QAQ 把状态转移方程式写成+的形式，而不是上面那种-的形式。 只要大于等于W的，都缩成一种状态。这样写好简单呀$QAQ$ 代码123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;#define Re register#define MAXN 255#define LD long doubleint N, W;int w[MAXN], T[MAXN];LD f[1005], v;bool check( LD t )&#123; for ( int i = 1; i &lt;= W; ++i ) f[i] = -1e12; for ( int i = 1; i &lt;= N; ++i )&#123; for ( int j = W; j &gt;= 0; --j )&#123; int k( min( j + w[i], W ) ); f[k] = max( f[k], f[j] + T[i] - w[i] * t ); &#125; &#125; return f[W] &gt;= 0;&#125;int main()&#123; scanf( "%d%d", &amp;N, &amp;W ); for ( int i = 1; i &lt;= N; ++i ) scanf( "%d%d", &amp;w[i], &amp;T[i] ); LD l(0), r(1000000), mid; for ( int i = 1; i &lt;= 40; ++i )&#123; mid = ( l + r ) / 2; if ( check( mid ) ) l = mid; else r = mid; &#125; printf( "%d\n", (int)floor(l * 1000) ); return 0;&#125;]]></content>
      <tags>
        <tag>背包DP</tag>
        <tag>二分答案</tag>
        <tag>0/1分数规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P1337」[JSOI2004]平衡点 / 吊打XXX 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fluogu1337-solution%2F</url>
    <content type="text"><![CDATA[P1337 [JSOI2004]平衡点 / 吊打XXX题目描述如图：有n个重物，每个重物系在一条足够长的绳子上。每条绳子自上而下穿过桌面上的洞，然后系在一起。图中X处就是公共的绳结。假设绳子是完全弹性的（不会造成能量损失），桌子足够高（因而重物不会垂到地上），且忽略所有的摩擦。 问绳结X最终平衡于何处。 注意：桌面上的洞都比绳结X小得多，所以即使某个重物特别重，绳结X也不可能穿过桌面上的洞掉下来，最多是卡在某个洞口处。 输入输出格式输入格式：文件的第一行为一个正整数n（1≤n≤1000），表示重物和洞的数目。接下来的n行，每行是3个整数：Xi.Yi.Wi，分别表示第i个洞的坐标以及第 i个重物的重量。(-10000≤ x,y ≤10000, 0&lt; w ≤ 1000 ) 输出格式：你的程序必须输出两个浮点数（保留小数点后三位），分别表示处于最终平衡状态时绳结X的横坐标和纵坐标。两个数以一个空格隔开。 输入输出样例输入样例#1：123430 0 10 2 11 1 1 输出样例#1：10.577 1.000 说明[JSOI] 前置芝士爬山算法。。。 思路很经典的爬山算法。 爬山算法是一个不断接近答案的骗分算法。 先设定答案的横纵坐标分别为每个点横纵坐标的平均数。 然后计算出每个点对它位置的影响（距离越远，重力越小，影响越小）；进行缩放（T）。 T不断减小时，当精度过高时就可以退出了。 代码123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;#define Re register#define MAXN 1005int N;int x[MAXN], y[MAXN], w[MAXN];double ansx, ansy;#define sqr(x) ( (x) * (x) )inline void ClimbHill()&#123; double T(1000);//设定T的初值 while( T &gt; 1e-5 )&#123; double cx(0), cy(0), tx, ty, dis; for ( int i = 1; i &lt;= N; ++i )&#123; tx = x[i] - ansx; ty = y[i] - ansy; dis = sqrt( tx * tx + ty * ty );//计算距离 if ( dis &lt; 1e-10 ) continue;//避免除以0 cx += tx * w[i] / dis;//计算对横纵坐标的影响 cy += ty * w[i] / dis; &#125; ansx += cx * T; ansy += cy * T; T *= 0.98;//T的值不断减小 &#125;&#125;int main()&#123; scanf( "%d", &amp;N ); for ( int i = 1; i &lt;= N; ++i ) scanf( "%d%d%d", &amp;x[i], &amp;y[i], &amp;w[i] ), ansx += x[i], ansy += y[i]; ansx /= N; ansy /= N;//计算初值 ClimbHill(); printf( "%.3lf %.3lf\n", ansx, ansy ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>爬山算法</tag>
        <tag>模拟退火</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P3705」[SDOI2017]新生舞会 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fluogu3705-solution%2F</url>
    <content type="text"><![CDATA[P3705 [SDOI2017]新生舞会题目描述学校组织了一次新生舞会，Cathy作为经验丰富的老学姐，负责为同学们安排舞伴。 有$n$个男生和$n$个女生参加舞会买一个男生和一个女生一起跳舞，互为舞伴。 Cathy收集了这些同学之间的关系，比如两个人之前认识没计算得出 $a_{i,j}$ Cathy还需要考虑两个人一起跳舞是否方便，比如身高体重差别会不会太大，计算得出 $b_{i,j}$，表示第i个男生和第j个女生一起跳舞时的不协调程度。 当然，还需要考虑很多其他问题。 Cathy想先用一个程序通过$a_{i,j}$和$b_{i,j}$求出一种方案，再手动对方案进行微调。 Cathy找到你，希望你帮她写那个程序。 一个方案中有n对舞伴，假设没对舞伴的喜悦程度分别是$a’_1,a’_2,…,a’_n$，假设每对舞伴的不协调程度分别是$b’_1,b’_2,…,b’_n$。令 $C=\frac{a’_1+a’_2+…+a’_n}{b’_1+b’_2+…+b’_n}$ Cathy希望C值最大。 输入输出格式输入格式：第一行一个整数n。 接下来n行，每行n个整数，第i行第j个数表示$a_{i,j}$。 接下来n行，每行n个整数，第i行第j个数表示$b_{i,j}$。 输出格式：一行一个数，表示C的最大值。四舍五入保留6位小数，选手输出的小数需要与标准输出相等。 输入输出样例输入样例#1：1234567319 17 1625 24 2335 36 319 5 63 4 27 8 9 输出样例#1：15.357143 说明对于10%的数据，$1\le n\le 5$ 对于40%的数据，$1\le n\le 18$ 另有20%的数据，$b_{i,j}\le 1$ 对于100%的数据，$1\le n\le 100,1\le a_{i,j},b_{i,j}&lt;=10^4$ 前置芝士最大费用最大流，0/1分数规划 思路又是道0/1分数规划。。。 还是那个套路，$C=\frac{a’_1+a’_2+…+a’_n}{b’_1+b’_2+…+b’_n} $转换成$\sum (a_i’-C\times b_i’)=0$ 二分答案即可。条件判断使用最大费用最大流。（不会zkw 555 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;using namespace std;#define Re register#define MAXN 305#define MAXM 30005#define LD long doubleint N;int hd[MAXN], nxt[MAXM], to[MAXM], val[MAXM], tot(1);LD c[MAXM];int S, T;inline void Add( Re int x, Re int y, Re int z, Re LD k )&#123; nxt[++tot] = hd[x]; hd[x] = tot; to[tot] = y; val[tot] = z; c[tot] = k; nxt[++tot] = hd[y]; hd[y] = tot; to[tot] = x; val[tot] = 0; c[tot] = -k;&#125;queue&lt;int&gt; Q;LD ans, d[MAXN];bool vis[MAXN];int pre[MAXN];int a[MAXN][MAXN], b[MAXN][MAXN];inline bool SPFA()&#123; for ( Re int i = S; i &lt;= T; ++i ) d[i] = -1e11; while( !Q.empty() ) Q.pop(); memset( vis, 0, sizeof vis ); d[S] = 0; Q.push(S); vis[S] = 1; while( !Q.empty() )&#123; Re int t(Q.front()); Q.pop(); vis[t] = 0; for ( Re int i = hd[t]; i; i = nxt[i] )&#123; if ( val[i] &amp;&amp; d[t] + c[i] &gt; d[to[i]] )&#123; d[to[i]] = d[t] + c[i]; pre[to[i]] = i; if ( !vis[to[i]] ) vis[to[i]] = 1, Q.push(to[i]); &#125; &#125; &#125; if ( d[T] &lt;= -5e10 ) return 0; Re int fl(INT_MAX); for ( Re int i = T; i != S; i = to[pre[i] ^ 1] ) fl = min( fl, val[pre[i]] ); for ( Re int i = T; i != S; i = to[pre[i] ^ 1] ) val[pre[i]] -= fl, val[pre[i] ^ 1] += fl; ans += (LD)fl * d[T]; return 1;&#125;inline bool check( Re LD x )&#123; memset( hd, 0, sizeof hd ); tot = 1; for ( int i = 1; i &lt;= N; ++i ) Add( S, i, 1, 0 ); for ( int i = 1; i &lt;= N; ++i ) Add( i + N, T, 1, 0 ); for ( int i = 1; i &lt;= N; ++i ) for ( int j = 1; j &lt;= N; ++j ) Add( i, j + N, 1, (LD)a[i][j] - x * (LD)b[i][j] ); ans = 0; while( SPFA() ); return ans &gt;= 0;&#125;int main()&#123; scanf( "%d", &amp;N ); S = 0; T = N &lt;&lt; 1 | 1; for ( int i = 1; i &lt;= N; ++i ) for ( int j = 1; j &lt;= N; ++j ) scanf( "%d", &amp;a[i][j] ); for ( int i = 1; i &lt;= N; ++i ) for ( int j = 1; j &lt;= N; ++j ) scanf( "%d", &amp;b[i][j] ); LD l(0), r(1e4), mid, ans(0); while ( l + 1e-7 &lt; r )&#123; mid = ( l + r ) / 2; if ( check( mid ) ) ans = mid, l = mid; else r = mid; &#125; printf( "%.6Lf\n", ans ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>网络流</tag>
        <tag>0/1分数规划</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P4322」[JSOI2016]最佳团体 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fluogu4322-solution%2F</url>
    <content type="text"><![CDATA[P4322 [JSOI2016]最佳团体题目描述JSOI 信息学代表队一共有 $N$ 名候选人，这些候选人从 $1$ 到 $N$ 编号。方便起见，JYY 的编号是 $0$ 号。每个候选人都由一位编号比他小的候选人$R_i$推荐。如果 $R_i = 0$ ，则说明这个候选人是 JYY 自己看上的。为了保证团队的和谐，JYY 需要保证，如果招募了候选人 $i$，那么候选人 $R_i$也一定需要在团队中。当然了，JYY 自己总是在团队里的。每一个候选人都有一个战斗值 $P_i$ ，也有一个招募费用 $S_i$。JYY 希望招募 $K$ 个候选人（JYY 自己不算），组成一个性价比最高的团队。也就是，这 $K$ 个被 JYY 选择的候选人的总战斗值与总招募费用的比值最大。 输入输出格式输入格式：输入一行包含两个正整数 $K$ 和 $N$ 。接下来 $N$ 行，其中第 $i$ 行包含三个整数 $S_i$,$P_i$, $R_i$, 表示候选人$i$的招募费用，战斗值和推荐人编号。 输出格式：输出一行一个实数，表示最佳比值。答案保留三位小数。 输入输出样例输入样例#1：1231 21000 1 01 1000 1 输出样例#1：10.001 说明对于100%的数据满足$1 \le K \le N \le 2500,0 &lt; S_i,P_i≤10^4$ 前置芝士树形DP，背包DP，0/1分数规划 思路十分裸的0/1分数规划。 $\frac{P_1+P_2+..P_k}{S_1+S_2+..S_k}= Ans$转换成$\sum (P_i-S_i\times Ans) = 0$ 二分答案即可。条件判断可以使用树上分组背包DP解决。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;bits/stdc++.h&gt;using namespace std;#define Re register#define MAXN 2505#define LD doubleint K, N; int S[MAXN], P[MAXN], R, sz[MAXN];int hd[MAXN], nxt[MAXN &lt;&lt; 1], to[MAXN &lt;&lt; 1], tot;LD f[MAXN][MAXN], v[MAXN];inline void Add( Re int x, Re int y )&#123; nxt[++tot] = hd[x]; hd[x] = tot; to[tot] = y; &#125;void DFS( Re int x )&#123; f[x][0] = 0; for ( Re int i = 1; i &lt;= K; ++i ) f[x][i] = -1e10; sz[x] = 1; for ( Re int i = hd[x]; i; i = nxt[i] )&#123; DFS(to[i]); sz[x] += sz[to[i]]; int t(min( sz[x], K )); for ( Re int k = t; k &gt;= 1; --k ) for ( Re int j = 1; j &lt;= sz[to[i]]; ++j ) if ( k - j &gt;= 0 ) f[x][k] = max( f[x][k], f[x][k - j] + f[to[i]][j] ); else break; &#125; for ( Re int i = min( K, sz[x] ); i &gt;= 1; --i ) f[x][i] = f[x][i - 1] + v[x];&#125;inline bool check( Re LD x )&#123; for ( Re int i = 1; i &lt;= N; ++i ) v[i] = (LD)P[i] - (LD)S[i] * x; DFS( 0 ); return f[0][K] &gt;= 0;&#125;int main()&#123; scanf( "%d%d", &amp;K, &amp;N ); K++; for ( Re int i = 1; i &lt;= N; ++i ) scanf( "%d%d%d", &amp;S[i], &amp;P[i], &amp;R ), Add( R, i ); Re LD l(0), r(10000), mid, ans(0); while ( r - l &gt; 0.0001 )&#123; mid = ( l + r ) / 2; if ( check( mid ) ) l = mid, ans = mid; else r = mid; &#125; printf( "%.3lf\n", ans ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>背包DP</tag>
        <tag>0/1分数规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「2015南阳CCPC D」金砖 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fgold-brick-solution%2F</url>
    <content type="text"><![CDATA[金砖Problem有一个长度为L的板凳，可以放一排金砖，金砖不能重叠。特别的，摆放的金砖可以超出板凳，前提是必须保证该金砖不会掉下去，即该金砖的重心必须在板凳上。每块金砖都一个长度和价值，且金砖是规则的长方体。请计算最多可以摆放多少价值的金砖。 Input Data第一行，两个整数N和L，分别表示金砖的数量和板凳的长度。接下来N行，每行两个整数，ai和vi，分别表示第i块金砖的长度和价值。 Output Data一行，一个整数，表示最大价值。 Input Sample 112343 74 12 18 1 Output Sample 112 Input Sample 212343 54 12 28 9 Output Sample 2111 Input Sample 3121 110 3 Output Sample 313 思路要做这道题，得先掌握背包的一般思路，这里就不细讲了。 先说下思路。 At first,处理奇数长度的情况（没考虑清楚会WA一个点），因为对于奇数长度金砖，重心位置会出现小数的情况，这就让人很难堪。不过，可以把所有相关长度都乘2，或理解为以0.5为单位长度，这样就不用管奇数长度的情况了。 Secondly,咋处理能长出板凳的情况？？？直接按题目思路不好考虑，就把它转换一下吧。首先，我们很容易得知，最边上的两块要最靠边，及刚好不掉下去，这样可以腾出更大的空间给放在中间的金砖s。然后呢？有些人可能会想预处理出所有不超过板凳长度能放多少价值，再枚举两边的金砖，最后取最大值。However,重复取金砖的情况怎么考虑？？？其实我们可以当做最靠边的金砖长度打五折，或者说有两个金砖长度折半，具体实现就是把f数组再开一维记录已经取了几个“半价“金砖，最后取最大值即可。 Finally,还要考虑长度远大于L的金砖（更严谨地说，就是指长度 &gt; 2 * L的金砖），它们即使“半价”处理也无法放上板凳，但是实际上可以把金砖的重心刚好放在板凳上，两边尽管长出去。好在这种情况会使金砖独占板凳，所以说直接用v来更新ans的值。 具体实现就在下面啦： 代码12345678910111213141516171819202122232425262728#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 4005#define LL long longint N, L;LL f[MAXN];int main()&#123; scanf( "%d%d", &amp;N, &amp;L ); L *= 2; LL ans(0);//注意开long long !important for ( int i = 1; i &lt;= N; ++i )&#123; LL a, v; scanf( "%lld%lld", &amp;a, &amp;v ); a *= 2; if ( a &gt; L * 2 ) ans = max( ans, v ); else for ( int j = L; j &gt;= 1; --j )&#123;//注意零一背包要倒过来 for ( int k = 0; k &lt;= 2; ++k )&#123; if ( j &gt;= a ) f[j][k] = max( f[j][k], f[j - a][k] + v );//放在中间 if ( k &amp;&amp; j &gt;= a / 2 ) f[j][k] = max( f[j][k], f[j - a / 2][k - 1] + v );//放在两边，既“半价处理” ans = max( ans, f[j][k] );//更新ans的值 &#125; &#125; &#125; printf( "%lld", ans ); return 0;&#125; 撒花！（刚好下课）]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P1233」木棍加工 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fluogu1233-solution%2F</url>
    <content type="text"><![CDATA[P1233 木棍加工题目描述一堆木头棍子共有n根，每根棍子的长度和宽度都是已知的。棍子可以被一台机器一个接一个地加工。机器处理一根棍子之前需要准备时间。准备时间是这样定义的： 第一根棍子的准备时间为1分钟； 如果刚处理完长度为L，宽度为W的棍子，那么如果下一个棍子长度为Li，宽度为Wi，并且满足L&gt;＝Li，W&gt;＝Wi，这个棍子就不需要准备时间，否则需要1分钟的准备时间； 计算处理完n根棍子所需要的最短准备时间。比如，你有5根棍子，长度和宽度分别为(4, 9)，(5, 2)，(2, 1)，(3, 5)，(1, 4)，最短准备时间为2（按(4, 9)、(3, 5)、(1, 4)、(5, 2)、(2, 1)的次序进行加工）。 输入输出格式输入格式：第一行是一个整数n(n&lt;＝5000)，第2行是2n个整数，分别是L1，W1，L2，w2，…，Ln，Wn。L和W的值均不超过10000，相邻两数之间用空格分开。 输出格式：仅一行，一个整数，所需要的最短准备时间。 输入输出样例输入样例#1：1254 9 5 2 2 1 3 5 1 4 输出样例#1：12 思路一般来说，数据较大，要求顺序时，要优先考虑贪心（当然，也有可能是动态规划或其他算法，这并不绝对）。 根据题意，最终答案中1min准备后能一次处理的木棍L、W非严递减。我们可以考虑以L为关键字进行降序排序，然后在W中进行类似于“导弹拦截”这道经典题的操作，也就是用最少的装置防御最多的导弹（请自行类比 导弹拦截 具体原因不再赘述）。 总结一下，就是将L降序排序，然后求最长不下降子序列。 废话不多说，直接上代码。 代码123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 5005struct ppp&#123; int L, W;&#125;a[MAXN];bool cmp( ppp x, ppp y )&#123; return x.L &gt; y.L;&#125;int n;int f[MAXN], tot;void Add( int x )&#123; int l(1), r(tot), mid, ans(-1); while( l &lt;= r )&#123; mid = ( l + r ) &gt;&gt; 1; if ( f[mid] &gt;= x )&#123; r = mid - 1; ans = mid; &#125; else l = mid + 1; &#125; if ( ans == -1 ) f[++tot] = x; else f[ans] = x;&#125;int main()&#123; scanf( "%d", &amp;n ); for ( int i = 1; i &lt;= n; ++i ) scanf( "%d%d", &amp;a[i].L, &amp;a[i].W ); sort( a + 1, a + n + 1, cmp ); f[++tot] = a[1].W; for ( int i = 2; i &lt;= n; ++i ) Add( a[i].W ); printf( "%d\n", tot ); return 0;&#125; 2018/11/26修改为Markdown格式]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「2018-11-02模拟赛」t3 老大 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2F2018-11-02-sontest-T3-solution%2F</url>
    <content type="text"><![CDATA[老大题目描述因为 OB 今年拿下 4 块金牌，学校赞助扩建劳模办公室为劳模办公室群，为了体现 OI 的特色，办公室群被设计成了树形（n 个点 n − 1 条边的无向连通图），由于新建的办公室太大以至于要将奖杯要分放在两个不同的地方以便同学们丢硬币进去开光，OB 想请你帮帮他看看奖杯放在哪两个办公室使得在任意一个在劳模办公室做题的小朋友能最快地找到奖杯来开光。一句话题意：给出一个 n 个点的树，在两个合适且不同的点放上奖杯，使得每个点到最近的奖杯距离最大值最小。 输入第一行，一个整数 n。接下来的 n − 1 行，每行两个数 x y 输出一个数，表示最小的最大距离。 样例输入1234567881 21 32 42 53 63 71 8 样例输出12 提示对于前 60% 的数据，n ≤ 100。对于前 80% 的数据，n ≤ 2000。对于 80% 的数据，保证树的形态随机。对于 100% 的数据，保证 3 ≤ n ≤ 200000。 这道题有好多种解法，把题解贴一贴~ 题解3.1 60% O(n3)n2 枚举两个奖杯位置，再 O(n) 扫一遍看看每个位置离最近奖杯最远是多少。 3.2 80% O(n2) 考虑两个奖杯管辖的区域必定有一个边界，我们枚举这个边界，也就是一条边，其中一部分是子树，一部分是子树外，我们只要分别求出另外两个树的直径。3.3 树形态随机 期望树的直径很短，两个奖杯都在直径上枚举。3.4 100% 二分答案 1 O(nlogn) 奖杯在直径上，二分答案后取离直径上离端点距离答案的点，遍历 check 一遍。3.5 100% 二分答案 2 O(nlogn) 随便提一个节点为根，二分答案，深度最深的节点一定要被照顾到，所以最深的点往上跳答案层即可，和其距离答案以内的点都删掉，再做一次。(我最开始的做法QAQ)此法可以拓展到 k 个奖杯，由皮皮轩友情提供。 3.6 100% 树形 dp O(n) 在 80 分的基础上用树形 dp，记下每个点向下前三长和向上一格后不回该子树最长的路径长度。子树内直径是前两长的和与该子树各个子树直径取 max；子树外直径是父节点向上一格后不回该子树最长的路径长度，前两长不进入该子树的向下最长路径这三条取前两长加起来与父节点以上的答案取 max。 思路我使用的应该算第二种二分。 也就是先二分答案——最短距离x，再按深度从大到小枚举节点，如果发现有一个节点距最近奖杯的距离大于x，即!v[i]，那么找它的父亲的父亲的父亲。。。的父亲(共x个父亲)t，在t节点放置一个奖杯，然后搜索将和它距离小于等于x的节点，标记v[i]等于1。 如果发现v[i] == 0 &amp;&amp; cnt &gt;= 2 就直接返回0，因为已经没有更多的奖杯可以放了。这种贪心策略很容易证明，这里不再赘述。 我的AC之路多么坎坷—— 1.用了DFS，自己生成一个200000个节点的链形树，结果发现RE，怀疑可能爆栈，我改。x 2.用了BFS，然后随机生成一棵200000个节点的树，虽然过了，但是发现时间有点慢，用了clock()输出所用时间，发现用了1000+ms，可能会TLE，我再改。 3.输出 读入所用时间，发现已经是几百ms，毅然将scanf改为读优，用了一些register，降了一些复杂度，但仍然不能满足要求，我还要改。 4.怀疑BFS时直接用了queue，复杂度会倍增，于是手打队列，发现复杂度一下子减掉了一半，只有400~500+ms水平，估计没有问题，但是仍然打了对拍（其实DFS打好以后就打了对拍），没有发现错误，实际上也AC了。 给出了那些我打的代码QAQ(好艰辛) 代码123456789101112131415161718192021222324252627282930313233343536//暴力#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 200005int n, x, y;int head[MAXN], nxt[MAXN &lt;&lt; 1], to[MAXN &lt;&lt; 1], tot;int dis[MAXN];inline void Add( int x, int y )&#123; to[++tot] = y; nxt[tot] = head[x]; head[x] = tot;&#125;void dfs( int x, int fa, int d )&#123; dis[x] = min( dis[x], d ); for ( int i = head[x]; i; i = nxt[i] ) if ( to[i] != fa ) dfs( to[i], x, d + 1 );&#125;int main()&#123; scanf( "%d", &amp;n ); for ( int i = 1; i &lt; n; ++i )&#123; scanf( "%d%d", &amp;x, &amp;y ); Add( x, y ); Add( y, x ); &#125; int ans(0x7f7f7f7f); for ( int i = 1; i &lt;= n; ++i ) for ( int j = i + 1; j &lt;= n; ++j )&#123; memset( dis, 0x3f, sizeof dis ); dfs( i, i, 0 ); dfs( j, j, 0 ); int cur(0); for ( int k = 1; k &lt;= n; ++k ) cur = max( cur, dis[k] ); ans = min( ans, cur ); &#125; printf( "%d\n", ans ); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//深搜#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 200005int n, x, y;int head[MAXN], nxt[MAXN &lt;&lt; 1], to[MAXN &lt;&lt; 1], tot;int dep[MAXN], o[MAXN], f[MAXN];int v[MAXN];bool cmp( int x, int y )&#123; return dep[x] &gt; dep[y];&#125;inline void Add( int x, int y )&#123; to[++tot] = y; nxt[tot] = head[x]; head[x] = tot;&#125;void DFS( int x, int fa, int d )&#123; dep[x] = d; f[x] = fa; for ( int i = head[x]; i; i = nxt[i] ) if ( to[i] != fa ) DFS( to[i], x, d + 1 );&#125;void dfs( int x, int fa, int d, int maxd )&#123; if ( d &gt; maxd ) return; v[x] = 1; for ( int i = head[x]; i; i = nxt[i] ) if ( to[i] != fa ) dfs( to[i], x, d + 1, maxd );&#125;bool check( int x )&#123; int cur(0); memset( v, 0, sizeof v ); for ( int i = 1; i &lt;= n; ++i )&#123; if ( !v[o[i]] )&#123; int t(o[i]); for ( int j = 1; j &lt;= x; ++j ) t = f[t]; cur++; if ( cur &gt; 2 ) return 0; dfs( t, t, 0, x ); &#125; &#125; return 1;&#125;int main()&#123; scanf( "%d", &amp;n ); for ( int i = 1; i &lt; n; ++i )&#123; scanf( "%d%d", &amp;x, &amp;y ); Add( x, y ); Add( y, x ); &#125; DFS( 1, 1, 1 ); for ( int i = 1; i &lt;= n; ++i ) o[i] = i; sort( o + 1, o + n + 1, cmp ); int l(1), r(200000), mid, ans(-1); while( l &lt;= r )&#123; mid = ( l + r ) &gt;&gt; 1; if ( check( mid ) ) r = mid - 1, ans = mid; else l = mid + 1; &#125; printf( "%d\n", ans ); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//宽搜（偷懒STL）#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 400005int n, x, y;int head[MAXN], nxt[MAXN &lt;&lt; 1], to[MAXN &lt;&lt; 1], tot;int dep[MAXN], o[MAXN], f[MAXN];int v[MAXN];bool cmp( int x, int y )&#123; return dep[x] &gt; dep[y];&#125;inline void Add( int x, int y )&#123; to[++tot] = y; nxt[tot] = head[x]; head[x] = tot;&#125;void BFS()&#123; queue&lt;int&gt; Q; Q.push(1); f[1] = 1; dep[1] = 1; while( !Q.empty() )&#123; int t(Q.front()); Q.pop(); for ( int i = head[t]; i; i = nxt[i] ) if ( to[i] != f[t] )&#123; dep[to[i]] = dep[t] + 1; f[to[i]] = t; Q.push(to[i]); &#125; &#125;&#125;struct states&#123; int id, de, fa;&#125;;states make_st( int x, int y, int z )&#123; states t; t.id = x; t.de = y; t.fa = z; return t;&#125;void bfs( int x, int maxd )&#123; queue&lt;states&gt; Q; Q.push( make_st( x, 0, x ) ); while( !Q.empty() )&#123; int t(Q.front().id), d(Q.front().de), fth(Q.front().fa); Q.pop(); v[t] = 1; if ( d &gt;= maxd ) continue; for ( int i = head[t]; i; i = nxt[i] ) if ( to[i] != fth ) Q.push( make_st( to[i], d + 1, t ) ); &#125;&#125;bool check( int x )&#123; int cur(0); memset( v, 0, sizeof v ); for ( int i = 1; i &lt;= n; ++i )&#123; if ( !v[o[i]] )&#123; int t(o[i]); for ( int j = 1; j &lt;= x; ++j ) t = f[t]; cur++; if ( cur &gt; 2 ) return 0; bfs( t, x ); &#125; &#125; return 1;&#125;int main()&#123; scanf( "%d", &amp;n ); for ( int i = 1; i &lt; n; ++i )&#123; scanf( "%d%d", &amp;x, &amp;y ); Add( x, y ); Add( y, x ); &#125; BFS(); for ( int i = 1; i &lt;= n; ++i ) o[i] = i; sort( o + 1, o + n + 1, cmp ); int l(1), r(200000), mid, ans(-1); while( l &lt;= r )&#123; mid = ( l + r ) &gt;&gt; 1; if ( check( mid ) ) r = mid - 1, ans = mid; else l = mid + 1; &#125; printf( "%d\n", ans ); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//把STL改为手打QAQ//最后的结果 #include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 200005#define Reg registerint n;int head[MAXN], nxt[MAXN &lt;&lt; 1], to[MAXN &lt;&lt; 1], tot;int dep[MAXN], o[MAXN], f[MAXN];int v[MAXN];int read()&#123; Reg int x(0); Reg char c = getchar(); while ( !isdigit(c) ) c = getchar(); for ( ;isdigit(c); c = getchar() ) x = x * 10 + ( c ^ '0' ); return x;&#125;bool cmp( int x, int y )&#123; return dep[x] &gt; dep[y];&#125;inline void Add( int x, int y )&#123; to[++tot] = y; nxt[tot] = head[x]; head[x] = tot;&#125;int q[MAXN];void BFS()&#123; int tl(1), hd(1); q[1] = 1; f[1] = 1; dep[1] = 1; while( tl &gt;= hd )&#123; int t(q[hd]); hd++; for ( int i = head[t]; i; i = nxt[i] ) if ( to[i] != f[t] )&#123; dep[to[i]] = dep[t] + 1; f[to[i]] = t; q[++tl] = to[i]; &#125; &#125;&#125;struct states&#123; int id, de, fa;&#125;;inline states make_st( int x, int y, int z )&#123; states t; t.id = x; t.de = y; t.fa = z; return t;&#125;states Q[MAXN];void bfs( int x, int maxd )&#123; int tl(1), hd(1); Q[1] = make_st( x, 0, x ); while( tl &gt;= hd )&#123; int t(Q[hd].id), d(Q[hd].de), fth(Q[hd].fa); hd++; v[t] = 1; if ( d &gt;= maxd ) continue; for ( int i = head[t]; i; i = nxt[i] ) if ( to[i] != fth ) Q[++tl] = make_st( to[i], d + 1, t ); &#125;&#125;bool check( int x )&#123; int cur(0); memset( v, 0, sizeof v ); for ( Reg int i = 1; i &lt;= n; ++i )&#123; if ( !v[o[i]] )&#123; int t(o[i]); for ( int j = 1; j &lt;= x; ++j ) t = f[t]; cur++; if ( cur &gt; 2 ) return 0; bfs( t, x ); &#125; &#125; return 1;&#125;int main()&#123;// freopen( "ob.in", "r", stdin );// freopen( "ob.out", "w", stdout ); scanf( "%d", &amp;n ); Reg int x, y; for ( Reg int i = 1; i &lt; n; ++i )&#123; x = read(); y = read(); Add( x, y ); Add( y, x ); &#125; BFS(); for ( Reg int i = 1; i &lt;= n; ++i ) o[i] = i; sort( o + 1, o + n + 1, cmp ); int l(1), r(200000), mid, ans(-1); while( l &lt;= r )&#123; mid = ( l + r ) &gt;&gt; 1; if ( check( mid ) ) r = mid - 1, ans = mid; else l = mid + 1; &#125; printf( "%d\n", ans ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>二分答案</tag>
        <tag>贪心</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P1080」「NOIP2012提高组」国王游戏 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fluogu1080-solution%2F</url>
    <content type="text"><![CDATA[P1080 国王游戏题目描述恰逢 $H$国国庆，国王邀请$n$位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 $n$ 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。 国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。 输入输出格式输入格式：第一行包含一个整数$n$，表示大臣的人数。 第二行包含两个整数 $a$和 $b$，之间用一个空格隔开，分别表示国王左手和右手上的整数。 接下来 $n$行，每行包含两个整数$a$ 和 $b$，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。 输出格式：一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。 输入输出样例输入样例#1：123453 1 1 2 3 7 4 4 6 输出样例#1：12 说明【输入输出样例说明】 按11、22、33 这样排列队伍，获得奖赏最多的大臣所获得金币数为 22； 按 11、33、22 这样排列队伍，获得奖赏最多的大臣所获得金币数为22； 按 22、11、33 这样排列队伍，获得奖赏最多的大臣所获得金币数为 22； 按22、33、11这样排列队伍，获得奖赏最多的大臣所获得金币数为99； 按 33、11、22这样排列队伍，获得奖赏最多的大臣所获得金币数为 22； 按33、22、11 这样排列队伍，获得奖赏最多的大臣所获得金币数为 99。 因此，奖赏最多的大臣最少获得 22个金币，答案输出 22。 【数据范围】 对于 20%的数据，有 1≤ n≤ 10,0 &lt; a,b &lt; 81≤n≤10,0&lt; a,b&lt;8； 对于 40%的数据，有1≤ n≤20,0 &lt; a,b &lt; 81≤n≤20,0&lt; a,b&lt;8； 对于 60%的数据，有 1≤ n≤1001≤n≤100； 对于 60%的数据，保证答案不超过 10^9109； 对于 100%的数据，有 1 ≤ n ≤1,000,0 &lt; a,b &lt; 100001≤n≤1,000,0&lt; a,b&lt;10000。 NOIP 2012 提高组 第一天 第二题 思路我们假设一个正确的序列中有两个元素 i 与 i + 1,他们左右手的数字分别为Ai，Bi，Ai+1，Bi+1 排在i大臣前面的所有人的左手上的数的乘积为T(以下向下取整省略不写) 这两位大臣得到最多的硬币为 max( T / Bi, (T * Ai) / Bi+1 ) = Ans1 假设交换这两位大臣 则他们得到最多硬币数变为 max( T / Bi+1, (T * Ai+1) / Bi ) = Ans2 要求Ans1 &lt;= Ans2，原序列顺序可能不是最优（否则这两位大臣交换能得到更有策略） 所以要使 T / Bi 和 (T * Ai) / Bi+1都小于等于Ans2即可满足要求 由于T / Bi &lt;= (T Ai+1) / Bi ，T / Bi 肯定能满足要求，只要使 ( T Ai ) / Bi+1 也小于等于 Ans2即可 (T Ai) / Bi+1 肯定大于等于 T / Bi+1 ，所以只能使 (T Ai+1) / Bi 大于等于(T * Ai) / Bi+1 ,否则不能达到要求 然后我们就可以列出不等式 (T Ai) / Bi+1 &lt;= (T Ai+1) / Bi 因为T是正数，所以可以同时消去 Ai / Bi+1 &lt;= Ai+1 / Bi 同乘Bi+1Bi Ai Bi &lt;= Ai+1 Bi+1 所以，只要按Ai * Bi从小到大排序就不成问题了。（当然别把国王也排序了） 注意要加高精度。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 10005struct ppp&#123; int a, b;&#125;p[MAXN];int n;bool cmp( ppp x, ppp y )&#123; return x.a * x.b &lt; y.a * y.b;&#125;int s[4005], len;int ans[4005], ans_l(0);void Mul( int x )&#123; int t(len); for ( int i = 1; i &lt;= len; ++i ) s[i] *= x; for ( int i = 1; i &lt;= len + 5; ++i )&#123; if ( s[i] ) t = i; s[i + 1] += s[i] / 10; s[i] %= 10; &#125; len = t;&#125;void Copy( int c[], int c_l )&#123; for ( int i = 1; i &lt;= c_l; ++i ) ans[i] = c[i]; ans_l = c_l;&#125;void Out( int s[], int l )&#123; for ( int i = l; i &gt;= 1; --i ) printf( "%d", s[i] ); putchar('\n');&#125;void Div( int x )&#123; int c[4005], l(-1); for ( int i = 1; i &lt;= len; ++i ) c[i] = s[i]; for ( int i = len; i &gt;= 1; --i )&#123; c[i - 1] += ( c[i] % x ) * 10; c[i] /= x; if ( c[i] &amp;&amp; l == -1 ) l = i; &#125; if ( ans_l == l )&#123; bool flg(0); for ( int i = l; i &gt;= 1; --i ) if ( ans[i] &lt; c[i] )&#123; flg = 1; break; &#125; else break; if ( flg ) Copy( c, l ); &#125; if ( ans_l &lt; l ) Copy( c, l );&#125;int main()&#123; scanf( "%d", &amp;n ); scanf( "%d%d", &amp;p[0].a, &amp;p[0].b ); for ( int i = 1; i &lt;= n; ++i ) scanf( "%d%d", &amp;p[i].a, &amp;p[i].b ); sort( p + 1, p + n + 1, cmp ); s[1] = 1; len = 1; Mul( p[0].a ); for ( int i = 1; i &lt;= n; ++i ) Div( p[i].b ), Mul( p[i].a ); Out( ans, ans_l ); return 0;&#125; 完事！！！]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>贪心</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIP 2018 普及组 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fnoip-2018-pj-solution%2F</url>
    <content type="text"><![CDATA[比完小结今年的题目出的有点诡异，难度跨越有点大 入门 to 普及- to(注意：前方东非大裂谷，请小心慢行) 提高+/省选- to 提高+/省选- 不过实际上没有这么难 T3、T4 一个DP 一个暴力（虽然不是正解） 也就可以过了 扯入正题 T1 标题统计这道题十分的水，没有什么技术含量，随便怎么搞都可以过。 下面是我直接放代码了。。。 1234567891011121314#include&lt;bits/stdc++.h&gt;using namespace std;char t;int ans(0);int main()&#123; freopen( "title.in", "r", stdin ); freopen( "title.out", "w", stdout ); while( ( t = getchar() ) != EOF ) if ( t != ' ' &amp;&amp; t != '\n' &amp;&amp; t != '\r' ) ans++; printf( "%d", ans ); return 0;&#125; T2 龙虎斗这道题没话说，只是题目长了点，好好理解一下也是不难的。我们可以预处理出两边阵营的气势和（别忘了加上“某一刻天降神兵”）然后枚举每个兵营，把你的兵加进去，算出之后两个阵营最终的气势，然后选出气势之差绝对值最小的哪个阵营就可以了。C++内置的函数abs由于老是忘掉是什么类型的，所以干脆手打算了。。。话不多说，直接上代码（普及- 及以下难度的不用具体讲吧？）。还有注意要开 long long。（死了也别忘记）据说没开long long只能得70左右。 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;LL n, m, p1, s1, s2;LL s[166666];LL L, R;LL ans(-1), q(0x7f7f7f7f7f7f7f7f);LL Abs( LL x )&#123; return x &gt;= 0 ? x : -x;&#125;int main()&#123; freopen( "fight.in", "r", stdin ); freopen( "fight.out", "w", stdout ); scanf( "%lld", &amp;n ); for ( int i = 1; i &lt;= n; ++i ) scanf( "%lld", &amp;s[i] ); scanf( "%lld%lld%lld%lld", &amp;m, &amp;p1, &amp;s1, &amp;s2 ); s[p1] += s1; for ( int i = 1; i &lt;= n; ++i )&#123; if ( i &lt; m ) L += ( m - i ) * s[i]; if ( i &gt; m ) R += ( i - m ) * s[i]; &#125; for ( int i = 1; i &lt;= n; ++i )&#123; LL tL(L), tR(R), c; if ( i &lt; m ) tL += ( m - i ) * s2; if ( i &gt; m ) tR += ( i - m ) * s2; c = Abs( tL - tR ); if ( c &lt; q ) ans = i, q = c; &#125; printf( "%lld\n", ans ); return 0;&#125; T3 摆渡车看这道题的时候，我（相信大家也是这样）最先想到的是贪心，但是从数据范围可以看出，如果是贪心题，数据范围不会那么小（相信NOIP不会和Luogu月赛一样，2018 11月月赛 搞个几百大小数据骗我们用DP，结果是贪心）。有些人会想(including me)，是不是在有人到达时才能发车呢？？？没想清楚就下手的话，就会浪费好多时间。仔细想想，很容易发现不一定要有人到达时发车，比如有时候，bus一回来，有个人等了2分钟，后面那个人还有INF(hh) min 才会来，如果有人到达时才能发车，那么bus将在INF min后才等到一个人，原来等了2分钟的那个人与司机等得花都谢了，所以这时候肯定是一回来就发车，虽然没有人刚好到达。 当然，我们先排序。（DP，从排序做起）。 我们用f[i]表示i min 时发一辆车，ps[i]表示1 ~ i 的人数，ts[i]表示1 ~ i 所有人开始等的时间之和。设上一次发车是jmin时，那么j min及以前的人都已经滚粗了，我们要求j + 1 ~ i所有人等待时间之和。等待时间之和为Σ(i - t[k]) 可以简化为 i * 人数 - Σ(t[k])， 人数、Σ(t[k])可以用前缀和来维护（即前面提到的ps、ts数组）。然后就可以得到转移方程—— 12( 0 &lt;= i &lt; m ) f[i] = ps[i] * i - ts[i]( i &gt; m ) f[i] = min&#123; f[j] + ( ps[i] - ps[j] ) * i - ( ts[i] - ts[j] ) &#125;( 0 &lt;= j &lt;= i - m ) 蓝鹅，这样的复杂度达到了O(MAXT ^ 2)!!!这是远远不行的。所以我们要进行优化~ 优化I 对于两个人a、b( ta &lt; tb,b = a + 1) 如果 tb - ta &gt;= 2 * m 可以从中间断开 如果用work( l, r )表示对l、r区间范围内进行一次DP work( ls, ta ), ls = tb; 很容易解释，因为如果两个人之间时间间隔不小于2m的话，他们是完全可以分两趟车走的。因为a最迟走的时间为ta + m - 1，车回来的时间为ta + 2m - 1,如果tb &gt;= ta + 2m - 1，刚好可以直接粗发QAQ。(或者理解为b可以作为起点) 优化II i - 2* m + 1 &lt;= j &lt;= i - m 不难理解，每两趟车之间间隔不会超过或等于2m（否则中间为什么不再来一趟呢？？？） 实际上，这已经满足题目的时间复杂度要求，但是还有一个乱搞优化。(在考场上想到的) 优化III if ps[i] == ps[i - 1] ​ j = i - m 解释这个优化要从贪心的角度考虑。 回到原来那个问题:是不是在有人到达时才能发车呢？？？ 前面已经解释了答案是否定的。这从一个侧面告诉我们，如果不是在有人到达时才发车，肯定是由于车来不及回来。 所以，在最优方案中，那趟车一定会在刚好回来时发车。也就是说，i min时车刚好回来，上一次发车是在 i - m min时。 真是玄之又玄。 最终的程序不是在考场中写的，因为考场中 优化I 采用了路径压缩的方法，但是出现一些问题，被卡掉20分。 算法的复杂度也是在O(nm)级别，但常数要比Sooke大佬的代码大一些。 然后上代码！（虽然不是最好的解，但87ms也凑合吧。） 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 505#define MAXM 205int n, m, mm, ans;int t[MAXN], ps[MAXM * MAXN], ts[MAXM * MAXN];int f[MAXM * MAXN];void work( int l, int r )&#123; memset( ps, 0, sizeof ps ), memset( ts, 0, sizeof ts ), memset( f, 0, sizeof f ); for ( int i = l + 1; i &lt;= r; ++i )&#123; t[i] -= t[l]; ps[t[i]]++; ts[t[i]] += t[i]; &#125; t[l] = 0; ps[0]++; for ( int i = 1; i &lt; t[r] + m; ++i ) ps[i] += ps[i - 1], ts[i] += ts[i - 1]; for ( int i = 1; i &lt; t[r] + m; ++i )&#123; if ( i &lt; m )&#123; f[i] = ps[i] * i - ts[i]; continue; &#125; if ( ps[i] == ps[i - 1] )&#123; f[i] = f[i - m] + ( ps[i] - ps[i - m] ) * i - ( ts[i] - ts[i - m] ); continue; &#125; f[i] = INT_MAX; for ( int j = max( 0, i - mm + 1 ); j &lt;= i - m; ++j ) f[i] = min( f[i], f[j] + ( ps[i] - ps[j] ) * i - ( ts[i] - ts[j] ) ); &#125; int cur(INT_MAX); for ( int i = t[r]; i &lt; t[r] + m; ++i ) cur = min( cur, f[i] ); ans += cur; &#125;int main()&#123; scanf( "%d%d", &amp;n, &amp;m ); mm = m &lt;&lt; 1; for ( int i = 1; i &lt;= n; ++i ) scanf( "%d", &amp;t[i] ); sort( t + 1, t + n + 1 ); int ls(1); for ( int i = 1; i &lt; n; ++i ) if ( t[i + 1] - t[i] &gt;= mm ) work( ls, i ), ls = i + 1; work( ls, n ); printf( "%d\n", ans ); return 0;&#125; 非常抱歉，虽然这个代码通过了一些民间数据，但CCF的数据实在太强，把我原来的代码卡到了80分，以上代码70分，具体错误还不清楚，所以就暂时留坑QAQ。updata 2018/11/30 23:03: 总算填好坑了QAQ T4 对称二叉树这道题我也不知道正解是什么。我直接暴力+剪枝也跑过了所有测试点（数据太水？） 我们可以考虑当将一棵树所有节点的左右子树交换，那么搜索的顺序左变右，右变左。 即原来对于节点P，从根节点到P的路径是左右左左右，那么反转后根节点到P’的位置的路径就是右左右右左。 我们直接枚举每个子树的根节点，把原来的点、翻转后的点一一对应就可以了。 实现起来也不难。注意加点剪枝（不解释剪枝原理了）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1000000 + 0xac;//AC万岁！！！int n, v[MAXN], d[MAXN], s[MAXN];unsigned long long M1[MAXN], M2[MAXN], M3[MAXN];int L[MAXN], R[MAXN];void DFS( int x, int dep )&#123; s[x] = 1; M1[x] = v[x]; M2[x] = v[x]; M3[x] = dep * v[x]; if ( L[x] != -1 ) DFS( L[x], dep + 1 ), s[x] += s[L[x]], M1[x] *= M1[L[x]], M2[x] += M2[L[x]], M3[x] += M3[L[x]]; d[x] = dep; if ( R[x] != -1 ) DFS( R[x], dep + 1 ), s[x] += s[R[x]], M1[x] *= M1[R[x]], M2[x] += M2[R[x]], M3[x] += M3[R[x]];&#125;bool check( int x, int y )&#123; if ( v[x] != v[y] || s[x] != s[y] || M1[x] != M1[y] || M2[x] != M2[y] || M3[x] != M3[y] ) return 0; if ( L[x] &gt; 0 || R[y] &gt; 0 )&#123; if ( L[x] &lt; 0 || R[y] &lt; 0 ) return 0; if ( !check( L[x], R[y] ) ) return 0; &#125; if ( R[x] &gt; 0 || L[y] &gt; 0 )&#123; if ( R[x] &lt; 0 || L[y] &lt; 0 ) return 0; if ( !check( R[x], L[y] ) ) return 0; &#125; return 1;&#125;bool cmp( int x, int y )&#123; return s[x] &gt; s[y];&#125;int main()&#123; freopen( "tree.in", "r", stdin ); freopen( "tree.out", "w", stdout ); scanf( "%d", &amp;n ); for ( int i = 1; i &lt;= n; ++i ) scanf( "%d", &amp;v[i] ); for ( int i = 1; i &lt;= n; ++i ) scanf( "%d%d", &amp;L[i], &amp;R[i] ); DFS( 1, 1 ); int ans(1); for ( int i = 1; i &lt;= n; ++i ) if ( s[i] &gt; ans &amp;&amp; check( i, i ) ) ans = max( ans, s[i] ); printf( "%d\n", ans ); return 0;&#125; 鸣谢感谢叶康杰童鞋的审核。感谢CCF提供的数据（尤其是把我T3卡掉了的那些QAQ）。]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>NOIP普及组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「2018-11-05模拟赛」T5 传送机 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2F2018-11-05-contest-T5-solution%2F</url>
    <content type="text"><![CDATA[5、传送机(sent.*)问题描述:黄黄同学要到清华大学上学去了。黄黄同学很喜欢清华大学的校园，每次去上课时总喜欢把校园里面的每条路都走一遍，当然，黄黄同学想每条路也只走一遍。我们一般人很可能对一些地图是办不到每条路走一遍且仅走一遍的，但是黄黄同学有个传送机，他可以任意地将一个人从一个路口传送到任意一个路口。可是，每传送一次是需要耗费巨大的内力的，黄黄同学希望可以用最少的传送次数完成游遍校园，你帮助他吗？因为黄黄同学只是游历校园，于是我们可以认为黄黄同学可以从任意点开始，到任意点结束。注意：不必经过所有的点。输入格式：输入第一行一个整数N，表示黄黄的校园里一共有多少路口。第二行一个整数M，表示路口之间有M条路。后面M行，每行两个整数a、b，表示a与b之间有一条路，且路是双向的。输出格式：输出一行一个整数S，表示黄黄同学最少的传送次数。 输入样例：321 22 3 输出样例：0 数据规模：对于100%的数据满足：N&lt;=100000，M&lt;=500000，1&lt;=a，b&lt;=N。 知识储备：奇点：度数为奇数的点 //度数是什么就不解释了 当一个连通图的奇点个数为0或2时，该连通图可以从某个点出发，经过每条边一次（仅一次）//自己概括，可能有所疏忽，请大家指出错误之处！ 一句话概括，就是添加最少的边，使它构成一个欧拉回路，也就是广为人知的一笔画问题。 这样理解，你就死了因为根据之前我的题解，会导致细节贼多，超难理解，所以我换了种思路 可以这样考虑：不要看总体，考虑每个连通块分别构成欧拉回路，也就是对于每个连通块，连上 max((奇点个数 - 2) / 2,0)条边 再将所有连通块的起点和终点顺次相连，这样就可以保证整个图构成欧拉回路了 不难理解吧（由于目前时间紧迫，有时间再添加具体细节） 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 100005int N, M;int fa[MAXN];int s[MAXN], a[MAXN];int find( int x )&#123; if ( x == fa[x] ) return x; return fa[x] = find( fa[x] );&#125;void Merge( int x, int y )&#123; x = find(x); y = find(y); if ( x != y ) fa[x] = y;&#125;int main()&#123; scanf( "%d%d", &amp;N, &amp;M ); if ( M == 0 )&#123; printf( "0\n" ); return 0; &#125; for ( int i = 1; i &lt;= N; ++i ) fa[i] = i; for ( int i = 1; i &lt;= M; ++i )&#123; int x, y; scanf( "%d%d", &amp;x, &amp;y ); s[x]++; s[y]++; Merge( x, y ); &#125; for ( int i = 1; i &lt;= N; ++i ) a[find(i)] += s[i] % 2; int ans(0); for ( int i = 1; i &lt;= N; ++i ) if ( s[i] &gt; 0 &amp;&amp; find(i) == i ) ans = ans + 1 + max( 0, ( a[i] - 2 ) / 2 ); printf( "%d\n", ans - 1 ); return 0;&#125; 完结撒花]]></content>
      <tags>
        <tag>欧拉回路</tag>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P1196」「NOI2002」银河英雄传说 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fluogu1196-solution%2F</url>
    <content type="text"><![CDATA[P1196 [NOI2002]银河英雄传说题目描述公元五八○一年，地球居民迁至金牛座α第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。 宇宙历七九九年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。 杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成$30000$列，每列依次编号为$1, 2, …,30000$。之后，他把自己的战舰也依次编号为$1, 2, …, 30000$，让第$i$号战舰处于第$i$列$(i = 1, 2, …, 30000)$，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为$M_{i,j}$，含义为第i号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第j号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。 然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。 在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：$C_{i,j}$。该指令意思是，询问电脑，杨威利的第ii号战舰与第jj号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。 作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。 最终的决战已经展开，银河的历史又翻过了一页…… 输入输出格式输入格式：第一行有一个整数$T(1 \le T \le 500,000)$，表示总共有TT条指令。 以下有$T$行，每行有一条指令。指令有两种格式： $M_{i,j}$ ：$i$和$j$是两个整数$(1 \le i,j \le 30000)$，表示指令涉及的战舰编号。该指令是莱因哈特窃听到的杨威利发布的舰队调动指令，并且保证第ii号战舰与第jj号战舰不在同一列。 $C_{i,j}$ ：$i$和$j$是两个整数$(1 \le i,j \le 30000)$，表示指令涉及的战舰编号。该指令是莱因哈特发布的询问指令。 输出格式：依次对输入的每一条指令进行分析和处理： 如果是杨威利发布的舰队调动指令，则表示舰队排列发生了变化，你的程序要注意到这一点，但是不要输出任何信息； 如果是莱因哈特发布的询问指令，你的程序要输出一行，仅包含一个整数，表示在同一列上，第$i$号战舰与第$j$号战舰之间布置的战舰数目。如果第$i$号战舰与第$j$号战舰当前不在同一列上，则输出$-1$。 输入输出样例输入样例#1：123454M 2 3C 1 2M 2 4C 4 2 输出样例#1：12-11 说明【样例说明】 战舰位置图：表格中阿拉伯数字表示战舰编号 写在前面这是一道边带权并查集的好题。(我的题解可能对不了解并查集的人不太友好) 思路我们很容易想到记录每只船在某处排行位置，然后询问时直接减一减就可以了。就这样，问题转换为如何保留每个数的位置(d[i])。 Hint:注意，为了方便，我们把d[i]记作相对f[i]的位置。 当一列船(记为A 首只船为 a)合并到另一列(记为B 首只船为b)时，我们为了让a直接以b为父亲，我们要记录每一列船的只数(s[i])，将d[a]修改为s[a] + 1(连到最后时rank为原来船数+1)，别忘了修改s[b]与f[a]的值。对于后面父亲不为B的先不管。当寻找祖先时，对于父亲是祖先的船，我们不用修改，因为在合并时已经修改过了，而对于父亲不是祖先的船，我们可以先修改它的父亲(递归进行)，是他的父亲的父亲为它的老祖宗，然后把它的d[i] = d[i] + d[f[i]];这样就把参照物改为他的祖宗，实现了路径压缩。 代码很短，只有一点点。。。 代码1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;#define N 30000int T;int f[N + 5], d[N + 5], s[N + 5];int find( int x )&#123; if ( f[x] == x ) return x; int fa(find(f[x])); d[x] = d[x] + d[f[x]] - 1; return f[x] = fa;&#125;void Merge( int x, int y )&#123; x = find(x); y = find(y); if ( x == y ) return; f[x] = y; d[x] = s[y] + 1; s[y] += s[x];&#125;int main()&#123; scanf( "%d", &amp;T ); for ( int i = 1; i &lt;= N; ++i ) f[i] = i, d[i] = 1, s[i] = 1; while( T-- )&#123; char t; int x, y; while( ( t = getchar() ) != 'M' &amp;&amp; t != 'C' ); scanf( "%d%d", &amp;x, &amp;y ); if ( t == 'M' ) Merge( x, y ); else&#123; if ( find(x) == find(y) )&#123; if ( x == y ) printf("0\n"); else if ( d[x] &gt; d[y] ) printf( "%d\n", d[x] - d[y] - 1 ); else printf( "%d\n", d[y] - d[x] - 1 ); &#125; else printf( "-1\n" ); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「黑科技」查错神器——对拍]]></title>
    <url>%2F2019%2F01%2F23%2Fblack-technology-duipai%2F</url>
    <content type="text"><![CDATA[对拍是个好东西。 对拍真是个好东西。 对拍的的确确是个好东西。 当你苦苦找题解，却找不出自己代码哪里错，而OJ不给数据的时候—— 当你灵光一闪，give birth to a new problem 的时候，却不知自己打的标程是否有误的时候—— 当你比赛时间充裕，担心自己代码有问题的时候—— 那就来打对拍吧！！！！ 不会打？？具体怎么做？？继续往下看！！！ 知识储备首先要普及一下bat(不是BAT Baidu Alibaba Tencent)的知识，因为它是对拍的主要组成部分. 大家用过cmd吧？？（Windows + R -&gt; cmd -&gt; Enter）大家先了解下命令提示符的一些命令—— shutdown -p(不解释 暗笑) fc 1.txt 2.txt (将1.txt 2.txt 的内容进行比较) data.exe （调用data.exe这个可执行文件） &gt; 以及 &lt; (表示文件传输方向，1.exe &lt; input.txt &gt; output.txt 将input.txt的内容输入到1.exe中，并将结果输出到output.txt中 ) errorlevel 1 （大家暂时理解为一个bool类型的变量吧） if （分支语句） goto (跳转到某个标记，如下图，这样可以实现不断执行:loop 和 goto loop之间的内容) pause (暂停) @echo off （把那些没用的信息全部过滤掉） 然后就可以完成一个简单的对拍啦！！ 大家试着理解一下 手把手教你用对拍data.cpp里写着随机生成数据的代码（下面以对拍 公主的工作 为例，将我的代码和Hzwer大佬的题解对拍）要编译哦（F12） 别忘了打随机数种子srand(time(0)); 注意不用文件输出。因为 data.exe &gt; read.txt 已经确定了输出方向。 再把我的代码（前面那个45行的）放到1.cpp中，Hzwer大佬的代码（另一个）放到2.cpp中（为了能放在图中，将花括号位置进行了一些处理） 然后编译（注意要和data.exe放在同一个文件夹），生成两个exe文件（1.exe and 2.exe）。 然后新建一个文本文档，将扩展名改为bat,名字随便取（如dp.bat，lalala.bat，duipai.bat随便你） 右键dp.bat，点编辑 再把刚才那串东西输进去 然后保存，点击dp.bat 呀，发现错误啦！！！ 蓝后点击read.txt，那就是你出错的样例。 emmm，OMG!!! ans 没赋初值！！！！ 改为ans(0) 蓝后就。。。。。。 这就说明你的代码基本没问题了。然后我就AC了QAQ 对拍下载 解析实际上呢，具体过程是不难理解的（刚才那些神奇的cmd语句应该都会了吧） 先调用data.exe将随机生成的数据输出到data.txt中，这样就得到了一组随机的样例 然后分别调用1.exe 2.exe输入样例，并输出结果，然后将它 fc 比较一下(comp应该也可以实现)。 将上述过程重复执行，直到发现两个程序得到的两个答案有所不同（注意：行末空格也算） 然后就可以从中得出错误的地方 补充lch大佬友情提供了cpp对拍的写法 见TOPOI博客的下方评论]]></content>
      <tags>
        <tag>黑科技</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「分块系列」数列分块入门1 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fblock-I-solution%2F</url>
    <content type="text"><![CDATA[数列分块入门1题意概括区间加法，单点求值。 写在前面数列分块是个好东西。。。我这里详细介绍一下分块算法，便于初学者的理解（我这个蒟蒻原来也是看不懂分块）。 分块简要介绍先把数组分成几个块块，然后就可以对它们整体操作啦。 也就是说，把一个长度为的数组，拆分成一个个长度为sqrt(n)小块(当然，最后一块可能不完整，但是不用管)，记录每个数所属的块；也就是这样——(方便起见，我们直接再开一个数组来记录所属分块，虽然本题中可以临时计算，但在有些题目中这一步显得尤为重要) 1234scanf( "%d", &amp;n );m = (int)sqrt(n);for ( int i = 1; i &lt;= n; ++i ) p[i] = ( i - 1 ) / m + 1;for ( int i = 1; i &lt;= n; ++i ) scanf( "%d", &amp;a[i] ); 然后，就可以瞎暴力辣！ 实际上，所有的分块都是这样。把一个数列分成几块，然后对它们进行批量处理。一般来说，我们直接把块大小设为sqrt(n)，但实际上，有时候我们要根据数据范围、具体复杂度来确定。 正题当有修改时，对于完整的块，直接维护一个数组v记录整个块加过的数(每块共同的加数)，不完整的就直接暴力在原数组a上直接加。询问时，直接输出原数组的值+所属块的共同加数即可。 代码123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;#define MAXN 50005int n, a[MAXN], p[MAXN], m, v[300];int opt, l, r, c;void Add( int l, int r, int c )&#123; if ( p[l] == p[r] )&#123;//同属一分块时直接暴力即可 for ( int i = l; i &lt;= r; ++i ) a[i] += c; return; &#125; for ( int i = l; p[i] == p[l]; ++i ) a[i] += c;//对于两边不完整(即使完整也不管,看做不完整)的分块，直接暴力即可 for ( int i = r; p[i] == p[r]; --i ) a[i] += c; for ( int i = p[l] + 1; i &lt;= p[r] - 1; ++i ) v[i] += c;//记录完整分块的共同加数&#125;int main()&#123; scanf( "%d", &amp;n ); m = (int)sqrt(n); for ( int i = 1; i &lt;= n; ++i ) p[i] = ( i - 1 ) / m + 1;//记录所属分块 for ( int i = 1; i &lt;= n; ++i ) scanf( "%d", &amp;a[i] ); for ( int i = 1; i &lt;= n; ++i )&#123; scanf( "%d%d%d%d", &amp;opt, &amp;l, &amp;r, &amp;c ); if ( opt == 0 ) Add( l, r, c ); else printf( "%d\n", v[p[r]] + a[r] );//所属分块共同加数+原数组的值 &#125; return 0;&#125; 总结分块代码可以比线段树简洁不少，虽然暴力但十分巧妙，而且十分灵活，适用于更多的题目。 但是如果时间复杂度要求较高，分块的O(n sqrt(n))就不能承受了，所以还是要学会乖乖打线段树QAQ。]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「分块系列」数列分块入门2 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fblock-II-solution%2F</url>
    <content type="text"><![CDATA[数列分块入门2题意概括区间加法，区间询问小于一个数的个数。 正题对于每个块，除原数组之外用一个vector来有序地存储所有数。当区间加时，对于每个完整块维护共同加数，对于不完整的块直接暴力加上再重新排序。当询问时，对于每个完整块在vector中二分，对于不完整的，直接暴力计数。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;#define MAXN 50005int n, m, a[MAXN], p[MAXN], b[500], mm;vector&lt;int&gt; v[500];int opt, l, r, c;int EF( vector&lt;int&gt; vec, int x )&#123;//自力更生，手打二分万岁QAQ int l, r, mid, ans(-1); l = 0; r = vec.size() - 1; while( l &lt;= r )&#123; mid = ( l + r ) &gt;&gt; 1; if ( vec[mid] &lt; x )&#123; ans = mid; l = mid + 1; &#125; else r = mid - 1; &#125; return ans + 1;&#125;int query( int l, int r, int c )&#123; int ans(0); if ( p[l] == p[r] )&#123; for ( int i = l; i &lt;= r; ++i ) if ( a[i] + b[p[l]] &lt; c ) ans++; return ans; &#125; for ( int i = l; p[i] == p[l]; ++i ) if ( a[i] + b[p[i]] &lt; c ) ans++; for ( int i = r; p[i] == p[r]; --i ) if ( a[i] + b[p[i]] &lt; c ) ans++; for ( int i = p[l] + 1; i &lt;= p[r] - 1; ++i ) ans += EF( v[i], c - b[i] ); return ans;&#125;void re( int x )&#123; v[x].clear(); int be(( x - 1 ) * m + 1); for ( int i = be; p[i] == p[be]; i++ ) v[x].push_back( a[i] ); sort( v[x].begin(), v[x].end() );&#125;void Add( int l, int r, int c )&#123; if ( p[l] == p[r] )&#123; for ( int i = l; i &lt;= r; ++i ) a[i] += c; re( p[l] ); return; &#125; for ( int i = l; p[i] == p[l]; ++i ) a[i] += c; re(p[l]);//重排。实际上可以归并排序，或者要用时再临时排序，这里偷了懒QAQ for ( int i = r; p[i] == p[r]; --i ) a[i] += c; re(p[r]); for ( int i = p[l] + 1; i &lt; p[r]; ++i ) b[i] += c;&#125;int main()&#123; scanf( "%d", &amp;n ); m = (int)sqrt(n); for ( int i = 1; i &lt;= n; ++i ) p[i] = ( i - 1 ) / m + 1, mm = p[i]; for ( int i = 1; i &lt;= n; ++i ) scanf( "%d", &amp;a[i] ); for ( int i = 1; i &lt;= n; ++i ) v[p[i]].push_back(a[i]); for ( int i = 1; i &lt;= mm; ++i ) sort( v[i].begin(), v[i].end() ); for ( int i = 1; i &lt;= n; ++i )&#123; scanf( "%d%d%d%d", &amp;opt, &amp;l, &amp;r, &amp;c ); if ( opt ) printf( "%d\n", query( l, r, c * c ) ); else Add( l, r, c ); &#125; return 0;&#125; 总结比起其他算法老长老长的代码，分块算法的灵活在本题中得到体现QAQ]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「分块系列」数列分块入门3 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fblock-III-solution%2F</url>
    <content type="text"><![CDATA[数列分块入门3题意概括区间加法，区间求前驱。 写在前面这题的方法与分块2方法极其类似，建议自行解决。 正题和上一题类似，但是二分不是用来计数的，而是用来求小于c的最大值的。然后对于不完整快，将小于c的值求最大值，再与所有块中二分结果求最大值即可。(其他思路上一篇题解已经讲了，这里不再复述，代码注释也懒得打了，因为比较简单，很容易理解) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;#define MAXN 100005int n, m, a[MAXN], p[MAXN], b[1005], mm;vector&lt;int&gt; v[1005];int opt, l, r, c;int EF( vector&lt;int&gt; vec, int x )&#123; int l, r, mid, ans(-1); l = 0; r = vec.size() - 1; while( l &lt;= r )&#123; mid = ( l + r ) &gt;&gt; 1; if ( vec[mid] &lt; x )&#123; ans = mid; l = mid + 1; &#125; else r = mid - 1; &#125; return ans;&#125;int query( int l, int r, int c )&#123; int ans(-1); if ( p[l] == p[r] )&#123; for ( int i = l; i &lt;= r; ++i ) if ( a[i] + b[p[l]] &lt; c ) ans = max( ans, a[i] + b[p[l]] ); return ans; &#125; for ( int i = l; p[i] == p[l]; ++i ) if ( a[i] + b[p[i]] &lt; c ) ans = max( ans, a[i] + b[p[l]] ); for ( int i = r; p[i] == p[r]; --i ) if ( a[i] + b[p[i]] &lt; c ) ans = max( ans, a[i] + b[p[r]] ); for ( int i = p[l] + 1; i &lt;= p[r] - 1; ++i )&#123; int t(EF( v[i], c - b[i] )); if ( t &gt;= 0 ) ans = max( ans, v[i][t] + b[i] ); &#125; return ans;&#125;void re( int x )&#123; v[x].clear(); int be(( x - 1 ) * m + 1); for ( int i = be; p[i] == p[be]; i++ ) v[x].push_back( a[i] ); sort( v[x].begin(), v[x].end() );&#125;void Add( int l, int r, int c )&#123; if ( p[l] == p[r] )&#123; for ( int i = l; i &lt;= r; ++i ) a[i] += c; re( p[l] ); return; &#125; for ( int i = l; p[i] == p[l]; ++i ) a[i] += c; re(p[l]); for ( int i = r; p[i] == p[r]; --i ) a[i] += c; re(p[r]); for ( int i = p[l] + 1; i &lt; p[r]; ++i ) b[i] += c;&#125;int main()&#123; scanf( "%d", &amp;n ); m = (int)sqrt(n); for ( int i = 1; i &lt;= n; ++i ) p[i] = ( i - 1 ) / m + 1, mm = p[i]; for ( int i = 1; i &lt;= n; ++i ) scanf( "%d", &amp;a[i] ); for ( int i = 1; i &lt;= n; ++i ) v[p[i]].push_back(a[i]); for ( int i = 1; i &lt;= mm; ++i ) sort( v[i].begin(), v[i].end() ); for ( int i = 1; i &lt;= n; ++i )&#123; scanf( "%d%d%d%d", &amp;opt, &amp;l, &amp;r, &amp;c ); if ( opt ) printf( "%d\n", query( l, r, c ) ); else Add( l, r, c ); &#125; return 0;&#125; 总结分块切记要触类旁通，充分发挥分块的灵活性。]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「分块系列」数列分块入门6 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fblock-VI-solution%2F</url>
    <content type="text"><![CDATA[数列分块入门6题意概括单点插入，单点询问。 写在前面分块的小技巧可多啦 O(∩_∩)O哈哈~ 正题用一个vector来记录每个块的元素。vector提供了强大的insert函数，插入某个元素只要写一点点就可以啦O(∩_∩)O，就是一个一个枚举块，直到找到插入位置属于哪个块，然后insert一下就OK。不过，如果插入元素集中于一个块的话就尴尬了QAQ复杂度飙升。所以我们要对块进行重新分配。我采用若一个块元素多于10倍原有元素个数时就重排~（由于数据随机分配，不进行重排其实也不会TLE，甚至直接1个vector插入也能过 QAQ 数据水？？？建议还是写下重排，因为完全可以卡掉不重排的） 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 100005int n, d, nn;int a[MAXN&lt;&lt;1];vector&lt;int&gt; v[1005];inline void mer()&#123;//把所有元素还原到a数组中 n = 0; for ( int i = 1; i &lt;= d + 1; ++i )&#123; if ( v[i].empty() ) break; for ( int j = 0; j &lt; v[i].size(); ++j ) a[++n] = v[i][j]; v[i].clear(); &#125;&#125;inline void div()&#123;//把a数组元素分配到各个块中 d = sqrt(n); for ( int i = 1; i &lt;= n; ++i ) v[( i - 1 ) / d + 1].push_back(a[i]);&#125;inline int Get( int wh )&#123; for ( int i = 1; i &lt;= d + 1; ++i )&#123; if ( wh &gt; v[i].size() ) wh -= v[i].size(); else return v[i][wh - 1]; &#125;&#125;inline void Ins( int wh, int x )&#123; for ( int i = 1; i &lt;= d + 1; ++i )&#123; if ( wh &gt; v[i].size() ) wh -= v[i].size(); else&#123; v[i].insert( v[i].begin() + wh - 1, x );//插入~ if ( v[i].size() &gt; 10 * d ) mer(), div();//重排 return; &#125; &#125;&#125;int main()&#123; scanf( "%d", &amp;n ); for ( int i = 1; i &lt;= n; ++i ) scanf( "%d", &amp;a[i] ); div(); nn = n; for ( int i = 1; i &lt;= nn; ++i )&#123; int opt, l, r, c; scanf( "%d%d%d%d", &amp;opt, &amp;l, &amp;r, &amp;c ); if ( opt ) printf( "%d\n", Get(r) ); else Ins( l, r ); &#125; return 0;&#125; 总结有些分块的技巧性很强，平时注意归纳(*^▽^*)]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「分块系列」数列分块入门5 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fblock-V-solution%2F</url>
    <content type="text"><![CDATA[数列分块入门5题意概括区间开方，区间求和。 写在前面这题需要更好地利用暴力QAQ 不暴力这题简直没法做~ 还有注意下，由于不是同一时段的代码，所属分块之后都写成b而不是p了QAQ 希望谅解。 正题因为每个数都不超过2 ^ 31 - 1,所以一个数开方5次，肯定会为1。 我们可以对这一性质加以利用 好好暴力QAQ。 我们用一个数组v来记录当前块是否全为1,s记录这一块的和。当修改时，若该块全为1，就用不着更新了;如果不是，就暴力一次，直接把这块全开方了(别忘了更新s)，顺便判断是否全为1，对v进行更新。对于两边不完整块，还是老样子——暴力QAQ。 时间复杂度分析我们把修改完整块和不完整块分开分析。 对于完整块，最多修改5次，因为前面分析过，修改5次肯定都为1了，所以上限为O(5n)。 对于不完整块，每次修改最多触及2次，所以上限为O(2n√n) 期间枚举完整块时间上限为O(n√n)。 最后加起来就是O(5n+3n√n) 满足复杂度要求。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 50005int a[MAXN], s[300], b[MAXN];bool v[300]; int n, d;void modify( int x, int y )&#123; if ( b[x] == b[y] )&#123; for ( int i = x; i &lt;= y; ++i )&#123; s[b[x]] -= a[i]; a[i] = sqrt(a[i]); s[b[x]] += a[i]; &#125; return; &#125; for ( int i = x; b[i] == b[x]; ++i )&#123; s[b[x]] -= a[i]; a[i] = sqrt(a[i]); s[b[x]] += a[i]; &#125;//修改不完整块 更新 s 的值 for ( int i = y; b[i] == b[y]; --i )&#123; s[b[y]] -= a[i]; a[i] = sqrt(a[i]); s[b[y]] += a[i]; &#125; for ( int i = b[x] + 1; i &lt;= b[y] - 1; ++i )&#123; if ( !v[i] )&#123;//满足全为1就别做了 不满足才做 v[i] = 1; for ( int j = d * ( i - 1 ) + 1; b[j] == i; ++j )&#123; s[i] -= a[j]; a[j] = sqrt(a[j]); s[i] += a[j]; if ( a[j] &gt; 1 ) v[i] = 0;//还是不满足QAQ &#125; &#125; &#125;&#125;int Get( int x, int y )&#123;//很好理解 不解释了 int ans(0); if ( b[x] == b[y] )&#123; for ( int i = x; i &lt;= y; ++i ) ans += a[i]; return ans; &#125; for ( int i = x; b[i] == b[x]; ++i ) ans += a[i]; for ( int i = y; b[i] == b[y]; --i ) ans += a[i]; for ( int i = b[x] + 1; i &lt;= b[y] - 1; ++i ) ans += s[i]; return ans;&#125;int main()&#123; scanf( "%d", &amp;n ); d = sqrt(n); for ( int i = 1; i &lt;= n; ++i )&#123; scanf( "%d", &amp;a[i] ); b[i] = ( i - 1 ) / d + 1; s[b[i]] += a[i]; &#125; for ( int i = 1; i &lt;= n; ++i )&#123; int opt, l, r, c; scanf( "%d%d%d%d", &amp;opt, &amp;l, &amp;r, &amp;c ); if ( opt ) printf( "%d\n", Get( l, r ) ); else modify( l, r ); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「分块系列」数列分块入门4 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fblock-IV-solution%2F</url>
    <content type="text"><![CDATA[数列分块入门4题意概括区间加法，区间求和。 写在前面这题。。。也与分块1如出一辙。。。 正题当有修改时，对于完整的块，直接维护一个数组v记录整个块加过的数(每块共同的加数)与s记录每个块的和(不算共同加数)，不完整的就直接暴力在原数组a上直接加，并且别忘了给s也加上。询问时，对于不完整的块，直接暴力加(别忘了共同加数)，完整的块对于每个区间ans加上 (区间和 + 共同加数 * 大小)就可以了。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;cmath&gt;using namespace std;#define MAXN 50005#define LL long longint n, t, m;LL a[MAXN], p[MAXN], v[500], s[500];LL opt, l, r, c;void Add( int l, int r, int c )&#123; if ( p[l] == p[r] )&#123; for ( int i = l; i &lt;= r; ++i ) a[i] += c, s[p[i]] += c; return; &#125; for ( int i = l; p[l] == p[i]; ++i ) a[i] += c, s[p[i]] += c; for ( int i = r; p[r] == p[i]; --i ) a[i] += c, s[p[i]] += c; for ( int i = p[l] + 1; i &lt; p[r]; ++i ) v[i] += c;&#125;LL query( int l, int r, LL c )&#123; if ( p[l] == p[r] )&#123; LL ans(0); for ( int i = l; i &lt;= r; ++i ) ans += ( a[i] + v[p[i]] ) % c, ans %= c; return ans; &#125; int ans(0); for ( int i = l; p[i] == p[l]; ++i ) ans += ( a[i] + v[p[i]] ) % c, ans %= c; for ( int i = r; p[i] == p[r]; --i ) ans += ( a[i] + v[p[i]] ) % c, ans %= c; for ( int i = p[l] + 1; i &lt; p[r]; ++i ) ans += ( s[i] + v[i] * m ) % c, ans %= c; return ans % c;&#125;int main()&#123; scanf( "%d", &amp;n ); m = (int)sqrt(n); for ( int i = 1; i &lt;= n; ++i ) scanf( "%lld", &amp;a[i] ), p[i] = ( i - 1 ) / m + 1, s[p[i]] += a[i]; for ( int i = 1; i &lt;= n; ++i )&#123; scanf( "%d%lld%lld%lld", &amp;opt, &amp;l, &amp;r, &amp;c ); if ( opt ) printf( "%lld\n", query( l, r, c + 1 ) ); else Add( l, r, c ); &#125;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「分块系列」数列分块入门7 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fblock-VII-solution%2F</url>
    <content type="text"><![CDATA[数列分块入门7题意概括区间乘法，区间加法，单点询问。 写在前面写过线段树模板2的童鞋应该很清楚了吧QAQ 由于1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# 正题我们把一个数表示为 a[i] × tg2[b[i]] + tg1[b[i]]。tg2表示乘法标记，tg1表示加法标记。对于不完整的块，直接 a[i] = a[i] × tg2[b[i]] + tg1[b[i]] 将这个块的所有元素都还原，也就是将该块的标记下传。对于完整的块​ 乘法：( a[i] × tg2[b[i]] + tg1[b[i]] ) × c = a[i] × (tg2[b[i]] × c) + (tg1[b[i]] × c) 也就是说，将tg1、tg2都乘c就可以了​ 加法：( a[i] × tg2[b[i]] + tg1[b[i]] ) + c = a[i] × tg2[b[i]] + (tg1[b[i]] + c) 也就是将tg1加上c 然后就很清楚了ヾ(ｏ･ω･)ﾉ# 代码```cpp#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 100005#define mod(x) (1ll * x) % 10007int n, d;int a[MAXN], b[MAXN], tg1[500], tg2[500];inline void Push( int wh )&#123; for ( int i = ( wh - 1 ) * d + 1; i &lt;= wh * d; ++i ) a[i] = mod( 1ll * a[i] * tg2[wh] + tg1[wh] ); tg1[wh] = 0; tg2[wh] = 1;&#125;void Add( int l, int r, int c )&#123; if ( b[l] == b[r] )&#123; Push(b[l]); for ( int i = l; i &lt;= r; ++i ) a[i] = mod( a[i] + c ); return; &#125; Push(b[l]); for ( int i = l; b[i] == b[l]; ++i ) a[i] = mod( a[i] + c ); Push(b[r]); for ( int i = r; b[i] == b[r]; --i ) a[i] = mod( a[i] + c ); for ( int i = b[l] + 1; i &lt;= b[r] - 1; ++i ) tg1[i] = mod( tg1[i] + c );&#125;void Mul( int l, int r, int c )&#123; if ( b[l] == b[r] )&#123; Push(b[l]); for ( int i = l; i &lt;= r; ++i ) a[i] = mod( a[i] * c ); return; &#125; Push(b[l]); for ( int i = l; b[i] == b[l]; ++i ) a[i] = mod( a[i] * c ); Push(b[r]); for ( int i = r; b[i] == b[r]; --i ) a[i] = mod( a[i] * c ); for ( int i = b[l] + 1; i &lt;= b[r] - 1; ++i ) tg1[i] = mod( tg1[i] * c ), tg2[i] = mod( tg2[i] * c );&#125;int main()&#123; scanf( &quot;%d&quot;, &amp;n ); d = sqrt(n); for ( int i = 1; i &lt;= n; ++i )&#123; scanf( &quot;%d&quot;, &amp;a[i] ); b[i] = ( i - 1 ) / d + 1; &#125; for ( int i = 1; i &lt;= b[n]; ++i ) tg1[i] = 0, tg2[i] = 1; for ( int i = 1; i &lt;= n; ++i )&#123; int opt, l, r, c; scanf( &quot;%d%d%d%d&quot;, &amp;opt, &amp;l, &amp;r, &amp;c ); if ( opt == 0 ) Add( l, r, c ); if ( opt == 1 ) Mul( l, r, c ); if ( opt == 2 ) printf( &quot;%d\n&quot;, mod(a[r] * tg2[b[r]] + tg1[b[r]]) ); &#125; return 0;&#125; 总结有多种操作时可以借助代数来分析~(＾ω＾)]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「分块系列」数列分块入门8 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fblock-VIII-solution%2F</url>
    <content type="text"><![CDATA[数列分块入门8题意概括区间修改，区间计数。 写在前面感叹~ 分块真是玄之又玄|(￣0￣) 正题跟分块7类似的是，这题也运用还原。 v数组用来记录一个分块是否都为一个数，f数组来记录如果都为一个数，那么这个数是什么(实际上可以用只一个数组来记录QAQ) 查询时，对于都为一个数的块，直接加上(如果这个数是c)，顺便把f改为c，不是的话暴力计数，顺便把v改为1，f改为c。 不完整的块稍微麻烦一点，如果v为1的话先还原（都变成f的值），然后再修改~ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 100005int n, d;int a[MAXN], b[MAXN], f[500];bool v[500];int FF( int x )&#123;//取出x位置的值 return v[b[x]] ? f[b[x]] : a[x];&#125;int fun( int l, int r, int c )&#123;//计数&amp;修改 int ans(0); for ( int i = l; i &lt;= r &amp;&amp; i &lt;= n; ++i ) ans += FF(i) == c, a[i] = c; return ans;&#125;int Get( int l, int r, int c )&#123; int ans(0); if ( b[l] == b[r] )&#123; if ( v[b[l]] &amp;&amp; f[b[l]] == c ) return r - l + 1; if ( v[b[l]] )&#123; fun( ( b[l] - 1 ) * d + 1, l - 1, f[b[l]] ); fun( r + 1, b[l] * d, f[b[l]] ); &#125; ans = fun( l, r, c ); v[b[l]] = 0; return ans; &#125; if ( v[b[l]] ) fun( ( b[l] - 1 ) * d + 1, l - 1, f[b[l]] ); ans += fun( l, b[l] * d, c ); v[b[l]] = 0; if ( v[b[r]] ) fun( r + 1, min( b[r] * d, n ), f[b[r]] ); ans += fun( ( b[r] - 1 ) * d + 1, r, c ); v[b[r]] = 0; for ( int i = b[l] + 1; i &lt;= b[r] - 1; ++i )&#123; if ( !v[i] )&#123; for ( int j = ( i - 1 ) * d + 1; b[j] == i; ++j ) ans += a[j] == c, a[j] = c; v[i] = 1; f[i] = c; &#125; else&#123; if ( f[i] == c ) ans += d; else f[i] = c; &#125; &#125; return ans;&#125;int main()&#123; scanf( "%d", &amp;n ); d = (int)sqrt(n); for ( int i = 1; i &lt;= n; ++i )&#123; scanf( "%d", &amp;a[i] ); b[i] = ( i - 1 ) / d + 1; &#125; for ( int i = 1; i &lt;= n; ++i )&#123; int l, r, c; scanf( "%d%d%d", &amp;l ,&amp;r, &amp;c ); printf( "%d\n", Get( l, r, c ) ); &#125; return 0;&#125; 总结分块大法好！$^分_块\le^灵_活的暴力\le^骗_分大法$]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「分块系列」数列分块入门9 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fblock-IX-solution%2F</url>
    <content type="text"><![CDATA[数列分块入门9题意概括静态，区间求众数。 写在前面还记得分块1就提到的关于块的大小有时要通过计算么？？在这里就得到了体现！ 正题为了方便起见，我们设把数列分成K块~ 这道题很值得思考。 先离散化~ 然后记录位置~ 我们可以考虑，对于L ~ R之间的众数只有可能是以下三种情况： b[L]块中L之后的部分 b[R]块中R之前的部分 b[L] + 1块到b[R] - 1块的众数 第三条可以预处理出。 然后对于每次询问，直接枚举上述三种情况即可。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 50005int n, m, T;int a[MAXN], b[MAXN], c[MAXN];int d, f[2000][2000];int s[MAXN];vector&lt;int&gt; p[MAXN];int Count( int l, int r, int x )&#123; return upper_bound( p[x].begin(), p[x].end(), r ) - lower_bound( p[x].begin(), p[x].end(), l );&#125;int Get( int l, int r )&#123; if ( b[l] == b[r] )&#123; int ans1(0), ans2(0); for ( int i = l; i &lt;= r; ++i )&#123; int t(Count( l, r, a[i] )); if ( t &gt; ans2 ) ans1 = a[i], ans2 = t; if ( t == ans2 ) ans1 = min( ans1, a[i] ); &#125; return ans1; &#125; int ans1(f[b[l] + 1][b[r] - 1]), ans2(Count( l, r, ans1 )); for ( int i = l; b[l] == b[i]; ++i )&#123; int t(Count( l, r, a[i] )); if ( t == ans2 ) ans1 = min( ans1, a[i] ); if ( t &gt; ans2 ) ans1 = a[i], ans2 = t; &#125; for ( int i = r; b[r] == b[i]; --i )&#123; int t(Count( l, r, a[i] )); if ( t == ans2 ) ans1 = min( ans1, a[i] ); if ( t &gt; ans2 ) ans1 = a[i], ans2 = t; &#125; return ans1;&#125;int main()&#123; scanf( "%d", &amp;n ); d = 0; while( ( 1 &lt;&lt; d ) &lt;= n ) d++; d--; d = (int)( n / sqrt( 2 * n * d ) ); for ( int i = 1; i &lt;= n; ++i )&#123; scanf( "%d", &amp;a[i] ); c[i] = a[i]; b[i] = ( i - 1 ) / d + 1; &#125; sort( c + 1, c + n + 1 );//离散化 m = unique( c + 1, c + n + 1 ) - c - 1; for ( int i = 1; i &lt;= n; ++i ) a[i] = lower_bound( c + 1, c + m + 1, a[i] ) - c; for ( int i = 1; i &lt;= n; ++i ) p[a[i]].push_back(i);//每个元素都记录位置 for ( int i = 1; i &lt;= b[n]; ++i )&#123; memset( s, 0, sizeof s ); int ans1(0), ans2(0); for ( int j = ( i - 1 ) * d + 1; j &lt;= n; ++j )&#123; s[a[j]]++; if ( s[a[j]] == ans2 ) ans1 = min( ans1, a[j] ); if ( s[a[j]] &gt; ans2 ) ans1 = a[j], ans2 = s[a[j]]; if ( b[j + 1] != b[j] ) f[i][b[j]] = ans1; &#125; &#125; int x(0); for ( int T = 1; T &lt;= n; ++T )&#123; int l, r; scanf( "%d%d", &amp;l, &amp;r ); int t(min( l, r )); r = max( l, r ); l = t; printf( "%d\n", x = c[Get( l, r )] ); &#125; return 0;&#125; 总结分块大法入门1~9就这么结束惹，但分块这个博大精深的暴力远远不止这些, 还有待大家去探索(((((ી(･◡･)ʃ)))))]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「分块系列」「洛谷P4168 [Violet]」蒲公英 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fluogu4168-solution%2F</url>
    <content type="text"><![CDATA[蒲公英Description我们把所有的蒲公英看成一个长度为$n$的序列($a_1,a_2,…a_n$)，其中$a_i$为一个正整数，表示第i棵蒲公英的种类的编号。每次询问一个区间$[l,r]$，你需要回答区间里出现次数最多的是哪种蒲公英，如果有若干种蒲公英出现次数相同，则输出种类编号最小的那个。注意，你的算法必须是在线的。 Input Data第一行两整数$n,m$，表示有$n$棵蒲公英，mm次询问。接下来一行$n$个空格分隔的整数$a_i$，表示蒲公英的种类。接下来$m$行，每行两个整数$l_0,r_0$。令上次的查询结果为$x$（如果是第一次查询，则$x=0$）。令$l=(l_0+x-1) mod (n+1), r=(r_0+x-1) mod (n+1)$ Output Data输出$m$行，每行一个整数，表示每次查询的结果。 Input / Output Sample123456 3 1 2 3 2 1 2 1 5 3 6 1 5 1231 2 1 Data Limit$n \le 40000,m \le 50000,1 \le a_i \le 10^9n≤40000,m≤50000,1≤ai≤10^9$ Problem Source$BZOJ2724$算法竞赛进阶指南$P218-219$ 这道题和$数列分块入门9$蜜汁相似QAQ。 请自行参照我的$数列分块入门9题解$ 这里仅放上代码QAQ—— 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 40005int n, m, T;int a[MAXN], b[MAXN], c[MAXN];int d, f[2000][2000];int s[MAXN];vector&lt;int&gt; p[MAXN];int Count( int l, int r, int x )&#123; return upper_bound( p[x].begin(), p[x].end(), r ) - lower_bound( p[x].begin(), p[x].end(), l );&#125;int Get( int l, int r )&#123; if ( b[l] == b[r] )&#123; int ans1(0), ans2(0); for ( int i = l; i &lt;= r; ++i )&#123; int t(Count( l, r, a[i] )); if ( t &gt; ans2 ) ans1 = a[i], ans2 = t; if ( t == ans2 ) ans1 = min( ans1, a[i] ); &#125; return ans1; &#125; int ans1(f[b[l] + 1][b[r] - 1]), ans2(Count( l, r, ans1 )); for ( int i = l; b[l] == b[i]; ++i )&#123; int t(Count( l, r, a[i] )); if ( t &gt; ans2 ) ans1 = a[i], ans2 = t; if ( t == ans2 ) ans1 = min( ans1, a[i] ); &#125; for ( int i = r; b[r] == b[i]; --i )&#123; int t(Count( l, r, a[i] )); if ( t &gt; ans2 ) ans1 = a[i], ans2 = t; if ( t == ans2 ) ans1 = min( ans1, a[i] ); &#125; return ans1;&#125;int main()&#123; scanf( "%d%d", &amp;n, &amp;T ); d = 0; while( ( 1 &lt;&lt; d ) &lt;= n ) d++; d = (int)( n / sqrt( 2 * T * d ) ); for ( int i = 1; i &lt;= n; ++i )&#123; scanf( "%d", &amp;a[i] ); c[i] = a[i]; b[i] = ( i - 1 ) / d + 1; &#125; sort( c + 1, c + n + 1 ); m = unique( c + 1, c + n + 1 ) - c - 1; for ( int i = 1; i &lt;= n; ++i ) a[i] = lower_bound( c + 1, c + m + 1, a[i] ) - c; for ( int i = 1; i &lt;= n; ++i ) p[a[i]].push_back(i); for ( int i = 1; i &lt;= b[n]; ++i )&#123; memset( s, 0, sizeof s ); int ans1(0), ans2(0); for ( int j = ( i - 1 ) * d + 1; j &lt;= n; ++j )&#123; s[a[j]]++; if ( s[a[j]] == ans2 ) ans1 = min( ans1, a[j] ); if ( s[a[j]] &gt; ans2 ) ans1 = a[j], ans2 = s[a[j]]; if ( b[j + 1] != b[j] ) f[i][b[j]] = ans1; &#125; &#125; int x(0); while( T-- )&#123; int l, r; scanf( "%d%d", &amp;l, &amp;r ); l = ( l + x - 1 ) % n + 1; r = ( r + x - 1 ) % n + 1; int t(min( l, r )); r = max( l, r ); l = t; printf( "%d\n", x = c[Get( l, r )] ); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「分块系列」公主的朋友 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fblock-friends-of-princes-solution%2F</url>
    <content type="text"><![CDATA[公主的朋友DescriptionProblem由于$Wulala$在上个问题中的精彩表现，公主认为$Wulala$是一个很棒的人，就把$Wulala$留在 了$X$国。这时正好公主的一位传教士朋友来拜访公主，于是想找$wulala$帮忙。 $X$国如同一条直线，其中有$n$个城市,从东向西分别编号为$1$到$n$。而他的国家中有$m$种宗教， 每个城市一定会有一种信仰的宗教。 有时候有些城市为了获得更多的认可，会派出信仰本城市宗教的传教士前往其他国家。 $X$国的传教士都十分厉害，只要是他途经的地方都会改信他所传播的宗教。 传教士们在路上碰到自己宗教的城市自然就不用传教了，所以每 一个传教士在旅行前都会计算自己可以在多少城市停下来(不包括起始的城市)。 而传教士们都是文科僧，数学是很差的，所以他希望$Wulala$能帮他计算。可$Wulala$数学也不好，但他又不想在公主面前丢脸，你能帮帮他吗？ Input Data第一行两个整数$n$，$m$；第二行$n$个整数第$i$个整数代表第ii个城市信仰的宗教；第三行一个整数 $T$ 代表传教士的个数；接下来 $T$ 行每行两个整数 $x$，$y$代表 $x$ 城向 $y$ 城派遣了一个传教士(保证 $x &lt; y$) Output Data输出$T$行，第$i$行代表第$i$个传教士询问的答案 Input / Output Sample123452 21 221 21 2 1201 Data Limit对于 30%的数据 $n \le 100000, m \le 10, T \le100$;对于 60%的数据 $n \le 100000, m \le 10, T \le 100000$;对于 100%的数据 $n \le 100000, m \le 300, T \le 100000$。 Problem Source湖南师大附中模拟赛 这又和$数列分块入门8$蜜汁相似QAQ $^双_经$ $^倍_验 $泛滥成灾啊 这里也不多提，参照$数列分块入门8$ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 100005int n, m, d, T;int a[MAXN], b[MAXN], f[500];bool v[500];int FF( int x )&#123; return v[b[x]] ? f[b[x]] : a[x];&#125;int fun( int l, int r, int c )&#123; int ans(0); for ( int i = l; i &lt;= r &amp;&amp; i &lt;= n; ++i ) ans += FF(i) == c, a[i] = c; return ans;&#125;int Get( int l, int r, int c )&#123; int ans(0); if ( b[l] == b[r] )&#123; if ( v[b[l]] &amp;&amp; f[b[l]] == c ) return r - l + 1; if ( v[b[l]] )&#123; fun( ( b[l] - 1 ) * d + 1, l - 1, f[b[l]] ); fun( r + 1, b[l] * d, f[b[l]] ); &#125; ans = fun( l, r, c ); v[b[l]] = 0; return ans; &#125; if ( v[b[l]] ) fun( ( b[l] - 1 ) * d + 1, l - 1, f[b[l]] ); ans += fun( l, b[l] * d, c ); v[b[l]] = 0; if ( v[b[r]] ) fun( r + 1, min( b[r] * d, n ), f[b[r]] ); ans += fun( ( b[r] - 1 ) * d + 1, r, c ); v[b[r]] = 0; for ( int i = b[l] + 1; i &lt;= b[r] - 1; ++i )&#123; if ( !v[i] )&#123; for ( int j = ( i - 1 ) * d + 1; b[j] == i; ++j ) ans += a[j] == c, a[j] = c; v[i] = 1; f[i] = c; &#125; else&#123; if ( f[i] == c ) ans += d; else f[i] = c; &#125; &#125; return ans;&#125;int main()&#123; scanf( "%d%d", &amp;n, &amp;m ); d = (int)sqrt(n); for ( int i = 1; i &lt;= n; ++i )&#123; scanf( "%d", &amp;a[i] ); b[i] = ( i - 1 ) / d + 1; &#125; scanf( "%d", &amp;T ); while ( T-- )&#123; int l, r; scanf( "%d%d", &amp;l ,&amp;r ); printf( "%d\n", Get( l, r, FF(l) ) - 1 ); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「2018-12-02模拟赛」T1 最短路 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2F2018-12-02-contest-T1-solution%2F</url>
    <content type="text"><![CDATA[1.最短路(short.pas/cpp/in/out)问题描述：小 C 终于被小 X 感动了，于是决定与他看电影，然而小 X 距离电影院非常远，现在假设每条道路需要花费小 X 的时间为 1，由于有数以万计的好朋友沿路祝贺，导致小 X 在通过某些路不得不耗费 1 的时间来和他们聊天，尽管他希望尽早见到小 C，所以他希望找到一条最快时间到达电影院的路。一开始小 X 在 1 号点，共有 N 个点，M 条路，电影院为 T 号点。 输入：第一行 3 个正整数，分别为 n，m 和 t。以下 m 行，每行 3 个数，表示连接的编号以及权值。（注意，可能会有重边） 输出：一行一个数，表示 1 到 t 的最短路。 样例输入：1234567891011121310 12 63 9 26 9 26 2 13 1 11 9 22 8 27 10 17 2 110 0 18 1 11 5 23 7 2 样例输出：14 数据范围：对于 30%的数据：n&lt;=10，m&lt;=20；对于 60%的数据：n&lt;=1 000，m&lt;=20 000；对于 100%的数据：n&lt;=5 000 000，m&lt;=10 000 000。 时空限制注意下这道题时间限制:$2.5ms$ 空间限制:$1024MB$ 好大呀 思路把因为边权只有可能是1和2，所以我们可以把边权为2的点拆成两条边，然后广搜~ 最大的测试点还是达到了1.3+s QAQ 无能为力嘤嘤嘤~ 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 10000005#define MAXM 20000005#define INF 0x7f7f7f7fint N, M, T;int hd[MAXN], to[MAXM &lt;&lt; 1], nxt[MAXM &lt;&lt; 1], tot, dis[MAXN];int Q[MAXN], ph(1), pt(0);int x, y, z;char B[150&lt;&lt;20], *S = B;int read()&#123; int ans(0); while( !isdigit(*S) ) S++; while( isdigit(*S) ) ans = ans * 10 + ( (*S) ^ '0' ), S++; return ans; &#125;void Add( int x, int y )&#123; nxt[++tot] = hd[x]; to[tot] = y; hd[x] = tot; nxt[++tot] = hd[y]; to[tot] = x; hd[y] = tot;&#125;int main()&#123; freopen( "short.in", "r", stdin ); freopen( "short.out", "w", stdout ); fread( B, 1, 150 &lt;&lt; 20, stdin ); N = read(); M = read(); T = read(); for ( int i = 1; i &lt;= M; ++i )&#123; x = read(); y = read(); z = read(); if ( z &amp; 1 ) Add( x, y ); else Add( x, ++N ), Add( y, N ); &#125; Q[++pt] = 1; memset( dis, -1, sizeof dis ); dis[1] = 0; while( pt &gt;= ph )&#123; int t(Q[ph++]); for ( int i = hd[t]; i; i = nxt[i] ) if ( dis[to[i]] &lt; 0 )&#123; dis[to[i]] = dis[t] + 1, Q[++pt] = to[i]; if ( t == T ) break; &#125; &#125; printf( "%d\n", dis[T] ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>最短路</tag>
        <tag>广搜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「2018-12-02模拟赛」T2 种树 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2F2018-12-02-contest-T2-solution%2F</url>
    <content type="text"><![CDATA[2.种树(tree.pas/cpp/in/out)问题描述：Fanvree 很聪明，解决难题时他总会把问题简单化。例如，他就整天喜欢把图转化为树。但是他不会缩环，那他怎么转化呢？ 这是一个有n 个点 m 条双向边的图，Fanvree 会选定一个节点，然后删掉这个节点和这个点连出去的边，如果变成了一棵树，那么这个节点便是可行的，什么是树呢？树也即无简单环的无向连通图。告诉 Fanvree 可能的节点是什么。 输入：第一行两个正整数 n 和 m，表示有 n 个点 m 条边，保证 n≥2。接下来 m 行，每行两个整数 v,u，表示 v 和 u 之间有一条无向边 1≤v,u≤n，保证没有重边和自环。 输出：第一行一个正整数 ns，表示这个图中有 ns 个结点可选。接下来一行，共 ns 个整数，每个整数表示一个可选结点的编号。请按编号从小到大的顺序输出。数据保证图中至少存在一个可选的结点。 样例输入：12345676 61 21 32 42 54 65 6 样例输出：1234 5 6 数据范围：对于 40%的数据：n，m&lt;=1000；另外存在 10%的数据：m=n-1；另外存在 20%的数据：m=n；对于 100%的数据：n，m&lt;=100000。 写在前面只要掌握一个小定理，就显得十分简单（啊呸，叫我这种刚刚普及退役$Tarjan$都不会的蒟蒻找割点QAQ） 当且仅当一个有N个节点的连通图有N - 1条边，这是一棵树。 思路输入时，记录每个点相连的边数s。 如果 M - s[P] != N - 2，该图不满足前面提到的定理，删去P不是一棵树。 如果该点为割点，那么删去P将不连通。 所以预处理出割点、每个点相连的边数即可。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;#define open(s) freopen( s".in", "r", stdin ), freopen( s".out", "w", stdout );#define MAXN 100005#define MAXM 100005int n, m, ans;int hd[MAXN], nxt[MAXM &lt;&lt; 1], to[MAXM &lt;&lt; 1], s[MAXN], tot(1);void Add( int x, int y )&#123; nxt[++tot] = hd[x]; to[tot] = y; hd[x] = tot; &#125;int dfn[MAXN], low[MAXN], num, root;bool cut[MAXN];void Tarjan( int x )&#123; //找割点—— dfn[x] = low[x] = ++num; int cnt(0); for ( int i = hd[x]; i; i = nxt[i] )&#123; if ( !dfn[to[i]] )&#123; Tarjan(to[i]); low[x] = min( low[x], low[to[i]] ); if ( dfn[x] &lt;= low[to[i]] ) cnt++; &#125; else low[x] = min( low[x], dfn[to[i]] ); &#125; if ( cnt &amp;&amp; ( x != root || cnt &gt; 1 ) ) cut[x] = 1;&#125;int main()&#123; open("tree"); scanf( "%d%d", &amp;n, &amp;m ); for ( int i = 1; i &lt;= m; ++i )&#123; int x, y; scanf( "%d%d", &amp;x, &amp;y ); Add( x, y ), Add( y, x ); s[x]++; s[y]++; &#125; root = 1; Tarjan(1); //别忘了 如果图是由一棵树和一个孤零零的点组成。。。 if ( num == 1 )&#123; //不连通的话，如果找到的点只有1个(节点1)，那只有可能节点1是满足要求的点 root = 2; Tarjan( 2 ); if ( num == n &amp;&amp; m == n - 2 ) printf( "1\n1\n" ); return 0; &#125; if ( num == n - 1 )&#123; //如果找到的点有n - 1个，那么在非节点1的节点中有一个还满足题要求。。。 if ( m == n - 2 )&#123; printf( "1\n" ); for ( int i = 2; i &lt;= n; ++i ) if ( !dfn[i] )&#123; printf( "%d\n", i ); break; &#125; &#125; return 0; &#125; if ( num != n )&#123; printf( "0\n0\n" ); return 0; &#125; //如果有多个点不能到达，咋删都成不了棵树。。。 for ( int i = 1; i &lt;= n; ++i ) if ( m - s[i] == n - 2 &amp;&amp; !cut[i] ) ans++; //边数符合、不是割点，它一定是棵树！ printf( "%d\n", ans ); for ( int i = 1; i &lt;= n; ++i ) if ( m - s[i] == n - 2 &amp;&amp; !cut[i] ) printf( "%d ", i ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>割点</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「2018-12-02模拟赛」T3 约束排列 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2F2018-12-02-contest-T3-solution%2F</url>
    <content type="text"><![CDATA[3.约束排列(place.pas/cpp/in/out)问题描述：给出 n 个互不相同的小写字母，表示出现的字符类型，以及 k 个约束关系： …..，表示 ai 必须出现在 bi 前面(ai,bi 不会超出所给字符类型的范围，且ai!=bi)。请按照字典序输出所有满足约束条件的序列。如:n=3，字符类型为：x y zk=1，约束条件为：x z，表示 x 必须出现在 z 的前面。所有满足约束条件的排列有：xyzxzyyxz 输入：第 1 行，2 个整数 n 和 k。第 2 行，n 个空格隔开的字符。接下来 k 行，每行二个字符 ai 和 bi（表示约束关系），数据保证不会出现矛盾的关系。 输出：若干行，每行 n 个字符（字符之间没有空格），表示排列的结果。 样例输入：1233 1x y zx z 样例输出：123xyzxzyyxz 数据范围：对于 100%的数据：1&lt;n&lt;9，1≤k≤8。 思路数据真的小，直接全排列，枚举即可。 对于检查是否满足K个约束，直接枚举，对于每个约束，如果先出现”应该先出现的”那就满足要求，如果先出现“应该后出现的”，那就不满足，标记之后再退出。 满足所有约束的就输出。 next_permutation( a + 1, a + n + 1 )：转为下一个全排列，没有了就返回0 （真搞不懂这种题目为嘛放T3？？？逗我么？？估计普及-。。。） 代码123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;int N, K;char s[20];char a[20], b[20];inline char Get()&#123; char ans; while( ( ans = getchar() ) &lt; 'a' || ans &gt; 'z' ); return ans;&#125;int main()&#123; freopen( "place.in", "r", stdin ); freopen( "place.out", "w", stdout ); scanf( "%d%d", &amp;N, &amp;K ); for ( int i = 1; i &lt;= N; ++i ) s[i] = Get(); for ( int i = 1; i &lt;= K; ++i ) a[i] = Get(), b[i] = Get(); sort( s + 1, s + N + 1 ); s[N + 1] = '\0'; do&#123; bool flg(1); for ( int i = 1; i &lt;= K; ++i ) for ( int j = 1; j &lt;= N; ++j )&#123; if ( s[j] == a[i] ) break; if ( s[j] == b[i] )&#123; flg = 0; break; &#125; &#125; if ( flg ) printf( "%s\n", s + 1 ); &#125;while( next_permutation( s + 1, s + N + 1 ) ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Vijos 1283」「OIBH杯NOIP2006第二次模拟赛」佳佳的魔杖]]></title>
    <url>%2F2019%2F01%2F23%2Fvijos1283-solution%2F</url>
    <content type="text"><![CDATA[佳佳的魔杖背景配制成功了珍贵的0号药水，MM的病治好了。轻松下来的佳佳意外的得到了一个好东西……那就是——一种非常珍贵的树枝。这些树枝可以用来做优质的魔杖！当然了，不能只做自己的，至少还要考虑到MM的对吧。选择怎样的切割方式来制作魔杖非常重要，关键问题是——一把魔杖既不能太长、又不能太短，且制作出来的魔杖不能有冲突…… 描述佳佳得到的这些树枝在属性上完全相同。每一个树枝都有n段（用1~n编号），给定了每段的长度L[i]和每段的魔力值M[i]。单独的一段是不可以从中间切开的，你可以做的就是选择一段或连续的几段，把它们作为一个整体切下来，再用来制作魔杖。但是一根魔杖的长度不能太长——不能大于给定的值hi；也不能太短——不能小于给定的值lo。 魔杖有一个奇怪的要求：如果某一根魔杖的制作材料是另一根魔杖的一部分，则这两根魔杖之间将发生冲突。比如说树枝有三段，从左到右的长度分别为4、 1、3，佳佳需要长度为4到5之间的魔杖。佳佳可以用一根树枝的前两段做出一个长度为5的魔杖，用一根树枝的后两段做出长度为4的魔杖；但他决不能用一根树枝的前两段做了魔杖后再单独使用另一根树枝的第一段做成魔杖，因为前者包含了后者的所有成分，这会导致冲突。 我们假设佳佳可以得到任意多这样的树枝。佳佳需要制作出若干个互不冲突的魔杖，使所有魔杖的魔力值之和最大。（魔杖的长度就是组成它的那些段的长度的总和，魔力值亦然）。 输入格式第一行有三个用空格隔开的正整数，分别表示n、lo、hi。 第二行的n个用空格隔开的正整数就是L[1]、L[2]……L[n]。 第三行的n个用空格隔开的正整数就是M[1]、M[2]……M[n]。 输入文件以一个回车/换行符结尾。 输出格式只用输出一个整数，表示能够获得的魔力值的最大值。 样例1样例输入11236 4 51 3 3 2 2 12 3 1 4 5 2 样例输出1121 限制1秒 提示取$[1 3] [3 2] [2 2 1]$做成魔杖。 得到最大权值$2+3+1+4+4+5+2=21$。 对于30%的数据，$n\le10$；对于50%的数据，$n\le100$；对于100%的数据，$n&lt;=1000，l_o\le h_i \le 2^{31}-1，L_i,M_i \le 100 000$ 来源matrix67 思路这是DP题，$f[i][j]$ 表示左端点不超过i且右端点不超过j的最优方案。 很明显转移方程之一是$f[i][j] = max( f[i - 1][j], f[i][j - 1] );$ 还有如果长度满足，可以$f[i][j] = max( f[i][j], f[i - 1][j - 1] + 得到魔力值 );$ 话不多说，上代码—— 代码123456789101112131415161718192021#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 1005#define LL long longint n, lo, hi;LL L[MAXN], M[MAXN];LL f[MAXN][MAXN];int main()&#123; scanf( "%d%d%d", &amp;n, &amp;lo, &amp;hi ); for ( int i = 1; i &lt;= n; ++i ) scanf( "%lld", &amp;L[i] ), L[i] += L[i - 1]; for ( int i = 1; i &lt;= n; ++i ) scanf( "%lld", &amp;M[i] ), M[i] += M[i - 1]; for ( int i = 1; i &lt;= n; ++i ) for ( int j = 1; j &lt;= i; ++j )&#123; f[i][j] = max( f[i - 1][j], f[i][j - 1] ); if ( L[i] - L[j - 1] &gt;= lo &amp;&amp; L[i] - L[j - 1] &lt;= hi ) f[i][j] = max( f[i][j], f[i - 1][j - 1] + M[i] - M[j - 1] ); &#125; printf( "%lld", f[n][n] ); return 0; &#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Vijos 1284」「OIBH杯NOIP2006第二次模拟赛」佳佳的魔法阵]]></title>
    <url>%2F2019%2F01%2F23%2Fvijos1284-solution%2F</url>
    <content type="text"><![CDATA[佳佳的魔法阵背景也许是为了捕捉猎物（捕捉MM？），也许是因为其它原因，总之，佳佳准备设计一个魔法阵。而设计魔法阵涉及到的最关键问题，似乎就是那些带有魔力的宝石的摆放…… 描述魔法阵是一个$n \times m$的格子（高n，宽m），$n \times m$为偶数。佳佳手中有$n \times m$个宝石（以$1 \to n \times m$编号）。佳佳从最右上角的格子开始走，从一个格子可以走到上、下、左、右4个相邻的格子，但不能走出边界。每个格子必须且仅能到过1次，这样佳佳一共走了$n \times m$个格子停止（随便停哪里）。佳佳每进入一个格子，就在该格子里放入一颗宝石。他是按顺序放的，也就是说——第i个进入的格子放入i号宝石。 如果两颗宝石的编号对$\frac{n \times m}{2}$取模的值相同，则认为这两颗宝石相互之间有微妙的影响。也就是说，我们按照宝石的编号对取$\frac{n \times m}{2}$模的值，将宝石分成$\frac{n \times m}{2}$对，其中每对都恰有两颗宝石。对于每一对宝石，设第一颗宝石在第a行第b列，另一颗宝石在第c行第d列，那么定义这2个宝石的魔力影响值为 $ k_1\times \left| a-c \right|+k_2 \times \left| b-d \right| $。 需要你求出的是，在所有合乎题意的宝石摆放方案中，所有成对的宝石间的最大魔力影响值的最小值为多少。换句话说，如果我们定义对$\frac{n \times m}{2}$取模的值为i的一对宝石的魔力影响值为$a_i$。你需要求出的就是$\max{(a_i|i=0,1,2…)}$的最小值。 输入格式只有一行用空格隔开的4个整数，分别是$n、m、k_1、k_2，n \times m \le 50，0 &lt; k_1,k_2 \le 32767$。 输出格式只需输出一个整数，即题目所要求的“所有成对的宝石间的最大魔力影响值的最小值”。 样例输入112 2 2 2 样例输出114 限制1秒 思路这是一道搜索+剪枝题。一看到数据范围($n \times m \le 50$)我便兴奋的飞起——暴搜！！！ 然而没打完代码模拟赛就结束了。。。。。。 这道题的搜索的方式要一分为二(其实还是有很多重叠部分的)，前 $ \frac{n \times m}{2}$ 一部分，剩下的一部分。 注意两个剪枝 最优化剪枝：很简单，当前最大值比ans大或者等于ans时直接return。 可行性剪枝：接下来仔细讲讲这个吧。 蓝色的点表示当前位置，红色的点表示访问过的位置。这种情况(左、右两点不能再访问而上下两点未访问)是一种不可行的情况。 为什么呢？ 仔细想一想就能明白了。 以上述情况为例，蓝色点的上方或下方必定会构成死胡同。 像这样： 具体自己再理解理解吧。 然后上代码！ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 55int n, m, k1, k2, ans(0x7f7f7f7f), nn;int a[MAXN][2];bool vis[MAXN][MAXN];int dir[][2] = &#123; 1, 0, 0, 1, -1, 0, 0, -1 &#125;;bool check( int x, int y )&#123; if ( vis[x + 1][y] &amp;&amp; vis[x - 1][y] &amp;&amp; !vis[x][y + 1] &amp;&amp; !vis[x][y - 1] ) return 0; if ( vis[x][y + 1] &amp;&amp; vis[x][y - 1] &amp;&amp; !vis[x + 1][y] &amp;&amp; !vis[x - 1][y] ) return 0; return !vis[x][y];&#125; inline int ABS( int x )&#123; return x &lt; 0 ? -x : x; &#125;inline int Get( int x, int y, int a, int b )&#123; return k1 * ABS( x - a ) + k2 * ABS( y - b );&#125; void DFS( int x, int y, int wh, int cur )&#123; if ( wh &lt;= nn ) a[wh][0] = x, a[wh][1] = y; else cur = max( cur, Get( x, y, a[wh - nn][0], a[wh - nn][1] ) ); if ( wh &gt;= n * m )&#123; ans = min( ans, cur ); return; &#125; if ( cur &gt;= ans ) return; vis[x][y] = 1; for ( int i = 0; i &lt; 4; ++i )&#123; int tx( x + dir[i][0] ), ty( y + dir[i][1] ); if ( !check( tx, ty ) ) continue; DFS( tx, ty, wh + 1, cur ); &#125; vis[x][y] = 0;&#125;int main()&#123; scanf( "%d%d%d%d", &amp;n, &amp;m, &amp;k1, &amp;k2 ); for ( int i = 0; i &lt;= n + 1; ++i ) vis[i][0] = vis[i][m + 1] = 1; for ( int i = 0; i &lt;= m + 1; ++i ) vis[0][i] = vis[n + 1][i] = 1; nn = n * m &gt;&gt; 1; DFS( 1, m, 1, 0 ); printf( "%d\n", ans ); return 0;&#125; 秀一把 $\LaTeX$ hahaha]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>深搜</tag>
        <tag>搜索剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Vijos 1285」「OIBH杯NOIP2006第二次模拟赛」佳佳的魔法药水]]></title>
    <url>%2F2019%2F01%2F23%2Fvijos1285-solution%2F</url>
    <content type="text"><![CDATA[佳佳的魔法药水背景发完了k张照片，佳佳却得到了一个坏消息：他的MM得病了！佳佳和大家一样焦急万分！治好MM的病只有一种办法，那就是传说中的0号药水……怎么样才能得到0号药水呢？你要知道佳佳的家境也不是很好，成本得足够低才行…… 描述得到一种药水有两种方法：可以按照魔法书上的指导自己配置，也可以到魔法商店里去买——那里对于每种药水都有供应，虽然有可能价格很贵。在魔法书上有很多这样的记载：1份A药水混合1份B药水就可以得到1份C药水。（至于为什么1+1=1，因为……这是魔法世界）好了，现在你知道了需要得到某种药水，还知道所有可能涉及到的药水的价格以及魔法书上所有的配置方法，现在要问的就是：1.最少花多少钱可以配制成功这种珍贵的药水；2.共有多少种不同的花费最少的方案（两种可行的配置方案如果有任何一个步骤不同则视为不同的）。假定初始时你手中并没有任何可以用的药水。 输入格式第一行有一个整数$N(N \le 1000)$，表示一共涉及到的药水总数。药水从0~N-1顺序编号，0号药水就是最终要配制的药水。 第二行有N个整数，分别表示从0~N-1顺序编号的所有药水在魔法商店的价格（都表示1份的价格）。 第三行开始，每行有3个整数A、B、C，表示1份A药水混合1份B药水就可以得到1份C药水。注意，某两种特定的药水搭配如果能配成新药水的话，那么结果是唯一的。也就是说不会出现某两行的A、B相同但C不同的情况。 输出格式输出两个用空格隔开的整数，分别表示得到0号药水的最小花费以及花费最少的方案的个数。 样例1样例输入112345710 5 6 3 2 2 31 2 04 5 13 6 2 样例输出1110 3 限制1秒 提示最优方案有3种，分别是：直接买0号药水；买4号药水、5号药水配制成1号药水，直接买2号药水，然后配制成0号药水；买4号药水、5号药水配制成1号药水，买3号药水、6号药水配制成2，然后配制成0。 思路这道题，我扪可以使用类似于最短路的方法做。 与最短路类似，我们引入蓝点、白点的概念，即确定一些药品的最佳购买方案，并用它们来优化其他药品的方案。 很明显，目前购买价格(或制取价格)最低的是不可能再优化的，因此把它的价格确定，优化它能优化的所有方案。 然后继续以这种方式确定药水的最小购买(制取)价格，最后得到的就是每个药品的最低价。 由于数据范围较小，这里不必用堆优化，直接暴力就可以了。如果实在要卡你，就使用一个堆优化就好了。 至于方案数，可以再用一个数组记录，与最短路计数差不多，只要注意运用加法原理与乘法原理，这里不再赘述。 还有注意开long long(似乎不开也可以过，保险起见还是开起来吧)。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 1005#define INF 1000000000000000000#define LL long longtypedef pair&lt;int, int&gt; pi;struct ppp&#123; int x, y, z;&#125;;ppp make( LL x, LL y, LL z )&#123; ppp t; t.x = x; t.y = y; t.z = z; return t;&#125;int N;int m[MAXN][MAXN];bool vis[MAXN];LL dis[MAXN], s[MAXN];void Dij()&#123; for ( int i = 0; i &lt; N; ++i )&#123; int t(-1); for ( int j = 0; j &lt; N; ++j ) if ( !vis[j] &amp;&amp; ( t == -1 || dis[t] &gt; dis[j] ) ) t = j; if ( t == -1 ) return; vis[t] = 1; for ( int j = 0; j &lt; N; ++j ) if ( m[t][j] &lt; N &amp;&amp; vis[t] &amp;&amp; vis[j] )&#123; if ( dis[m[t][j]] &gt; dis[t] + dis[j] )&#123; dis[m[t][j]] = dis[t] + dis[j]; s[m[t][j]] = s[t] * s[j]; &#125;else if ( dis[m[t][j]] == dis[t] + dis[j] ) s[m[t][j]] += s[t] * s[j]; &#125; &#125;&#125;int main()&#123; scanf( "%d", &amp;N ); for ( int i = 0; i &lt; N; ++i ) scanf( "%lld", &amp;dis[i] ), s[i] = 1; int x, y, z; memset( m, 0x3f, sizeof m ); while( ~scanf( "%d%d%d", &amp;x, &amp;y, &amp;z ) ) m[x][y] = m[y][x] = z; Dij(); printf( "%lld %lld\n", dis[0], s[0] ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Vijos 1282」「OIBH杯NOIP2006第二次模拟赛」佳佳的魔法照片]]></title>
    <url>%2F2019%2F01%2F23%2Fvijos1282-solution%2F</url>
    <content type="text"><![CDATA[佳佳的魔法照片背景佳佳的魔法照片(Magic Photo)：如果你看过《哈利·波特》，你就会知道魔法世界里的照片是很神奇的。也许是因为小魔法师佳佳长的太帅，很多人都找他要那种神奇的魔法照片，而且还都要佳佳和他的MM的合照。那些照片可是非常珍贵的，他到底应该把照片给谁呢？ 描述一共有n个人（以1—n编号）向佳佳要照片，而佳佳只能把照片给其中的k个人。佳佳按照与他们的关系好坏的程度给每个人赋予了一个初始权值W[i]。然后将初始权值从大到小进行排序，每人就有了一个序号D[i]（取值同样是1—n）。按照这个序号对10取模的值将这些人分为10类。也就是说定义每个人的类别序号C[i]的值为(D[i]-1) mod 10 +1，显然类别序号的取值为1—10。第i类的人将会额外得到E[i]的权值。你需要做的就是求出加上额外权值以后，最终的权值最大的k个人，并输出他们的编号。在排序中，如果两人的W[i]相同，编号小的优先。 输入格式第一行输出用空格隔开的两个整数，分别是n和k。 第二行给出了10个正整数，分别是E[1]到E[10]。 第三行给出了n个正整数，第i个数表示编号为i的人的权值W[i]。 输出格式只需输出一行用空格隔开的k个整数，分别表示最终的W[i]从高到低的人的编号。 样例1样例输入112310 101 2 3 4 5 6 7 8 9 102 4 6 8 10 12 14 16 18 20 样例输出1110 9 8 7 6 5 4 3 2 1 限制1秒 提示对于50%的数据，$n \le 200$；对于100%的数据，$n \le 50000$，$k \le 2000$，给出的所有正整数都不超过32767。 思路这题没什么好说的，就是快排。。。 STL 的 sort还是很好用的—— 如果想更快的还可以按编号分成10组归并，不过这里没有必要。 具体就不仔细讲了，看代码吧。 代码12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 50005int n, k;int E[15];int W[MAXN], D[MAXN];bool cmp( int x, int y )&#123; if ( W[x] == W[y] ) return x &lt; y; return W[x] &gt; W[y];&#125;int main()&#123;// freopen( "mphoto.in", "r", stdin );// freopen( "mphoto.out", "w", stdout ); scanf( "%d%d", &amp;n, &amp;k ); for ( int i = 1; i &lt;= 10; ++i ) scanf( "%d", &amp;E[i] ); for ( int i = 1; i &lt;= n; ++i ) scanf( "%d", &amp;W[i] ), D[i] = i; sort( D + 1, D + n + 1, cmp ); for ( int i = 1; i &lt;= n; ++i ) W[D[i]] += E[( i - 1 ) % 10 + 1]; sort( D + 1, D + n + 1, cmp ); for ( int i = 1; i &lt;= k; ++i ) printf( "%d%c", D[i], "\n "[i != k] ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>水题</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeForces 546B」Soldier and Badges 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fcodeforces-546B-solution%2F</url>
    <content type="text"><![CDATA[CF546B Soldier and Badges题意翻译给 n 个数，每次操作可以将一个数 +1，要使这 n 个数都不相同， 求最少要加多少？ $1 \le n \le 3000$感谢@凉凉 提供的翻译 题目描述Colonel has $n$ badges. He wants to give one badge to every of his $n$ soldiers. Each badge has a coolness factor, which shows how much it’s owner reached. Coolness factor can be increased by one for the cost of one coin. For every pair of soldiers one of them should get a badge with strictly higher factor than the second one. Exact values of their factors aren’t important, they just need to have distinct factors. Colonel knows, which soldier is supposed to get which badge initially, but there is a problem. Some of badges may have the same factor of coolness. Help him and calculate how much money has to be paid for making all badges have different factors of coolness. 输入格式：First line of input consists of one integer $n$ ( $1 \le n \le 3000,1 \le n \le 3000$ ). Next line consists of $n$ integers $a_{i}$ ( $1 \le a_{i} \le n$ ), which stand for coolness factor of each badge. 输出格式：Output single integer — minimum amount of coins the colonel has to pay. 输入输出样例输入样例#1：1241 3 1 4 输出样例#1：11 输入样例#2：1251 2 3 2 5 输出样例#2：12 说明In first sample test we can increase factor of first badge by $1$ . In second sample test we can increase factors of the second and the third badge by $1$ . 思路其实这道题的思想很简单，就是每次遇到一个没有出现过的的数，就把之前的一个重复的数变成这个数。。。 我的代码可能有点奇怪。。。 我的主要思想是把取到的数的和 - 原来的和，然后就是答案。 具体看代码吧—— 代码12345678910111213141516171819202122#include&lt;cstdio&gt;#include&lt;queue&gt;using namespace std;#define MAXN 3005int n, ans, t, s;int nn;int a[MAXN * 2];int main()&#123; scanf( "%d", &amp;n ); for ( int i = 1; i &lt;= n; ++i ) scanf( "%d", &amp;t ), a[t]++, s += t, nn = max( nn, t );//哈希计数 t = 0; for ( int i = 1; i &lt;= 6000; ++i )&#123; if ( t == 0 &amp;&amp; i &gt; nn ) break; if ( t &gt; 0 &amp;&amp; a[i] == 0 ) t--, ans += i;//把一个该改的数改成这个数 if ( a[i] &gt; 1 ) t += a[i] - 1;//又多了这么多个待改变的数 if ( a[i] ) ans += i;//不改变的话也要加哦 &#125; printf( "%d\n", ans - s ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>CodeForces</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ1722」「Usaco2006 Mar」Milk Team Select产奶比赛 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fbzoj1722-solution%2F</url>
    <content type="text"><![CDATA[Milk Team Select 产奶比赛DescriptionFarmer John’s N ($1 \le N \le 500$) cows are trying to select the milking team for the world-famous Multistate Milking Match-up (MMM) competition. As you probably know, any team that produces at least X ($1 \le X \le 1,000,000$) gallons of milk is a winner. Each cow has the potential of contributing between $-10,000$ and $10,000$ gallons of milk. (Sadly, some cows have a tendency to knock over jugs containing milk produced by other cows.) The MMM prides itself on promoting family values. FJ’s cows have no doubt that they can produce X gallons of milk and win the contest, but to support the contest’s spirit,they want to send a team with as many parent-child relationships as possible (while still producing at least X gallons of milk). Not surprisingly, all the cows on FJ’s farm are female. Given the family tree of FJ’s cows and the amount of milk that each would contribute, compute the maximum number of parent-child relationships that can exist in a winning team. Note that a set of cows with a grandmother-mother-daughter combination has two parent-child relationships (grandmother-mother, mother-daughter). 约翰的N($1 \le N \le 500$)头奶牛打算组队去参加一个世界级的产奶比赛(Multistate Milking Match-up，缩写为MMM)．她们很清楚其他队的实力，也就是说，她们派出的队只要能产出至少X($1 \le X \le 1000000$)加仑牛奶，就能赢得这场比赛． 每头牛都能为集体贡献一定量的牛奶，数值在$-10000$到$10000$之间（有些奶牛总是想弄翻装着其他奶牛产的奶的瓶子）． MMM的举办目的之一，是通过竞赛中的合作来增进家庭成员之间的默契．奶牛们认为她们总是能赢得这场比赛，但为了表示对比赛精神的支持，她们希望在选出的队伍里能有尽可能多的牛来自同一个家庭，也就是说，有尽可能多对的牛有直系血缘关系（当然，这支队伍必须能产出至少X加仑牛奶）．当然了，所有的奶牛都是女性，所以队伍里所有直系血亲都是母女关系． 约翰熟知所有奶牛之间的血缘关系．现在他想知道，如果在保证一支队伍能赢得比赛的情况下，队伍中最多能存在多少对血缘关系．注意，如果一支队伍由某头奶牛和她的母亲、她的外祖母组成，那这支队伍里一共有2对血缘关系（这头奶牛外祖母与她的母亲，以及她与她的母亲）． InputLine 1: Two space-separated integers, N and X. Lines 2..N+1: Line i+1 contains two space-separated integers describing cow i. The first integer is the number of gallons of milk cow i would contribute. The second integer (range 1..N) is the index of the cow’s mother. If the cow’s mother is unknown, the second number is 0. The family information has no cycles: no cow is her own mother, grandmother, etc. 第1行：两个用空格隔开的整数N和X. 第2到N+1行：每行包括两个用空格隔开的整数，第一个数为一只奶牛能贡献出的牛奶的加仑数，第二个数表示她的母亲的编号．如果她的母亲不在整个牛群里，那第二个数为0．并且，血缘信息不会出现循环，也就是说一头奶牛不会是自己的母亲或祖母，或者更高代的祖先． OutputLine 1: The maximum number of parent-child relationships possible on a winning team. Print -1 if no team can win. 输出在一个能获胜的队伍中，最多可能存在的有血缘关系的牛的对数．如果任何一支队伍都不可能获胜，输出-1. Sample Input1234565 8-1 03 15 1-3 32 0 第一个数字代表这头奶的产量,第二个数字代表其父亲点是哪一个. INPUT DETAILS: There are 5 cows. Cow 1 can produce -1 gallons and has two daughters, cow 2 and 3, who can produce 3 and 5 gallons, respectively. Cow 3 has a daughter (cow 4) who can produce -3 gallons. Then there’s cow 5, who can produce 2 gallons. Sample Output12 HINT约翰一共有5头奶牛．第1头奶牛能提供-1加仑的牛奶，且她是第2、第3头奶牛的母亲．第2、第3头奶牛的产奶量务别为3加仑和5加仑．第4头奶牛是第3头奶牛的女儿，她能提供-3加仑牛奶．还有与其他牛都没有关系的第5头奶牛，她的产奶量是2加仑．最好的一支队伍包括第1，2，3，5头奶牛．她们一共能产出$-1+3+5+2=9 \ge 8$加仑牛奶，并且这支队伍里有2对牛有血缘关系（1-2和1-3）．如果只选第2，3，5头奶牛，虽然总产奶量会更高（10加仑），但这支队伍里包含的血缘关系的对数比上一种组合少（队伍里没有血缘关系对）． SourceGold 思路很明显,这是一道动态规划题（看着很像背包嘛）那我们要用什么作为下标呢？ 以牛奶量：牛奶量的数据范围较大，最多只能开一维数组(除非你开滚动数组)。总体来说较难考虑。 以关系数：关系数最多只有 N - 1 对，可以给每头牛开一个 MAXN 的数组，看起来更行得通。。。 还有，因为要考虑关系数的转换问题，所以还有开一维[0/1]表示这头牛取不取。 我们发现，这些关系是无环的，或者说这是一个森林(本来我想用拓扑排序，后来还是放弃了。。。)，所以可以再建立一头“牛祖先”，连接原来所有祖先，构成一棵树(即无母亲的节点都认0为母亲)。 对于样例，可以构成如图的一棵树： 整理一下，刚才讲到建立一个 $int f[MAXN][MAXN][2];$ 的数组，$f[i][j][op]$表示以第 i 个节点为根的树 共有 j 对关系，op = 1 时表示取这个节点，op = 0 时表示不取。 可以把 关系数 作为背包容量，牛奶量 作为 价值 用分组背包的方法来考虑。 具体的部分自己慢慢理解吧。 上代码—— 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;#define MAXN 505#define INF 0x3f3f3f3fint N, X, ans;int c[MAXN], t;int head[MAXN], to[MAXN &lt;&lt; 1], nxt[MAXN &lt;&lt; 1], tot(0);int f[MAXN][MAXN][2];void Add( int x, int y )&#123; to[++tot] = y; nxt[tot] = head[x]; head[x] = tot; &#125;void DFS( int x, int fa )&#123; for ( int i = 1; i &lt;= N; i++ ) f[x][i][0] = f[x][i][1] = -INF;//初始值均为负无穷 for ( int i = head[x]; i; i = nxt[i] )&#123; if ( to[i] == fa ) continue; DFS( to[i], x );//先完成子节点 for ( int j = N; j &gt;= 0; --j )&#123;//分配的关系数 for ( int k = 0; k &lt;= j; ++k )&#123;//背包—— f[x][j][1] = max( f[x][j][1], f[x][j - k][1] + max( k == 0 ? -INF : f[to[i]][k - 1][1], f[to[i]][k][0] ) ); f[x][j][0] = max( f[x][j][0], f[x][j - k][0] + max( f[to[i]][k][1], f[to[i]][k][0] ) ); &#125; &#125; &#125; for ( int i = 0; i &lt;= N; ++i ) f[x][i][1] += c[x];//若取这个节点，加上这个点的价值&#125;int main()&#123; scanf( "%d%d", &amp;N, &amp;X ); for ( int i = 1; i &lt;= N; ++i )&#123; scanf( "%d%d", &amp;c[i], &amp;t ); Add( i, t ); Add( t, i );//链式前向星存边 &#125; DFS( 0, -1 ); int ans(N); while( ans &gt;= 0 )&#123; if ( f[0][ans][0] &gt;= X ) break; ans--; &#125; printf( "%d\n", ans ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>背包DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ1385」「Baltic2000」Division expression 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fbzoj1385-solution%2F</url>
    <content type="text"><![CDATA[Division expressionDescription除法表达式有如下的形式: $X_1/X_2/X_3…/X_k$ 其中Xi是正整数且$X_i \le 1000000000(1 \le i \le k,K \le 10000)$ 除法表达式应当按照从左到右的顺序求，例如表达式1/2/1/2的值为1/4.但可以在表达式中加入括号来改变计算顺序，例如(1/2)/(1/2)的值为1.现给出一个除法表达式E，求是告诉是否可以通过增加括号来使其为E’,E’为整数。 Input先给出一个数字D，代表有D组数据. 每组数据先给出一个数字N，代表这组数据将有N个数。 接下来有N个数 Output如果能使得表达式的值为一个整数，则输出YES.否则为NO Sample Input123456789102412123123 Sample Output12YESNO 思路观察这个式子$E = X_1 / X_2 / X_3 …. / X_n$ 我们设$E’ = X_{a1} * X_{a2}…./ X_{b1} / X_{b2}….$ 即把加括号后的式子改成分数线的形式，有一些元素属于分子，其他的元素属于分母。 我们发现： $X_1$ 不得不在分子 没有为什么 就是不可以 $X_2$ 不得不在分母 因为你想让它去分母它也不可能到分母 $X_3 to X_n$ 可在分子也可在分母 总是有办法的QAQ 如果叫你把$X_3 to X_n$分一部分在分子，其他的在分母，你会怎么做？？ 当然是把全部元素放在分子呗。。。 因此最优的 $E’ = X_1 X_3 X_4….* X_n / X_2$ 如果真的乘起来的话肯定会溢出，所以当然要用GCD。 清爽的30行代码$(～￣▽￣)～ $ 代码123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;using namespace std;#define MAXN 10005int T;int n, t, s;int gcd( int x, int y )&#123; return x % y == 0 ? y : gcd( y, x % y );&#125;int main()&#123; scanf( "%d", &amp;T ); while( T-- )&#123; scanf( "%d", &amp;n ); scanf( "%d", &amp;t ); if ( n == 1 )&#123;//注意特判 printf( "YES\n" ); continue; &#125; scanf( "%d", &amp;s ); s /= gcd( s, t ); for ( int i = 3; i &lt;= n; ++i )&#123; scanf( "%d", &amp;t ); s /= gcd( s, t ); &#125; if ( s == 1 ) printf( "YES\n" ); else printf( "NO\n" ); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>水题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ4590」「SHOI2015」 自动刷题机 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fbzoj4590-solution%2F</url>
    <content type="text"><![CDATA[自动刷题机Description曾经发明了信号增幅仪的发明家SHTSC又公开了他的新发明：自动刷题机—一种可以自动AC题目的神秘装置。自动刷题机刷题的方式非常简单：首先会瞬间得出题目的正确做法，然后开始写程序，每秒，自动刷题机的代码生成模块会有两种可能的结果： A.写了x行代码。B.心情不好，删掉了之前写的y行代码。（如果y大于当前代码长度则相当于全部删除。） 对于每个OJ所有题目，存在某个固定的长度n&gt;0。一旦自动刷题机在某秒结束时积累了大于等于n行的代码，它就会自动提交并AC此题，然后新建一个文件开始写下一题。SHTSC在某个OJ上跑了一天的自动刷题机，得到了很多条关于写代码的日志信息。他突然发现自己没有记录这个OJ的n究竟是多少。所幸他通过自己在OJ上的Rank知道了机一共切了k道题。希望你计算n可能的最小值和最大值。 Input第一行两个整数l，k，表示刷题机的日志一共有l行，一共了切了k题。 第二行l个整数，$x_1…x_l。$$x_i \ge 0$表示写了$x_i$行代码。$x_i&lt;0$表示删除了这道题的$-x_i$行代码。 $1 \le l,k \le 100000，\left| x_i \right| \le10^9$ Output输出两个数a，b。分别代表n可能的最小值和最大值。如果不存在这样的n则输出-1。 Sample Input123454 225-39 Sample Output13 7 样例1：如果n=2那么刷题机就会切掉3题。但如果n&gt;7刷题机最多只能切1题。考虑n=4发生了什么。 第一秒：刷题机写了2行。 第二秒：刷题机又写了5行，共有7行，提交，自信AC。 第三秒：刷题机删掉了3行，共有0行。 第四秒：刷题机写了9行，共有9行，提交，自信AC。 一共AC了两题。 思路这是一道二分题。 没错这就是一道二分题。 它的单调性很明显。n越大，切的题就越少。 这里要求最小值(ans1)与最大值(ans2)，所以要写2个二分，一个判断条件是$check(mid) &gt; k$ 另一个是 $\ge$ 。 ans1要加1,因为$&gt;k$求出的是 满足 $check(mid) &gt; k$ 的 最大值。如果有答案的话，$ans1 + 1$必定是满足$check(mid) = k$最小值。 话不多说，直接上代码$(〃’▽’〃)——$ 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;iostream&gt;using namespace std;#define LL long longint l, k;LL a[100005];LL le(1), ri, ans1, ans2, mid;LL check( LL x )&#123;//模拟求切题数 LL cur(0), s(0); for ( int i = 1; i &lt;= l; ++i )&#123; cur = max( cur + a[i], 0ll ); if ( cur &gt;= x )&#123; s++; cur = 0; &#125; &#125; return s;&#125;int main()&#123; scanf( "%d%d", &amp;l, &amp;k ); for ( int i = 1; i &lt;= l; ++i ) scanf( "%lld", &amp;a[i] ); le = 1; ri = 1000000000000000;//边界是个坑，走远一点就不会掉进去了嘛(｀・ω・´)反正时间复杂度不会超过O(100) while( le &lt;= ri )&#123; mid = ( le + ri ) &gt;&gt; 1; if ( check( mid ) &gt; k )&#123; le = mid + 1; ans1 = mid; &#125; else ri = mid - 1; &#125; ans1++; le = 1; ri = 1000000000000000; while( le &lt;= ri )&#123; mid = ( le + ri ) &gt;&gt; 1; if ( check( mid ) &gt;= k )&#123; le = mid + 1; ans2 = mid; &#125; else ri = mid - 1; &#125; if ( check( ans1 ) != k ) printf( "-1\n" ); else printf( "%lld %lld\n", ans1, ans2 ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ4510」「Usaco2016 Jan」Radio Contact 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fbzoj4510-solution%2F</url>
    <content type="text"><![CDATA[无线电联系 Radio Contact题目描述Farmer John has lost his favorite cow bell, and Bessie the cow has agreed to help him find it! They both fan out and search the farm along different paths, but stay in contact via radio so they can keep in touch with each-other. Unfortunately, the batteries in their radios are running low, so they want to plan their movements so as to conserve power, by trying to stay always within a short distance apart. Farmer John starts at location ($f_x, f_y$) and plans to follow a path consisting of NN steps, each of which is either ‘N’ (north), ‘E’ (east), ‘S’ (south), or ‘W’ west. Bessie starts at location ($b_x, b_y$) and follows a similar path consisting of MM steps. Both paths may share points in common. At each time step, Farmer John can either stay put at his current location, or take one step forward along his path, in whichever direction happens to be next (assuming he has not yet reached the final location in his path). Bessie can make a similar choice. At each time step (excluding the first step where they start at their initial locations), their radios consume energy equal to the square of the distance between them. Please help FJ and Bessie plan a joint movement strategy that will minimize the total amount of energy consumed up to and including the final step where both of them first reach the final locations on their respective paths. FJ失去了他最喜欢的牛铃，而Bessie已经同意帮助他找到它！他们用不同的路径搜索农场，通过无线电保持联系。不幸的是，无线电中的电池电量不足，所以他们设法尽可能保持两者位置的距离最小，以节省电量。 FJ从位置$(f_x,f_y)$开始，并计划遵循由N步骤组成的路径，每个步骤都是“N”（北），“E”（东），“S”（南），或“W”（西）。Bessie从位置$(b_x,b_y)$开始，并遵循由M步骤组成的类似路径。两个路径可以经过相同的点。在每个时间段，FJ可以保持在他现在的位置，或沿着他的道路前进一步，无论哪个方向恰好在下一个（假设他还没有到达他的路径的最后位置）。Bessie可以做出类似的选择。在每个时间步（不包括从初始位置开始的第一步），他们的无线电消耗的能量等于它们之间距离的平方。 请帮助FJ和Bessie计划行动策略，最大限度地减少消耗的能量总量。总量包括最终步骤，这时两者首先到达各自路径上的最终位置。 输入输出格式输入格式：The first line of input contains $N$ and $M$ ($1 \le N, M \le 1000$). The second line contains integers $f_x$ and $f_y$, and the third line contains $b_x$ and $b_y$ ($0 \le f_x, f_y, b_x, b_y \le 1000$). The next line contains a string of length $N$ describing FJ’s path, and the final line contains a string of length $M$ describing Bessie’s path. It is guranteed that Farmer John and Bessie’s coordinates are always in the range ($0 \le x,y \le 1000$) throughout their journey. Note that East points in the positive x direction and North points in the positive y direction. 第一行输入$N$和$M$（$1 \le N,M \le 1000$）。 第二行输入整数$f_x$和$f_y$，第三行输入$b_x$和$b_y$$(0 \le f_x,f_y,b_x,b_y \le 1000)$。下一行包含一个长度为N的字符串描述FJ的路径，最后一行包含一个字符串的长度$M$描述Bessie的路径。 数据满足$(0 \le x,y \le 1000)$。注意，东方向为正X方向，北方向为正Y方向。 输出格式：Output a single integer specifying the minimum energy FJ and Bessie can use during their travels. 输出一个整数，表示最小能量。 输入输出样例输入样例#1：123452 73 05 0NNNWWWWWN 输出样例#1：128 思路 众所周知，DP是一个好东西，所以这题用DP。 这是样例的示意图 这道题有十分明显的阶段性，而且数据也不大，所以用DP即可。我们用一个二维数组f[i][j]表示当Farmer John到第i步，Bessie到第j步时所需花费的最小能量。转移方程容易推得： 1f[i][j] = min( f[i][j - 1], f[i - 1][j], f[i - 1][j - 1] ) + dist; 其中dist表示FJ在第i步，Bessie在j步时他们距离的平方$( tx1 - tx2 ) \times ( tx1 - tx2 ) + ( ty1 - ty2 ) \times ( ty1 - ty2 )$ 这里要注意初始化: 123f[i][0] = f[i - 1][0] + dist;f[0][i] = f[i - 1][0] + dist;f[0][0] = 0;//因为从初始位置开始的第一步不需要能量 这里我用一个move函数移动坐标(用了引用变量方便一点) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;#define MAXN 1005#define LL long longint N, M;LL f[MAXN][MAXN];//开long long防止上溢int fx, fy, bx, by, la, lb;char a[MAXN], b[MAXN];//移动方向void move( int &amp;x, int &amp;y, char d )&#123; //移动坐标 switch( d )&#123; case 'N': y++; break; case 'S': y--; break; case 'W': x--; break; case 'E': x++; break; &#125;&#125;LL dist( int x1, int y1, int x2, int y2 )&#123; //花费能量 return ( x1 - x2 ) * ( x1 - x2 ) + ( y1 - y2 ) * ( y1 - y2 );&#125;int main()&#123; scanf( "%d%d", &amp;N, &amp;M ); scanf( "%d%d%d%d", &amp;fx, &amp;fy, &amp;bx, &amp;by ); scanf( "%s%s", a + 1, b + 1 ); la = strlen( a + 1 ); lb = strlen( b + 1 ); int tx1(fx), ty1(fy), tx2(bx), ty2(by);//FJ、Bessie的坐标 for ( int i = 1; i &lt;= la; ++i )&#123; // 初始化f[i][0](i != 0) move( tx1, ty1, a[i] ); f[i][0] = f[i - 1][0] + dist( tx1, ty1, bx, by ); &#125; for ( int i = 1; i &lt;= lb; ++i )&#123; //初始化f[0][i](i != 0) move( tx2, ty2, b[i] ); f[0][i] = f[0][i - 1] + dist( fx, fy, tx2, ty2 ); &#125; tx1 = fx; ty1 = fy; for ( int i = 1; i &lt;= la; ++i )&#123; tx2 = bx; ty2 = by; move( tx1, ty1, a[i] ); for ( int j = 1; j &lt;= lb; ++j )&#123; move( tx2, ty2, b[j] ); f[i][j] = min( f[i - 1][j], f[i][j - 1] ); // 上述转移方程 f[i][j] = min( f[i][j], f[i - 1][j - 1] ); f[i][j] += dist( tx1, ty1, tx2, ty2 ); &#125; &#125; printf( "%lld", f[la][lb] ); return 0;&#125; 所以: DP是个好东西]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>线性DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CodeForces 476A」Dreamoon and Stairs 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fcodeforces-476A-solution%2F</url>
    <content type="text"><![CDATA[Dreamoon and Stairs题意翻译题面 DM小朋友想要上一个有 $n$ 级台阶的楼梯。他每一步可以上 $1$ 或 $2$ 级台阶。假设他走上这个台阶一共用了 $x$ 步。现在DM想知道 $x$ 是否可能为 $m$ 的倍数。如果可能，输出 $x$ 的最小值。如果不可能，输出 $-1$输入 两个正整数 $n,m (n \le 10000,m \le 10)$输出 按要求输出 $x$ 或 $-1$ 题目描述Dreamoon wants to climb up a stair of nn steps. He can climb $1$ or $2$ steps at each move. Dreamoon wants the number of moves to be a multiple of an integer $m$ .What is the minimal number of moves making him climb to the top of the stairs that satisfies his condition? 输入输出格式输入格式：The single line contains two space separated integers $n$ , $m$ ($0&lt;n \le 10000,1&lt;m \le 10$). 输出格式：Print a single integer — the minimal number of moves being a multiple of $m$ . If there is no way he can climb satisfying condition print $-1$ instead. 输入输出样例输入样例#1：110 2 输出样例#1：16 输入样例#2：13 5 输出样例#2：1-1 说明For the first sample, Dreamoon could climb in 6 moves with following sequence of steps: {2, 2, 2, 2, 1, 1}. For the second sample, there are only three valid sequence of steps {2, 1}, {1, 2}, {1, 1, 1} with 2, 2, and 3 steps respectively. All these numbers are not multiples of 5. 一句话题意 给定一个n级的台阶，开始时在第0级，每次可以向上爬1级或2级，问最少要爬多次才能爬到顶，而且爬的次数是m的倍数。 思路很明显，爬完这个台阶的最多步数是n(每次爬1层),最少步数 $\frac{n - 1}2 + 1$ (等价于 $\frac n2 + n \% 2$) (每次爬2层,如果层数是奇数，那再爬1层)，并且在( $\frac{n - 1}2 + 1$ ) ~ n 之间都可以到达。 所以只要选取( $\frac{n - 1}2 + 1$ ) ~ n 之间最小的能被m整除的数即可。 当然，这道题还可以用DP解决，那比较费时间，比较费空间，也比较难调试(谁愿意呢)，所以这里不再赘述。 代码下面给出两种写法—— 写法一比较保险的O($\frac nm$)算法(我模拟赛时就用这种的) 12345678910111213#include&lt;cstdio&gt;using namespace std;int n, m;int ans;int main()&#123; scanf( "%d%d", &amp;n, &amp;m ); while( ans &lt; n / 2 + n % 2 ) ans += m; if ( ans &gt; n ) ans = -1; printf( "%d\n", ans ); return 0;&#125; 写法二比较有风险的O(1)算法(就怕出错,有hack数据的请联系我) 1234567891011121314#include&lt;cstdio&gt;using namespace std;int n, m;int ans;int main()&#123; scanf( "%d%d", &amp;n, &amp;m );i if ( n == 0 ) printf( "0\n" ); ans = ( ( n / 2 + n % 2 - 1 ) / m + 1 ) * m; if ( ans == 0 || ans &gt; n ) ans = -1; printf( "%d\n", ans ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>CodeForces</tag>
        <tag>递推</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HDU3823」 Prime Friend 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fhdu3823-solution%2F</url>
    <content type="text"><![CDATA[Prime FriendTime Limit: 4000/2000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others)Total Submission(s): 5025 Accepted Submission(s): 1035 Problem DescriptionBesides the ordinary Boy Friend and Girl Friend, here we define a more academic kind of friend: Prime Friend. We call a nonnegative integer A is the integer B’s Prime Friend when the sum of A and B is a prime.So an integer has many prime friends, for example, 1 has infinite prime friends: 1, 2, 4, 6, 10 and so on. This problem is very simple, given two integers A and B, find the minimum common prime friend which will make them not only become primes but also prime neighbor. We say C and D is prime neighbor only when both of them are primes and integer(s) between them is/are not. InputThe first line contains a single integer T, indicating the number of test cases.Each test case only contains two integers A and B. Technical Specification 1 &lt;= T &lt;= 1000 1 &lt;= A, B &lt;= 150 OutputFor each test case, output the case number first, then the minimum common prime friend of A and B, if not such number exists, output -1. Sample Input12322 43 6 Sample Output12Case 1: 1Case 2: -1 AuthoriSea@WHU SourceThe 6th Central China Invitational Programming Contest and 9th Wuhan University Programming Contest Final 先线性筛出所有质数，然后对所有邻质数对进行处理。为了方便描述，我们设一对邻质数的差为Ki，很明显，Ki &gt; 150时是毫无用处的(因为输入中两个数最极端的差为150)，并且，对于每个小于等于150的Ki，只用保留较大质数小于等于150的所有邻质数与大于150的第一对邻质数。 有点拗口 (语文没学好T-T) 也就是说，Ki大于150的，除了第一个，其他都不要了，因为它们肯定不及第一个优(求的是x的最小值嘛)，但是留下的都有价值 。 思路1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;#define si 13626407//最大的有效质数是这个,输出max(a[i][j])得到的(节约空间，人人有责)int T;int A, B, sum;//sum为 已取完所有 有效素数 的Ki有几个bool p[si + 5];//加5免得越界int v[887319], tot; // 1~si范围内质数的个数+5 tot存储目前素数个数bool c[155];//判断第一个大于150的并且差为Ki的有没有出现vector&lt;int&gt; a[155];//a[Ki]存储所有差为Ki有效的邻质数(较小的那个)inline void init()&#123;//线性筛素数 p[1] = 1;//1不是素数 int t; for ( int i = 2; i &lt;= si; ++i )&#123; if ( !p[i] )&#123; v[++tot] = i; if ( i &lt;= 150 )&#123;//开始时没加，但也可以过，数据比较水 a[0].push_back(i); &#125;else&#123; if ( !c[0] )&#123; c[0] = 1; a[0].push_back(i); &#125; &#125; if ( i != 2 )&#123; if ( i &lt;= 150 ) a[i - t].push_back(t); else&#123; if ( i - t &lt;= 150 &amp;&amp; !c[i - t] )&#123; c[i - t] = 1; a[i - t].push_back(t); sum++; &#125; &#125; &#125; t = i; &#125; if ( sum &gt;= 75 ) break; // Ki只可能是偶数(因为质数除2外都是奇数，奇数减奇数为偶数) 因此只有 150 个(当然了，除2、3外，但是这里2和3不计入sum) for ( int j = 1; j &lt;= tot; ++j ) if ( i * v[j] &lt;= si ) p[i * v[j]] = 1; else break; &#125;&#125;int main()&#123; init(); scanf( "%d", &amp;T ); for ( int I = 1; I &lt;= T; ++I )&#123; scanf( "%d%d", &amp;A, &amp;B ); if ( A &gt; B )&#123; int t(A); A = B; B = t;//如果A &gt; B 就交换 使 A &lt;= B &#125; int ans(-1); for ( int i = 0; i &lt; a[B - A].size(); ++i )&#123;//在所有差为B - A的质数对中找第一个满足条件的数 if ( A &lt;= a[B - A][i] )&#123; ans = a[B - A][i] - A; break; &#125; &#125; printf( "Case %d: %d\n", I, ans ); &#125; return 0;&#125; 撒花(^-^)]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>数学,数论</tag>
        <tag>质数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「学习笔记」动态规划 I『初识DP』]]></title>
    <url>%2F2019%2F01%2F23%2Fnotes-dynamic-programming-I%2F</url>
    <content type="text"><![CDATA[写在前面注意：此文章仅供参考，如发现有误请及时告知。 更新日期：2018/3/16，2018/12/03 动态规划介绍动态规划，简称DP(Dynamic Programming)简介1 简介2 动态规划十分奇妙，它可以变身为记忆化搜索，变身为递推，甚至有时可以简化成一个小小的算式。 动态规划十分灵活，例如 NOIP2018 PJ T3 摆渡车 ，写法有很多很多，但时间、内存却各有差异。 动态规划十分简单，有时候一个小小的转移方程就能解决问题。 动态规划十分深奥，有时你会死也想不出合适的转移方程，有时你会被后效性困扰，有时动态规划的同时还有许多蜜汁优化。 动态规划在NOIP中十分重要，我目前为止参加的$NOIP_{2017 PJ} \&amp; NOIP_{2018PJ}$都有一道动态规划，而且都是$T3$。(估计普及考纲比较窄，要出难题只有DP了) 问题引入还是这道题…… 数塔问题！！！ 这里我们选择动态规划来解决.我们不难理解，对于每一个元素，它到顶层的最大值是确定的，也就是说，从顶层到任何一个元素的最大值都是确定的.比如，对于第3层的第2个元素6，顶层到它的最大值只有一个（9 + 15 + 6 = 30）（但不代表路径只有一条），不会改变. 所以，我们用一个数组dp来存储从元素(i, j)到底层的最大值. 12#define MAXN 100int dp[MAXN + 5][MAXN + 5]; 仔细观察分析，不难发现，对于每一个元素dp[i][j],都存在 1dp[i][j] = max( dp[i + 1][j], dp[i + 1][j + 1] ) + a[i][j]; 即每一个元素到(1, 1)的最大值都是上一层与它相连的两个元素中较大的一个，再加上这个元素本身的值. 最后的答案即为dp[1][1]. 不过，我们自顶向下分析，但是却要自底向上实现，即从最顶层开始分析，写代码时却要注意for语句要倒过来写： 123for ( int i = N; i &gt;= 1; --i ) for ( int j = 1; j &lt;= i; ++j ) dp[i][j] = max( dp[i + 1][j], dp[i + 1][j + 1] ) + a[i][j]; 为什么会这样呢？其实不难分析，在算dp[i][j]时，你必须确保dp[i + 1][j]和 dp[i + 1][j + 1]已经完成，如果没有完成，dp[i + 1][j]和 dp[i + 1][j + 1]的值就是错误的，算出的dp[i][j]也是错误的，这样结果就不对了。而反过来做，你就会发现i从大的开始，在做dp[i][j]的时候dp[i + 1][1 ~ N]都已经做过了。还有，要注意，动态规划的初始化很重要，有时初始化就会决定你结果对不对。这里的初始化很简单，现在给出两种方法： 12345678910memset( dp[N + 1], 0, sizeof( dp[N + 1] ) );//即把dp[N + 1][0...]全部初始化为0.for ( int i = 1; i &lt;= N; ++i ) dp[i] = a[i];//下面这个与上面等价：copy( a[N] + 1, a[N] + N + 1, dp[N] );// copy( 开始地址, 结束地址, 放到的数组 ); copy( a, a + n, b );即为把a数组下标为0~n按次序复制到b数组.//当然，这样写，实现时要注意少一层循环：(下面这个是修改后的)for ( int i = N - 1; i &gt;= 1; --i ) for ( int j = 1; j &lt;= i; ++j ) dp[i][j] = max( dp[i + 1][j], dp[i + 1][j + 1] ) + a[i][j];//至于为什么这样，这里不再赘述，请自己思考. 这里再完整地放一放代码，实在不会写的可以参考. 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 100int C, N;int a[MAXN + 5][MAXN + 5];int dp[MAXN + 5][MAXN + 5];void solve()&#123; scanf( "%d", &amp;N ); memset( dp, 0, sizeof dp ); for ( int i = 1; i &lt;= N; ++i ) for ( int j = 1; j &lt;= i; ++j ) scanf( "%d", &amp;a[i][j] ); for ( int i = N; i &gt;= 1; --i ) for ( int j = 1; j &lt;= i; ++j ) dp[i][j] = max( dp[i + 1][j], dp[i + 1][j + 1] ) + a[i][j]; printf( "%d\n", dp[1][1] );&#125;int main()&#123; scanf( "%d", &amp;C ); while( C-- ) solve(); return 0;&#125; 事实上，可以做一个优化：去掉dp数组，直接用a数组来做：(节约空间，人人有责) 1234567891011121314151617181920212223#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 100int C, N;int a[MAXN + 5][MAXN + 5];void solve()&#123; scanf( "%d", &amp;N ); for ( int i = 1; i &lt;= N; ++i ) for ( int j = 1; j &lt;= i; ++j ) scanf( "%d", &amp;a[i][j] ); for ( int i = N - 1; i &gt;= 1; --i ) for ( int j = 1; j &lt;= i; ++j ) a[i][j] += max( a[i + 1][j], a[i + 1][j + 1] ); printf( "%d\n", a[1][1] );&#125;int main()&#123; scanf( "%d", &amp;C ); while( C-- ) solve(); return 0;&#125; 至于为什么，请诸位自己理解（很好理解的，选个小一点的数据自己算一算就知道了）。 总结怎么样，找到些感觉了吧？现在我们来学习怎么写动态规划的程序. 第一步，我们要观察题目是否可以用动态规划实现。怎么判断呢？我们要看它是否可以分成几个阶段，如上题，可以分成1~N层共N个阶段，每个阶段还可以分成1~i个元素共i个小阶段。然后，我们要看看每个阶段的答案是不是确定的，上题中，每一个元素到底层的最大值就是确定的。再看看每个阶段是不是有关联，如果有，还要确定有什么关联，是否对于每一个阶段都满足。 第二步，就是确定关联啦。怎么确定呢？我们要仔细分析题目，观察每两个阶段之间的关系。动态规划的重点也就在这里，关联确定了，动态规划基本上就可以写下来了。 第三步，确定边界条件，比如，上题就要把dp[N+1][...]全部赋值为0，否则就会出错。 除此之外，还要确定完成的顺序，要做某个阶段，它需要用到的阶段必须先做完。 当然，有时还要添加滚动数组、优化等。 这样，一个动态规划程序就完成啦。 尾声当然，动态规划还有许多分支（背包DP、区间DP等），以上讲的都是最表皮的。那些难一点的，都只好下次再讲吧。 最好拿点题目来练一下：洛谷的DP]]></content>
      <tags>
        <tag>线性DP</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「学习笔记」离散化]]></title>
    <url>%2F2019%2F01%2F23%2Fnotes-discretization%2F</url>
    <content type="text"><![CDATA[介绍离散化是应用于当结果与具体数值无关时，将较大数据按次序变为较小数据的一种算法。 用科学的语言说，就是 把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。 说白了就是把较大数据编成一个个较小，但是大小关系不变的数。 也就是这样子： 原始数据 离散化后 12 1 32 3 18 2 12 1 有些人说：那用一个map不就行了么？？？ 蓝鹅 map 的常数真的大 尽量别用了，而且，这里是在讲离散化，不是map，所以我们继续看—— 过程离散化的过程真的很简单。一般来说只有那么3步~ 1.排序 2. 去重 3.映射 排序 就是把数据放到另外一个数组排一遍 sort~ 去重 用unique就可以了~ 映射 修改原来数组的数据 一般用lower_bound实现 即二分找出某个元素的排名，将该元素赋为其排名即可。 很简单吧？其实这就是STL三重奏 代码1234567891011121314151617#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;#define MAXN 100005int n, m;int a[MAXN], b[MAXN];int main()&#123; scanf( "%d", &amp;n ); for ( int i = 1; i &lt;= n; ++i ) scanf( "%d", &amp;a[i] ), b[i] = a[i]; sort( b + 1, b + n + 1 );//STEP ONE m = unique( b + 1, b + n + 1 ) - b - 1;//STEP TWO for ( int i = 1; i &lt;= n; ++i ) a[i] = lower_bound( b + 1, b + m + 1 ) - b;//STEP THREE for ( int i = 1; i &lt;= n; ++i ) printf( "%d%c", a[i], " \n"[i == n] ); return 0;&#125;]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「学习笔记」ST表]]></title>
    <url>%2F2019%2F01%2F23%2Fnotes-sparse-table%2F</url>
    <content type="text"><![CDATA[问题引入先让我们看一个简单的问题，有N个元素，Q次操作，每次操作需要求出一段区间内的最大/小值。 这就是著名的RMQ问题。 RMQ问题的解法有很多，如线段树、单调队列(某些情况下)、ST表等。这里主要探讨ST表 过程ST表是一种神奇的算法,它以倍增与二进制为基础，实现区间内最大/小值。话不多说，直接切入正题—— 我们这里以求区间最大值为例。 首先，我们可以用O($N lg N$)的时间复杂度预处理出以i开始，接下来2j个元素中的最大值。我们借助递推/DP的思想。 123for ( int i = 1; i &lt;= l; ++i ) for ( int j = 1; j + ( 1 &lt;&lt; i ) - 1 &lt;= n; ++j ) f[j][i] = max( f[j][i - 1], f[j + ( 1 &lt;&lt; ( i - 1 ) )][i - 1] ); 然后就可以以O(1)的复杂度求出任意两个区间的最大值辣。 假设要求[ x, y ] 区间内的最大值(因为区间相交对于最大值是没有影响的，所以可以直接把最接近区间长度的2的倍数设为2z，求出f[x][z]与f[y - ( 1 &lt;&lt; z ) + 1][z]的最大值即可)。 1printf( "%d\n", max( f[x][z], f[y - ( 1 &lt;&lt; z ) + 1][z] ) ); 为了保证复杂度为O(1) 我们采用一个数组预处理出1 ~ N 的log值 12lg[1] = 0;for ( int i = 2; i &lt;= N; ++i ) lg[i] = lg[i &gt;&gt; 1] + 1; 代码123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cctype&gt;#include&lt;queue&gt;using namespace std;int N, Q;int f[100005][30];int lg[100005];int main()&#123; scanf( "%d%d", &amp;N, &amp;Q ); for ( int i = 1; i &lt;= N; ++i ) scanf( "%d", &amp;f[i][0] );//从i开始2^0(就是1)个元素的最大值就是它自己 lg[1] = 0;//2 ^ 0 = 1 所以lg 1 = 0 for ( int i = 2; i &lt;= N; ++i ) lg[i] = lg[i &gt;&gt; 1] + 1; int l(lg[N]); for ( int i = 1; i &lt;= l; ++i )//按长度从小到大，以保证较小长度已经完成 for ( int j = 1; j + ( 1 &lt;&lt; i ) - 1 &lt;= N; ++j ) f[j][i] = max( f[j][i - 1], f[j + ( 1 &lt;&lt; ( i - 1 ) )][i - 1] );//如上所述 while( Q-- )&#123; int x, y, z; scanf( "%d%d", &amp;x, &amp;y ); z = lg[y - x + 1]; printf( "%d\n", max( f[x][z], f[y - ( 1 &lt;&lt; z ) + 1][z] ) );//如上所述 &#125; return 0;&#125; 推荐题目 洛谷 P3865【模板】ST表(等于Loj #10119. 「一本通 4.2 例 1」数列区间最大值 ) 洛谷 P2251 质量检测 Loj #10120. 「一本通 4.2 例 2」最敏捷的机器人 Loj #10121. 「一本通 4.2 例 3」与众不同 Loj #10122. 「一本通 4.2 练习 1」天才的记忆 Bzoj 1699: [Usaco2007 Jan]Balanced Lineup排队 (等于Loj #10123. 「一本通 4.2 练习 2」Balanced Lineup 洛谷 P2880 [USACO07JAN]平衡的阵容Balanced Lineup ) NOIP 2011 提高组 选择客栈 ：洛谷 P1311 选择客栈 Loj #2597. 「NOIP2011」选择客栈]]></content>
      <tags>
        <tag>ST表</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CH2401」送礼物 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fch2401-solution%2F</url>
    <content type="text"><![CDATA[CH2401 送礼物描述作为惩罚，GY被遣送去帮助某神牛给女生送礼物(GY：貌似是个好差事)但是在GY看到礼物之后，他就不这么认为了。某神牛有N个礼物，且异常沉重，但是GY的力气也异常的大(-_-b)，他一次可以搬动重量和在w(w&lt;=2^31-1)以下的任意多个物品。GY希望一次搬掉尽量重的一些物品，请你告诉他在他的力气范围内一次性能搬动的最大重量是多少。 输入格式第一行两个整数，分别代表W和N。以后N行，每行一个正整数表示G[i],G[i]&lt;= 2^31-1。 输出格式仅一个整数，表示GY在他的力气范围内一次性能搬动的最大重量。 样例输入12345620 5754181 样例输出119 数据范围与约定 对于20%的数据 N&lt;=26对于40%的数据 W&lt;=2^26对于100%的数据 N&lt;=45 W&lt;=2^31-1 思路这么小的数据。。。一般是搜索吧？？？这么大的W，用DP做肯定不成，而且也不资瓷离散化。。。。 直接搜？+剪枝？我已经剪不下去了。。。不过80分勉勉强强还可以~ 代码(搜索+剪枝)12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define MAXN 50int N;LL W, ans;LL G[MAXN], f[MAXN];//f表示“后缀和”bool cmp( LL x, LL y )&#123; return x &gt; y; &#125;void DFS( int x, LL h )&#123;//x表示当前搜的是第x件物品，h表示已经取到的总重量 while( x &lt;= N &amp;&amp; h + G[x] &gt; W ) x++;//由于是降序排序，找到第一个还能继续搬的物品 if ( x &gt; N )&#123; ans = max( ans, h ); return; &#125;//没东西了（或者没有可以搬的了），当然得回溯 for ( ; x &lt;= N; ++x )&#123; if ( h + f[x] &lt;= W )&#123; ans = max( ans, h + f[x] ); return; &#125;//剪枝~ 后面都能拿，当然要都拿来最优啦~ 这个剪枝可以看做是最优化剪枝 DFS( x + 1, h + G[x] ); &#125;&#125;int main()&#123; scanf( "%lld%d", &amp;W, &amp;N ); for ( int i = 1; i &lt;= N; ++i ) scanf( "%lld", &amp;G[i] ); sort( G + 1, G + N + 1, cmp );//剪枝~ 降序排序再搜~ for ( int i = N; i &gt;= 1; --i ) f[i] = f[i + 1] + G[i]; DFS( 1, 0 ); printf( "%lld\n", ans ); return 0;&#125; 相信大家都不会仅满足于80分~还有俩测试点呢。。。我们用一种神奇的搜索方式——双向搜索！ 也就是说，先找前半段，预处理出所有可以达到的总重量，存在一个数组F中，然后再搜索后半段，对于后半段已取的质量，在F中二分找出既满足条件，又最大的重量，加起来更新ans的值就可以了。这样复杂度就为O($2^{\frac n 2 }+2^{\frac n 2 } \times \log_2n$)基本可以满足要求。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define MAXN 50int N, M;LL W, ans;LL G[MAXN];LL F[20000000], tot;bool cmp( LL x, LL y )&#123; return x &gt; y; &#125;void DFS_1( int x, LL h )&#123;//第一次搜索，注意所有能得到的重量都要记录，所以不必剪枝 还有注意0也要记录 F[++tot] = h; while( x &lt;= M &amp;&amp; h + G[x] &gt; W ) x++; for ( ; x &lt;= M; ++x ) DFS_1( x + 1, h + G[x] );&#125;int EF( LL x )&#123;//手打二分~ int l(1), r(tot), mid, ans(1); while( l &lt;= r )&#123; mid = ( l + r ) &gt;&gt; 1; if ( F[mid] + x &lt;= W ) l = mid + 1, ans = mid; else r = mid - 1; &#125; return ans;&#125;void DFS_2( int x, LL h )&#123; ans = max( ans, h + F[EF(h)] ); while( x &lt;= N &amp;&amp; h + G[x] &gt; W ) x++; for ( ; x &lt;= N; ++x ) DFS_2( x + 1, h + G[x] );&#125;int main()&#123; scanf( "%lld%d", &amp;W, &amp;N ); M = ( N &gt;&gt; 1 ) + 2;//lyd大佬说前半段1~N/2+2最快~蒟蒻当然照做 for ( int i = 1; i &lt;= N; ++i ) scanf( "%lld", &amp;G[i] ); sort( G + 1, G + N + 1, cmp );//照样排序 DFS_1( 1, 0 ); sort( F + 1, F + tot + 1 ); tot = unique( F + 1, F + tot + 1 ) - F - 1;//排序&amp;去重 DFS_2( M + 1, 0 ); printf( "%lld\n", ans ); return 0;&#125; 搜索真是博大精深~]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>深搜</tag>
        <tag>搜索剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CH2501」矩阵距离 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fch2501-solution%2F</url>
    <content type="text"><![CDATA[CH2501 矩阵距离描述给定一个N行M列的01矩阵 A，$A[i][j]$ 与 $A[k][l]$ 之间的曼哈顿距离定义为：$dist(A[i][j],A[k][l])=|i-k|+|j-l|$ 输出一个N行M列的整数矩阵B，其中：$B[i][j]=min(1 \le x \le N,1 \le y \le M,A[x][y]=1)⁡{dist(A[i][j],A[x][y])}$即求与每个位置曼哈顿距离最近的1$N,M \le 1000$。 输入格式第一行两个整数N,M。 接下来一个N行M列的01矩阵，数字之间没有空格。 输出格式一个N行M列的矩阵B，相邻两个整数之间用一个空格隔开。 样例输入12343 4000100110110 样例输出1233 2 1 02 1 0 01 0 0 1 思路有没有觉得，有点像洪水填充？ 假设只有一个1，我们可以用广搜来实现。因为每次搜下一个位置，距离都会+1，所以队列里元素距起始点的距离是单调递增的。因此，当我们搜到一个没有被搜到的位置，直接记录最优答案即可。 但是这里有好几个1。不过这也无妨，我们把这几个1的ans初始值标记为0，把它们都push进队列，然后广搜即可。原理十分简单。 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;#define open(s) freopen( s".in", "r", stdin ), freopen( s".out", "w", stdout )#define MAXN 1005int N, M;bool a[MAXN][MAXN];int ans[MAXN][MAXN];queue&lt;int&gt; Qx, Qy;char t;int dir[4][2] = &#123; 1, 0, 0, 1, -1, 0, 0, -1 &#125;;int main()&#123; memset( ans, -1, sizeof ans ); scanf( "%d%d", &amp;N, &amp;M ); for ( int i = 1; i &lt;= N; ++i ) for ( int j = 1; j &lt;= M; ++j )&#123; while( ( t = getchar() ) != '1' &amp;&amp; t != '0' ); a[i][j] = t ^ '0'; if ( a[i][j] ) Qx.push(i), Qy.push(j), ans[i][j] = 0; &#125; int x, y, tx, ty; while( !Qx.empty() )&#123; x = Qx.front(); y = Qy.front(); Qx.pop(); Qy.pop(); for ( int i = 0; i &lt; 4; ++i )&#123; tx = x + dir[i][0]; ty = y + dir[i][1]; if ( tx &gt; 0 &amp;&amp; ty &gt; 0 &amp;&amp; tx &lt;= N &amp;&amp; ty &lt;= M &amp;&amp; ans[tx][ty] == -1 )&#123; ans[tx][ty] = ans[x][y] + 1; Qx.push(tx); Qy.push(ty); &#125; &#125; &#125; for ( int i = 1; i &lt;= N; ++i, putchar('\n') ) for ( int j = 1; j &lt;= M; ++j ) printf( "%d ", ans[i][j] ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>广搜</tag>
        <tag>Flood Fill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CH2101」可达性统计 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fch2101-solution%2F</url>
    <content type="text"><![CDATA[CH2101 可达性统计描述给定一张N个点M条边的有向无环图，分别统计从每个点出发能够到达的点的数量。N,M≤30000。 输入格式第一行两个整数N,M，接下来M行每行两个整数x,y，表示从x到y的一条有向边。 输出格式共N行，表示每个点能够到达的点的数量。 样例输入123456789101110 103 82 32 55 95 92 33 94 82 104 9 样例输出123456789101633211111 思路我们可以利用记忆化搜索，对于每个点，记录它能到达的点的集合。 至于怎么记录这个集合，我们采用bitset 1bitset&lt;MAXN&gt; f[MAXN]; 由于bitset十分省内存，30000大小就占用30000bit，不用担心炸空间。 还有，bitset支持位运算！你可以当做一个二进制数来操作，也可以当做一个bool数组，还支持各种神奇函数，十分强大。 12345bitset&lt;MAXN&gt; a, b;a[1] = 1;//当做bool数组~b[2] = 1;a = a | b;//支持位运算~printf("%llu\n", a.count());//统计1的个数~ 返回值是unsigned long long类型的 搜索过程十分简单，差不多是一个记忆化搜索模板。 P.S. 当然你也可以拓扑序DP 代码1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 30005#define MAXM 30005#define bs bitset&lt;30005&gt;int n, m;int hd[MAXN], nxt[MAXM], to[MAXM], tot;bs f[MAXN];int x, y;inline void Add( int x, int y )&#123; nxt[++tot] = hd[x]; hd[x] = tot; to[tot] = y; &#125;void DFS( int x )&#123; if ( f[x].any() ) return; f[x][x] = 1; for ( int i = hd[x]; i; i = nxt[i] ) f[x] |= ( DFS( to[i] ), f[to[i]] );&#125;int main()&#123; scanf( "%d%d", &amp;n, &amp;m ); for ( int i = 1; i &lt;= m; ++i )&#123; scanf( "%d%d", &amp;x, &amp;y ); Add( x, y ); &#125; for ( int i = 1; i &lt;= n; ++i ) printf( "%llu\n", ( DFS(i), f[i].count() ) ); return 0;&#125;]]></content>
      <tags>
        <tag>STL</tag>
        <tag>记忆化搜素</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CH2601」电路维修 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fch2601-solution%2F</url>
    <content type="text"><![CDATA[CH2601 电路维修描述Ha’nyu是来自异世界的魔女，她在漫无目的地四处漂流的时候，遇到了善良的少女Rika，从而被收留在地球上。Rika的家里有一辆飞行车。有一天飞行车的电路板突然出现了故障，导致无法启动。电路板的整体结构是一个R行C列的网格（R,C≤500），如右图所示。每个格点都是电线的接点，每个格子都包含一个电子元件。电子元件的主要部分是一个可旋转的、连接一条对角线上的两个接点的短电缆。在旋转之后，它就可以连接另一条对角线的两个接点。电路板左上角的接点接入直流电源，右下角的接点接入飞行车的发动装置。 Ha’nyu发现因为某些元件的方向不小心发生了改变，电路板可能处于断路的状态。她准备通过计算，旋转最少数量的元件，使电源与发动装置通过若干条短缆相连。不过，电路的规模实在是太大了，Ha’nyu并不擅长编程，希望你能够帮她解决这个问题。 输入格式输入文件包含多组测试数据。第一行包含一个整数T 表示测试数据的数目。对于每组测试数据，第一行包含正整数R 和C，表示电路板的行数和列数。之后R 行，每行C 个字符，字符是”/“和”\”中的一个，表示标准件的方向。 输出格式对于每组测试数据，在单独的一行输出一个正整数，表示所需的缩小旋转次数。如果无论怎样都不能使得电源和发动机之间连通，输出NO SOLUTION。 样例输入1234513 5\\/\\\\////\\\\ 样例输出11 数据范围与约定 对于40% 的数据，R,C≤5。对于100% 的数据，R,C≤500，T≤5。 样例解释样例的输入对应于题目描述中的情况。只需要按照下面的方式旋转标准件，就可以使得电源和发动机之间连通。 来源杜宇飞，石家庄二中【Nescafé 5】杯NOIP模拟赛 思路我们在格点建边，构成一个无向图。如果不用旋转就能到达，边权为0，否则为1。 然后广搜~ but 纯粹的广搜（或者SPFA?）是会炸的。。。 我得了70分。。。T了3个点。。。 我们可以考虑使用双端队列BFS 即如果边权为0，直接放到队首，如果边权为1，就和普通BFS一样放到队尾。 有时会出现这样一种情况： 最优值相同的点A，B都能更新C，A在队列中的位置在B前面。AC=1 BC=0 这样会导致最优值出现错误。所以我们还要判断能不能更新已有的点。 像上述这种情况，A更新C后，C‘会到队尾，B更新C后，C到队首，比之前的C’更快更新，C’不能再更新其他点，也就不会影响结果。 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;#define open(s) freopen( s".in", "r", stdin ), freopen( s".out", "w", stdout )#define MAXN 505int T;int R, C;char s[MAXN][MAXN];int dis[MAXN][MAXN];deque&lt;int&gt; Qx, Qy;int x, y, tx, ty, t1, t2; char t;int dir[4][2] = &#123; 1, 1, -1, -1, 1, -1, -1, 1 &#125;;int wh[4][2] = &#123; 1, 1, 0, 0, 1, 0, 0, 1 &#125;;int main()&#123; scanf( "%d", &amp;T ); while( T-- )&#123; scanf( "%d%d", &amp;R, &amp;C ); for ( int i = 1; i &lt;= R; ++i ) scanf( "%s", s[i] + 1 ); memset( dis, 0x7f, sizeof dis ); dis[0][0] = 0; Qx.push_back(0); Qy.push_back(0); while( !Qx.empty() )&#123; x = Qx.front(); y = Qy.front(); Qx.pop_front(); Qy.pop_front(); for ( int i = 0; i &lt; 4; ++i )&#123; tx = x + dir[i][0]; ty = y + dir[i][1]; t1 = x + wh[i][0]; t2 = y + wh[i][1]; t = i &lt;= 1 ? '\\' : '/'; if ( tx &gt;= 0 &amp;&amp; ty &gt;= 0 &amp;&amp; tx &lt;= R &amp;&amp; ty &lt;= C &amp;&amp; dis[tx][ty] &gt; dis[x][y] + ( s[t1][t2] != t ) )&#123; dis[tx][ty] = dis[x][y] + ( s[t1][t2] != t ); if ( s[t1][t2] != t ) Qx.push_back(tx), Qy.push_back(ty); else Qx.push_front(tx), Qy.push_front(ty); &#125; &#125; &#125; if ( dis[R][C] &gt;= 0x3f3f3f3f ) printf( "NO SOLUTION\n" ); else printf( "%d\n", dis[R][C] ); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>广搜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「CH2201」小猫爬山 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fch2201-solution%2F</url>
    <content type="text"><![CDATA[CH2201 小猫爬山背景Freda和rainbow饲养了N只小猫，这天，小猫们要去爬山。经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了（呜咕&gt;_&lt;）。 描述Freda和rainbow只好花钱让它们坐索道下山。索道上的缆车最大承重量为W，而N只小猫的重量分别是C1、C2……CN。当然，每辆缆车上的小猫的重量之和不能超过W。每租用一辆缆车，Freda和rainbow就要付1美元，所以他们想知道，最少需要付多少美元才能把这N只小猫都运送下山？ 输入格式第一行包含两个用空格隔开的整数，N和W。接下来N行每行一个整数，其中第i+1行的整数表示第i只小猫的重量Ci。 输出格式输出一个整数，最少需要多少美元，也就是最少需要多少辆缆车。 样例输入1234565 19961219941229 样例输出12 数据范围与约定 对于100%的数据，1&lt;=N&lt;=18，1&lt;=Ci&lt;=W&lt;=10^8。 来源石家庄二中【Nescafé 26】杯NOIP模拟赛T1 思路数据20-，很明显是搜索。 我们采用先花钱，再放小猫也就是说，有没有放满先不管，车先拿来，以后再继续放。这样，对于每只猫，就有两种情况： 1.坐之前就有的 2.再花1dollar 还可以加一个最优化剪枝~ 代码十分简短。。。 代码1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 22int N, W;int c[MAXN];int p[MAXN], ans;bool cmp( int x, int y )&#123; return x &gt; y; &#125;void DFS( int x, int cnt )&#123; if ( cnt &gt;= ans ) return;//最优化剪枝 if ( x &gt;= N )&#123; ans = cnt; return; &#125;//搜索边界 for ( int i = 1; i &lt;= cnt; ++i ) if ( p[i] + c[x] &lt;= W ) p[i] += c[x], DFS( x + 1, cnt ), p[i] -= c[x];//放在之前具有的索道 p[cnt + 1] = c[x]; DFS( x + 1, cnt + 1 ); p[cnt + 1] = 0;//再花1dollar&#125;int main()&#123; scanf( "%d%d", &amp;N, &amp;W ); for ( int i = 0; i &lt; N; ++i ) scanf( "%d", &amp;c[i] ); sort( c, c + N, cmp ); ans = N; DFS( 0, 0 ); printf( "%d\n", ans ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>深搜</tag>
        <tag>搜索剪枝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「黑科技」玄学优化]]></title>
    <url>%2F2019%2F01%2F23%2Fblack-technology-optimize%2F</url>
    <content type="text"><![CDATA[十分诡异的优化。。。123#pragma GCC diagnostic error "-std=c++11"#pragma GCC optimize("-fdelete-null-pointer-checks,inline-functions-called-once,-funsafe-loop-optimizations,-fexpensive-optimizations,-foptimize-sibling-calls,-ftree-switch-conversion,-finline-small-functions,inline-small-functions,-frerun-cse-after-loop,-fhoist-adjacent-loads,-findirect-inlining,-freorder-functions,no-stack-protector,-fpartial-inlining,-fsched-interblock,-fcse-follow-jumps,-fcse-skip-blocks,-falign-functions,-fstrict-overflow,-fstrict-aliasing,-fschedule-insns2,-ftree-tail-merge,inline-functions,-fschedule-insns,-freorder-blocks,-fwhole-program,-funroll-loops,-fthread-jumps,-fcrossjumping,-fcaller-saves,-fdevirtualize,-falign-labels,-falign-loops,-falign-jumps,unroll-loops,-fsched-spec,-ffast-math,Ofast,inline,-fgcse,-fgcse-lm,-fipa-sra,-ftree-pre,-ftree-vrp,-fpeephole2",3)#pragma GCC target("avx","sse2")]]></content>
      <tags>
        <tag>黑科技</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「题单」网络流『最大流/最小割』]]></title>
    <url>%2F2019%2F01%2F23%2Fproblemset-network-flow-I%2F</url>
    <content type="text"><![CDATA[由于最大流=最小割这里不另起一博客但会标记 模板/假模板 洛谷P1343 地震逃生『提高+/省选-』『最大流』 题解洛谷P2740 [USACO4.2]草地排水Drainage Ditches『提高+/省选-』『最大流』洛谷P2936 [USACO09JAN]全流Total Flow『提高+/省选-』『最大流』洛谷P3376 【模板】网络最大流『提高+/省选-』『最大流』洛谷P4001 [BJOI2006]狼抓兔子『省选+/NOI-』『最小割』UVA820 因特网带宽 Internet Bandwidth『省选+/NOI-』『最大流』 N倍经验系列I 洛谷P1402 酒店之王『省选+/NOI-』『最大流』题解洛谷P2891 [USACO07OPEN]吃饭Dining『提高+/省选-』『最大流』题解洛谷P1231 教辅的组成『提高+/省选-』『最大流』 题解大家会发现，三篇题解几乎一模一样，因为思路都一样，博主就偷懒啦。不过推荐大家看P1402 酒店之王 的题解，因为最初是给它打题解，后面修改修改当作另外两个的，不合理处相对较少，并且增加了拓展部分。 II 洛谷P2762 太空飞行计划问题『省选+/NOI-』『最小割』洛谷P3410 拍照『提高+/省选-』『最小割』 III 洛谷P4474 王者之剑『省选+/NOI-』『最小割』洛谷P2774 方格取数问题『省选+/NOI-』『最小割』 IV SPOJ300 CABLETV - Cable TV Network『NOI/NOI+/CTSC』『最大流』 恶意评分黑题)UVA1660 电视网络 Cable TV Network『省选+/NOI-』『最大流』 V SP741 STEAD - Steady Cow Assignment『省选+/NOI-』『最大流』洛谷P2857 [USACO06FEB]稳定奶牛分配Steady Cow Assignment『提高+/省选-』『最大流』感觉与下面对比可以有紫题难度呀QAQ) VI SP1693 COCONUTS - Coconuts『省选+/NOI-』『最小割』洛谷P2057 [SHOI2007]善意的投票『省选+/NOI-』『最小割』 VII 洛谷P2472 [SCOI2007]蜥蜴『省选+/NOI-』『最大流』UVA563 Crimewave『NOI/NOI+/CTSC』『最大流』恶意评分~) 其他 这里基本上按难度排序 当然指的是洛谷难度标签)洛谷P2071 座位安排『提高+/省选-』『最大流』UVA1184 Air Raid『提高+/省选-』『最大流』洛谷P1345 [USACO5.4]奶牛的电信Telecowmunication『提高+/省选-』『最小割』洛谷P2711 小行星『省选+/NOI-』『最小割』洛谷P2763 试题库问题『省选+/NOI-』『最大流』洛谷P3254 圆桌问题『省选+/NOI-』『最大流』洛谷P3153 [CQOI2009]跳舞『省选+/NOI-』『最大流』洛谷P4311 士兵占领『省选+/NOI-』『最大流』洛谷P2944 [USACO09MAR]地震损失2Earthquake Damage 2『省选+/NOI-』『最大流』洛谷P1344 [USACO4.4]追查坏牛奶Pollutant Control『省选+/NOI-』『最小割』洛谷P3866 [TJOI2009]战争游戏『省选+/NOI-』『最小割』洛谷P3171 [CQOI2015]网络吞吐量『省选+/NOI-』『最大流』洛谷P2754 [CTSC1999]家园『省选+/NOI-』『最大流』洛谷P2045 方格取数加强版『省选+/NOI-』『最大流』洛谷P3033 [USACO11NOV]牛的障碍Cow Steeplechase『省选+/NOI-』『最小割』洛谷P4174 [NOI2006]最大获利『省选+/NOI-』『最小割』洛谷P3872 [TJOI2010]电影迷『省选+/NOI-』『最小割』洛谷P3163 [CQOI2014]危桥『省选+/NOI-』『最大流』洛谷P3355 骑士共存问题『省选+/NOI-』『最小割』洛谷P4304 [TJOI2013]攻击装置『省选+/NOI-』『最小割』洛谷P2764 最小路径覆盖问题『省选+/NOI-』『最大流』洛谷P2598 [ZJOI2009]狼和羊的故事『省选+/NOI-』『最小割』洛谷P2172 [国家集训队]部落战争『省选+/NOI-』『最大流』洛谷P2805 [NOI2009]植物大战僵尸『省选+/NOI-』『最小割』SP4063 MPIGS - Sell Pigs『省选+/NOI-』『最大流』洛谷P3701 「伪模板」主席树『NOI/NOI+/CTSC』『最大流』 假黑题)洛谷P5030 长脖子鹿放置『NOI/NOI+/CTSC』『最小割』 又是假黑题)]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>网络最大流</tag>
        <tag>题单</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「题单」网络流『费用流』]]></title>
    <url>%2F2019%2F01%2F23%2Fproblemset-network-flow-II%2F</url>
    <content type="text"><![CDATA[关于费用流的一些题 模板/伪模板 洛谷P3381【模板】最小费用最大流 『提高+/省选-』 其他 洛谷P4016 负载平衡问题『提高+/省选-』洛谷P2153 [SDOI2009]晨跑『省选/NOI-』洛谷P2045 方格取数加强版『省选/NOI-』洛谷P1251 餐巾计划问题『省选/NOI-』洛谷P4014 分配问题『省选/NOI-』]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>费用流</tag>
        <tag>题单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P1343」地震逃生 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fluogu1343-solution%2F</url>
    <content type="text"><![CDATA[P1343 地震逃生题目描述汶川地震发生时，四川XX中学正在上课，一看地震发生，老师们立刻带领x名学生逃跑，整个学校可以抽象地看成一个有向图，图中有n个点，m条边。1号点为教室，n号点为安全地带，每条边都只能容纳一定量的学生，超过楼就要倒塌，由于人数太多，校长决定让同学们分成几批逃生，只有第一批学生全部逃生完毕后，第二批学生才能从1号点出发逃生，现在请你帮校长算算，每批最多能运出多少个学生，x名学生分几批才能运完。 输入输出格式输入格式：第一行3个整数n,m,x($x]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>网络流</tag>
        <tag>网络最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P1402」酒店之王 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fluogu1402-solution%2F</url>
    <content type="text"><![CDATA[P1402 酒店之王题目描述XX酒店的老板想成为酒店之王，本着这种希望，第一步要将酒店变得人性化。由于很多来住店的旅客有自己喜好的房间色调、阳光等，也有自己所爱的菜，但是该酒店只有p间房间，一天只有固定的q道不同的菜。 有一天来了n个客人，每个客人说出了自己喜欢哪些房间，喜欢哪道菜。但是很不幸，可能做不到让所有顾客满意（满意的条件是住进喜欢的房间，吃到喜欢的菜）。 这里要怎么分配，能使最多顾客满意呢？ 输入输出格式输入格式：第一行给出三个正整数表示n,p,q(&lt;=100)。 之后n行，每行p个数包含0或1，第i个数表示喜不喜欢第i个房间（1表示喜欢，0表示不喜欢）。 之后n行，每行q个数，表示喜不喜欢第i道菜。 输出格式：最大的顾客满意数。 输入输出样例输入样例#1：123452 2 21 01 01 11 1 输出样例#1：11 算法网络最大流。这里不详细讲，请大家先掌握。 思路 注意，以下出现的所有边边权皆为1，且其反向边边权为0 我们以房间、菜、人为点建图。像这样： S(=0)表示额外建的一个起始点，Ri(=i + n + n)表示第i个房间，Di(=i+n+n+p)表示第i种菜，由于人只有一个，而网络流处理只经过一个点不方便，我们采用一种神奇方法——拆点！也就是说，把一个人看做两个点，要匹配这个人必须经过这个人两点之间的边，这样就可以控制这个人只匹配一次。如图，Pi(=i)、Pi’(=i+n)表示第i个人。 然后建边。如图，将S与所有Ri相连，将所有的Di与T相连，S作为源点，T作为汇点。如果Pi喜欢Rj，就将Pi与Rj相连。如果Pi喜欢Dj，就将Dj与Pi’之间相连。当然，Pi与Pi’之间也要连一条边。 然后就可以套网络最大流辣。最后得出的答案即为满意数。 拓展有一天来了n批客人，每批客人喜欢的菜、房间都相同。第i批客人有gi位客人。其余同原题。 HINT:我们可以把每批客人当做2个点Pi、Pi’，在Pi、Pi’之间连gi条边连一条权为gi的边即可。菜、房间每种有多个同理。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;#define open(s) freopen( s".in", "r", stdin ), freopen( s".out", "w", stdout )#define MAXN 405#define MAXM 40005int n, p, q;int hd[MAXN], nxt[MAXM &lt;&lt; 1], to[MAXM &lt;&lt; 1], val[MAXM &lt;&lt; 1], tot(1);int ans, dis[MAXN];queue&lt;int&gt; Q;int x, y;int S, T;void Add( int x, int y, int z )&#123; nxt[++tot] = hd[x]; hd[x] = tot; to[tot] = y; val[tot] = z; &#125;bool BFS()&#123; while( !Q.empty() ) Q.pop(); memset( dis, 0, sizeof dis ); Q.push(S); dis[S] = 1; while( !Q.empty() )&#123; x = Q.front(); Q.pop(); for ( int i = hd[x]; i; i = nxt[i] ) if ( val[i] &amp;&amp; !dis[to[i]] )&#123; dis[to[i]] = dis[x] + 1; Q.push( to[i] ); if ( to[i] == T ) return 1; &#125; &#125; return 0;&#125;int DFS( int x, int fl )&#123; if ( x == T ) return fl; int res(fl), k; for ( int i = hd[x]; i &amp;&amp; res; i = nxt[i] )&#123; if ( val[i] &amp;&amp; dis[to[i]] == dis[x] + 1 )&#123; k = DFS( to[i], min( res, val[i] ) ); if ( !k ) dis[to[i]] = 0; val[i] -= k; val[i^1] += k; res -= k; &#125; &#125; return fl - res;&#125;int main()&#123; scanf( "%d%d%d", &amp;n, &amp;p, &amp;q ); S = 0; T = 1 + n + n + p + q; for ( int i = 1; i &lt;= n; ++i ) Add( i, i + n, 1 ), Add( i + n, i, 0 ); for ( int i = 1; i &lt;= p; ++i ) Add( S, i + n + n, 1 ), Add( i + n + n, S, 0 ); for ( int i = 1; i &lt;= q; ++i ) Add( i + n + n + p, T, 1 ), Add( T, i + n + n + p, 0 ); for ( int i = 1; i &lt;= n; ++i ) for ( int j = 1; j &lt;= p; ++j )&#123; int t; scanf( "%d", &amp;t ); if ( t ) Add( j + n + n, i, 1 ), Add( i, j + n + n, 0 ); &#125; for ( int i = 1; i &lt;= n; ++i ) for ( int j = 1; j &lt;= q; ++j )&#123; int t; scanf( "%d", &amp;t ); if ( t ) Add( i + n, j + n + n + p, 1 ), Add( j + n + n + p, i + n, 0 ); &#125; int t; while( BFS() ) while( ( t = DFS( S, 0x7f7f7f7f ) ) &gt; 0 ) ans += t; printf( "%d\n", ans ); return 0;&#125; 总结这类题目如果要用网络最大流解决，一般来说，将“选择者”放中间，并且要拆点，“被选物”放两边，直接与源点、汇点相连。但是这种做法“被选物”不能多于两种。 如果多于两种，要怎么做呢？ 我也不知道 QAQ）求教大佬QAQ]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>网络流</tag>
        <tag>网络最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P1231」教辅的组成 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fluogu1231-solution%2F</url>
    <content type="text"><![CDATA[P1231 教辅的组成题目背景滚粗了的HansBug在收拾旧语文书，然而他发现了什么奇妙的东西。 题目描述蒟蒻HansBug在一本语文书里面发现了一本答案，然而他却明明记得这书应该还包含一份练习题。然而出现在他眼前的书多得数不胜数，其中有书，有答案，有练习册。已知一个完整的书册均应该包含且仅包含一本书、一本练习册和一份答案，然而现在全都乱做了一团。许多书上面的字迹都已经模糊了，然而HansBug还是可以大致判断这是一本书还是练习册或答案，并且能够大致知道一本书和答案以及一本书和练习册的对应关系（即仅仅知道某书和某答案、某书和某练习册有可能相对应，除此以外的均不可能对应）。既然如此，HansBug想知道在这样的情况下，最多可能同时组合成多少个完整的书册。 输入输出格式输入格式：第一行包含三个正整数N1、N2、N3，分别表示书的个数、练习册的个数和答案的个数。 第二行包含一个正整数M1，表示书和练习册可能的对应关系个数。 接下来M1行每行包含两个正整数x、y，表示第x本书和第y本练习册可能对应。（$1 \le x \le N1，1\le y\le N2 $） 第M1+3行包含一个正整数M2，表述书和答案可能的对应关系个数。 接下来M2行每行包含两个正整数x、y，表示第x本书和第y本答案可能对应。（$1 \le x \le N1，1 \le y \le N3$） 输出格式：输出包含一个正整数，表示最多可能组成完整书册的数目。 输入输出样例输入样例#1：123456789101112135 3 454 32 25 25 15 351 33 12 23 34 3 输出样例#1：12 说明样例说明：如题，N1=5，N2=3，N3=4，表示书有5本、练习册有3本、答案有4本。 M1=5，表示书和练习册共有5个可能的对应关系，分别为：书4和练习册3、书2和练习册2、书5和练习册2、书5和练习册1以及书5和练习册3。 M2=5，表示数和答案共有5个可能的对应关系，分别为：书1和答案3、书3和答案1、书2和答案2、书3和答案3以及书4和答案3。 所以，以上情况的话最多可以同时配成两个书册，分别为：书2+练习册2+答案2、书4+练习册3+答案3。 数据规模： 对于数据点1, 2, 3，$M1，M2\le 20$ 对于数据点4~10，$M1，M2 \le 20000$ 算法网络最大流。这里不详细讲，请大家先掌握。 思路 注意，以下出现的所有边边权皆为1，且其反向边边权为0 我们以书、练习册、答案为点建图。像这样： S(=0)表示额外建的一个起始点，Ri(=i+N1+N1)表示第i本练习册，Di(=i+N1+N1+N2)表示第i本答案，由于书只有一本，而网络流处理只经过一个点不方便，我们采用一种神奇方法——拆点！也就是说，把一本书看做两个点，要匹配这本书必须经过这本书两点之间的边，这样就可以控制这本书只匹配一次。如图，Pi(=i)、Pi’(=i+N1)表示第i本书。 然后建边。如图，将S与所有Ri相连，将所有的Di与T相连，S作为源点，T作为汇点。如果Pi能匹配Rj，就将Pi与Rj相连。如果Pi能匹配Dj，就将Dj与Pi’之间相连。当然，Pi与Pi’之间也要连一条边。 然后就可以套网络最大流辣。最后得出的答案即为最多的数目。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;bits/stdc++.h&gt;using namespace std;#define open(s) freopen( s".in", "r", stdin ), freopen( s".out", "w", stdout )#define MAXN 40005#define MAXM 150000int N1, N2, N3;int M1, M2;int hd[MAXN], nxt[MAXM &lt;&lt; 1], to[MAXM &lt;&lt; 1], val[MAXM &lt;&lt; 1], tot(1);int ans, dis[MAXN];queue&lt;int&gt; Q;bool vis[MAXN];int x, y;int S, T;void Add( int x, int y, int z )&#123; nxt[++tot] = hd[x]; hd[x] = tot; to[tot] = y; val[tot] = z; &#125;bool BFS()&#123; while( !Q.empty() ) Q.pop(); memset( dis, 0, sizeof dis ); Q.push(S); dis[S] = 1; while( !Q.empty() )&#123; x = Q.front(); Q.pop(); for ( int i = hd[x]; i; i = nxt[i] ) if ( val[i] &amp;&amp; !dis[to[i]] )&#123; dis[to[i]] = dis[x] + 1; Q.push( to[i] ); if ( to[i] == T ) return 1; &#125; &#125; return 0;&#125;int DFS( int x, int fl )&#123; if ( x == T ) return fl; int res(fl), k; for ( int i = hd[x]; i &amp;&amp; res; i = nxt[i] )&#123; if ( val[i] &amp;&amp; dis[to[i]] == dis[x] + 1 )&#123; k = DFS( to[i], min( res, val[i] ) ); if ( !k ) dis[to[i]] = 0; val[i] -= k; val[i^1] += k; res -= k; &#125; &#125; return fl - res;&#125;int main()&#123; scanf( "%d%d%d", &amp;N1, &amp;N2, &amp;N3 ); scanf( "%d", &amp;M1 ); for ( int i = 1; i &lt;= M1; ++i )&#123; scanf( "%d%d", &amp;x, &amp;y ); Add( y + N1, x, 1 ); Add( x, y + N1, 0 ); &#125; scanf( "%d", &amp;M2 ); for ( int i = 1; i &lt;= M2; ++i )&#123; scanf( "%d%d", &amp;x, &amp;y ); Add( x + N1 + N2 + N3, y + N1 + N2, 1 ); Add( y + N1 + N2, x + N1 + N2 + N3, 0 ); &#125; S = 0; T = 1 + N1 + N1 + N2 + N3; for ( int i = 1; i &lt;= N2; ++i ) Add( S, i + N1, 1 ), Add( i + N1, S, 0 ); for ( int i = 1; i &lt;= N3; ++i ) Add( i + N1 + N2, T, 1 ), Add( T, i + N1 + N2, 0 ); for ( int i = 1; i &lt;= N1; ++i ) Add( i, i + N1 + N2 + N3, 1 ), Add( i + N1 + N2 + N3, i, 0 ); int t; while( BFS() ) while( ( t = DFS( S, 0x7f7f7f7f ) ) &gt; 0 ) ans += t; printf( "%d\n", ans ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>网络流</tag>
        <tag>网络最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P2891」[USACO07OPEN]吃饭Dining 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fluogu2891-solution%2F</url>
    <content type="text"><![CDATA[P2891 [USACO07OPEN]吃饭Dining题目描述Cows are such finicky eaters. Each cow has a preference for certain foods and drinks, and she will consume no others. Farmer John has cooked fabulous meals for his cows, but he forgot to check his menu against their preferences. Although he might not be able to stuff everybody, he wants to give a complete meal of both food and drink to as many cows as possible. Farmer John has cooked F (1 ≤ F ≤ 100) types of foods and prepared D (1 ≤ D ≤ 100) types of drinks. Each of his N (1 ≤ N ≤ 100) cows has decided whether she is willing to eat a particular food or drink a particular drink. Farmer John must assign a food type and a drink type to each cow to maximize the number of cows who get both. Each dish or drink can only be consumed by one cow (i.e., once food type 2 is assigned to a cow, no other cow can be assigned food type 2). 翻译有F种食物和D种饮料，每种食物或饮料只能供一头牛享用，且每头牛只享用一种食物和一种饮料。现在有N头牛，每头牛都有自己喜欢的食物种类列表和饮料种类列表，问最多能使几头牛同时享用到自己喜欢的食物和饮料。（$1 \le F \le 100, 1 \le D \le 100, 1 \le N \le 100$） 输入输出格式输入格式：Line 1: Three space-separated integers: N, F, and D Lines 2..N+1: Each line i starts with a two integers Fi and Di, the number of dishes that cow i likes and the number of drinks that cow i likes. The next Fi integers denote the dishes that cow i will eat, and the Di integers following that denote the drinks that cow i will drink. 输出格式：Line 1: A single integer that is the maximum number of cows that can be fed both food and drink that conform to their wishes 输入输出样例输入样例#1：123454 3 32 2 1 2 3 12 2 2 3 1 22 2 1 3 1 22 1 1 3 3 输出样例#1：13 算法网络最大流。这里不详细讲，请大家先掌握。 思路 注意，以下出现的所有边边权皆为1，且其反向边边权为0 我们以牛、食物、饮料为点建图。像这样： S(=0)表示额外建的一个起始点，Ri(=i+N+N)表示第i个菜，Di(=i+N+N+F)表示第i种饮料，由于牛只有一头，而网络流处理只经过一个点不方便，我们采用一种神奇方法——拆点！也就是说，把一头牛看做两个点，要匹配这头牛必须经过这头牛两点之间的边，这样就可以控制这头牛只匹配一次。如图，Pi(=i)、Pi’(=i+N)表示第i头牛。 然后建边。如图，将S与所有Ri相连，将所有的Di与T相连，S作为源点，T作为汇点。如果Pi喜欢Rj，就将Pi与Rj相连。如果Pi喜欢Dj，就将Dj与Pi’之间相连。当然，Pi与Pi’之间也要连一条边。 然后就可以套网络最大流辣。最后得出的答案即为满足的牛数。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;#define open(s) freopen( s".in", "r", stdin ), freopen( s".out", "w", stdout )#define MAXN 405#define MAXM 40005int N, F, D;int hd[MAXN], nxt[MAXM &lt;&lt; 1], to[MAXM &lt;&lt; 1], val[MAXM &lt;&lt; 1], tot(1);int pre[MAXN], e[MAXN], ans, dis[MAXN];queue&lt;int&gt; Q;int x, y;int S, T;void Add( int x, int y, int z )&#123; nxt[++tot] = hd[x]; hd[x] = tot; to[tot] = y; val[tot] = z; &#125;bool BFS()&#123; while( !Q.empty() ) Q.pop(); memset( dis, 0, sizeof dis ); Q.push(S); dis[S] = 1; while( !Q.empty() )&#123; x = Q.front(); Q.pop(); for ( int i = hd[x]; i; i = nxt[i] ) if ( val[i] &amp;&amp; !dis[to[i]] )&#123; dis[to[i]] = dis[x] + 1; Q.push( to[i] ); if ( to[i] == T ) return 1; &#125; &#125; return 0;&#125;int DFS( int x, int fl )&#123; if ( x == T ) return fl; int res(fl), k; for ( int i = hd[x]; i &amp;&amp; res; i = nxt[i] )&#123; if ( val[i] &amp;&amp; dis[to[i]] == dis[x] + 1 )&#123; k = DFS( to[i], min( res, val[i] ) ); if ( !k ) dis[to[i]] = 0; val[i] -= k; val[i^1] += k; res -= k; &#125; &#125; return fl - res;&#125;int main()&#123; scanf( "%d%d%d", &amp;N, &amp;F, &amp;D ); S = 0; T = N + N + F + D + 1; for ( int i = 1; i &lt;= N; ++i ) Add( i, i + N, 1 ), Add( i + N, i, 0 ); for ( int i = 1; i &lt;= F; ++i ) Add( S, i + N + N, 1 ), Add( i + N + N, S, 0 ); for ( int i = 1; i &lt;= D; ++i ) Add( i + N + N + F, T, 1 ), Add( T, i + N + N + F, 0 ); for ( int i = 1; i &lt;= N; ++i )&#123; int f, d, x; scanf( "%d%d", &amp;f, &amp;d ); for ( int j = 1; j &lt;= f; ++j ) scanf( "%d", &amp;x ), Add( x + N + N, i, 1 ), Add( i, x + N + N, 0 ); for ( int j = 1; j &lt;= d; ++j ) scanf( "%d", &amp;x ), Add( i + N, x + N + N + F, 1 ), Add( x + N + N + F, i + N, 0 ); &#125; int t; while( BFS() ) while( ( t = DFS( S, 0x7f7f7f7f ) ) &gt; 0 ) ans += t; printf( "%d\n", ans ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>网络流</tag>
        <tag>网络最大流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P3469」[POI2008]BLO-Blockade 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fluogu3469-solution%2F</url>
    <content type="text"><![CDATA[P3469[POI2008]LO-Blockade题意翻译在Byteotia有n个城镇。 一些城镇之间由无向边连接。 在城镇外没有十字路口，尽管可能有桥，隧道或者高架公路（反正不考虑这些）。每两个城镇之间至多只有一条直接连接的道路。人们可以从任意一个城镇直接或间接到达另一个城镇。 每个城镇都有一个公民，他们被孤独所困扰。事实证明，每个公民都想拜访其他所有公民一次（在主人所在的城镇）。所以，一共会有n*（n-1）次拜访。 不幸的是，一个程序员总罢工正在进行中，那些程序员迫切要求购买某个软件。 作为抗议行动，程序员们计划封锁一些城镇，阻止人们进入，离开或者路过那里。 正如我们所说，他们正在讨论选择哪些城镇会导致最严重的后果。 编写一个程序： 读入Byteotia的道路系统，对于每个被决定的城镇，如果它被封锁，有多少访问不会发生，输出结果。 输入输出格式第一行读入n，m，分别是城镇数目和道路数目 城镇编号1~n 接下来m行每行两个数字a,b，表示a和b之间有有一条无向边 输出n行，每行一个数字，为第i个城镇被锁时不能发生的访问的数量。 题目描述There are exactly nn towns in Byteotia. Some towns are connected by bidirectional roads. There are no crossroads outside towns, though there may be bridges, tunnels and flyovers. Each pair of towns may be connected by at most one direct road. One can get from any town to any other-directly or indirectly. Each town has exactly one citizen. For that reason the citizens suffer from loneliness. It turns out that each citizen would like to pay a visit to every other citizen (in his host’s hometown), and do it exactly once. So exactly n\cdot (n-1)n⋅(n−1) visits should take place. That’s right, should. Unfortunately, a general strike of programmers, who demand an emergency purchase of software, is under way. As an act of protest, the programmers plan to block one town of Byteotia, preventing entering it, leaving it, and even passing through. As we speak, they are debating which town to choose so that the consequences are most severe. Task Write a programme that: reads the Byteotian road system’s description from the standard input, for each town determines, how many visits could take place if this town were not blocked by programmers, writes out the outcome to the standard output. 给定一张无向图，求每个点被封锁之后有多少个有序点对(x,y)(x!=y,1&lt;=x,y&lt;=n)满足x无法到达y 输入输出格式输入格式：In the first line of the standard input there are two positive integers: $n$ and $m$ ($1\le n\le 100000, 1\le m\le 500000$ )denoting the number of towns and roads, respectively. The towns are numbered from 1 to $n$. The following mm lines contain descriptions of the roads. Each line contains two integers $a$ and $b$ ($1\le a&lt; b\le n$) and denotes a direct road between towns numbered $a$ and $b$. 输出格式：Your programme should write out exactly nn integers to the standard output, one number per line. The i^{th}ithline should contain the number of visits that could not take place if the programmers blocked the town no. $i$ 输入输出样例输入样例#1：1234565 51 22 31 33 44 5 输出样例#1：123458816148 算法Tarjan找割点 思路 I.设在搜索树T中以x为根的树包含的点集为SubTree(x)。 II.这里去除割点可以理解为删除与该点相连的所有边。 III.这里提到的连通块是指当某一割点去除时：1.其中任何两个点都能相互到达 2.没有更大的连通块包含该块 当然，根据II，我们把单独的X也看做一个连通块 IV.为了方便，我们直接将(x,y)(满足x不能到y)成为“点对” V. ~S：S的补集，A^B：在A中不包括点B的所有点构成的集合 利用Tarjan查找割点的同时，我们可以找出该割点X去除后剩余的连通块（有两种情况，一种是在SubTree(X)^X中，另一种是~SubTree(X)）。 只要能够理解割点的求解过程，这还是很好理解的，这里不再赘述。 然后要求“点对”。 对于一个点X，不管是否为割点，点对(i,j)为“点对”，当且仅当 i != j且i、j属于两个不同的连通块 根据定义，很容易证明这个推论。 代码有多种写法，这里选取我能想到的最简单的写法。 在枚举连通块时，ans加上s[to[i]] * ( n - s[to[i]] )，即一次性处理一个连通块的所有点，它们与其他不属于这个连通块的点都构成“点对”。当然，别忘了X与~SubTree(X)。 代码12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define MAXN 100005#define MAXM 1000005int n, m;int hd[MAXN], nxt[MAXM], to[MAXM], tot;int dfn[MAXN], low[MAXN], root, num;LL ans[MAXN];int s[MAXN];void Add( int x, int y )&#123; nxt[++tot] = hd[x]; hd[x] = tot; to[tot] = y; &#125;void DFS( int x )&#123; s[x] = 1; low[x] = dfn[x] = ++num; LL b(0); for ( int i = hd[x]; i; i = nxt[i] )&#123; if ( !dfn[to[i]] )&#123; DFS( to[i] ); s[x] += s[to[i]]; low[x] = min( low[x], low[to[i]] ); if ( dfn[x] &lt;= low[to[i]] ) ans[x] += (long long)s[to[i]] * ( n - s[to[i]] ), b += s[to[i]];//发现新的连通块！ &#125; else low[x] = min( low[x], dfn[to[i]] ); &#125; ans[x] += (long long)( n - b - 1 ) * ( b + 1 ) + ( n - 1 );//算上~SubTree(X)与X&#125;int main()&#123; scanf( "%d%d", &amp;n, &amp;m ); for ( int i = 1; i &lt;= m; ++i )&#123; int x, y; scanf( "%d%d", &amp;x, &amp;y ); Add( x, y ); Add( y, x ); &#125; DFS( 1 ); for ( int i = 1; i &lt;= n; ++i ) printf( "%lld\n", ans[i] ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>割点</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「错题集」网络流]]></title>
    <url>%2F2019%2F01%2F23%2Ferrors-network-flow%2F</url>
    <content type="text"><![CDATA[这里贴些曾经写网络流时犯过的沙雕错误QAQ可能对自己、对找不出网络流错误的人有些帮助 网络最大流/最小割I 写前向星时，tot初值误赋为0错误:1int hd[MAXN], nxt[MAXM], to[MAXM], val[MAXM], tot; 正确：1int hd[MAXN], nxt[MAXM], to[MAXM], val[MAXM], tot(1); II 在深搜中，枚举点时，为了方便，终点误用全局变量存储错误原因：深搜后全局变量的值会改变 错误：12345678910111213int DFS( int x, int fl )&#123; if ( x == T ) return fl; int res(fl), k; for ( int i = hd[x]; i &amp;&amp; res; i = nxt[i] )&#123; y = to[i]; if ( val[i] &amp;&amp; d[to[i]] == d[x] + 1 )&#123; k = DFS( to[i], min( res, val[i] ) ); if ( !k ) d[y] = 0; val[i] -= k; val[i^1] += k; res -= k; &#125; &#125; return fl - res;&#125; 正确123456789101112int DFS( int x, int fl )&#123; if ( x == T ) return fl; int res(fl), k; for ( int i = hd[x]; i &amp;&amp; res; i = nxt[i] )&#123; if ( val[i] &amp;&amp; d[to[i]] == d[x] + 1 )&#123; k = DFS( to[i], min( res, val[i] ) ); if ( !k ) d[to[i]] = 0; val[i] -= k; val[i^1] += k; res -= k; &#125; &#125; return fl - res;&#125; III 变量搞错第一种 点、边下标弄错 第二种二维矩阵时N、M弄反 第三种to[i]与i搞不清 IV ans没赋初值不说了。。。丢脸 V 源点搞错都用了变量S了，咋还写成1 丢脸 VI 忘了建反边从今天开始，网络最大流/最小割的建边都这么写1234void Add( int x, int y, int z )&#123; nxt[++tot] = hd[x]; hd[x] = tot; to[tot] = y; val[tot] = z; nxt[++tot] = hd[y]; hd[y] = tot; to[tot] = x; val[tot] = 0;&#125; VII 宽搜时忘了pop丢脸 VIII DFS时res为0时未及时退出错误：123456789101112int DFS( int x, int fl )&#123; if ( x == T ) return fl; int res(fl), k; for ( int &amp;i = HD[x]; i; i = nxt[i] )&#123; if ( val[i] &amp;&amp; d[to[i]] == d[x] + 1 )&#123; k = DFS( to[i], min( res, val[i] ) ); if ( !k ) d[to[i]] = 0; res -= k; val[i] -= k; val[i ^ 1] += k; &#125; &#125; return fl - res;&#125; 正确：123456789101112int DFS( int x, int fl )&#123; if ( x == T ) return fl; int res(fl), k; for ( int &amp;i = HD[x]; i &amp;&amp; res; i = nxt[i] )&#123; if ( val[i] &amp;&amp; d[to[i]] == d[x] + 1 )&#123; k = DFS( to[i], min( res, val[i] ) ); if ( !k ) d[to[i]] = 0; res -= k; val[i] -= k; val[i ^ 1] += k; &#125; &#125; return fl - res;&#125; 后果：超时 IX d数组没有初始化错误: 1234567891011121314bool BFS()&#123; while( !Q.empty() ) Q.pop(); d[S] = 1; Q.push(S); while( !Q.empty() )&#123; int t(Q.front()); Q.pop(); for ( int i = hd[t]; i; i = nxt[i] )&#123; if ( val[i] &amp;&amp; !d[to[i]] )&#123; Q.push(to[i]); d[to[i]] = d[t] + 1; if ( to[i] == T ) return 1; &#125; &#125; &#125; return 0;&#125; 正确: 123456789101112131415bool BFS()&#123; while( !Q.empty() ) Q.pop(); memset( d, 0, sizeof d ); d[S] = 1; Q.push(S); while( !Q.empty() )&#123; int t(Q.front()); Q.pop(); for ( int i = hd[t]; i; i = nxt[i] )&#123; if ( val[i] &amp;&amp; !d[to[i]] )&#123; Q.push(to[i]); d[to[i]] = d[t] + 1; if ( to[i] == T ) return 1; &#125; &#125; &#125; return 0;&#125; X 深搜时到达汇点忘记returnWrong: 1234567891011int DFS( int x, int fl )&#123; int res(fl), k; for ( int i = hd[x]; i &amp;&amp; res; i = nxt[i] )&#123; if ( val[i] &amp;&amp; d[to[i]] == d[x] + 1 )&#123; k = DFS( to[i], min( val[i], res ) ); if ( k &lt;= 0 ) d[to[i]] = 0; res -= k; val[i] -= k; val[i ^ 1] += k; &#125; &#125; return fl - res;&#125; Correct: 123456789101112int DFS( int x, int fl )&#123; if ( x == T ) return fl; int res(fl), k; for ( int i = hd[x]; i &amp;&amp; res; i = nxt[i] )&#123; if ( val[i] &amp;&amp; d[to[i]] == d[x] + 1 )&#123; k = DFS( to[i], min( val[i], res ) ); if ( k &lt;= 0 ) d[to[i]] = 0; res -= k; val[i] -= k; val[i ^ 1] += k; &#125; &#125; return fl - res;&#125; 结果。。。输出都是0.。。。 XI 宽搜时忘记push源点我真的智障了1d[S] = 1; Q.push(S); XII 忘了开long long丢脸 看看数据范围 XIII 数组开小了做网络流要空间何用！数组下标加个0 XIV 没看见双向边题目看清楚 T-T]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>错题集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVA1328」「POJ1961」 Period 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fuva1328-solution%2F</url>
    <content type="text"><![CDATA[UVA1328 Period其他链接：luogu UVA1328 POJ1961 For each prefix of a given string S with N characters (each character has an ASCII code between 97 and 126, inclusive), we want to know whether the prefix is a periodic string. That is, for each i ($2 \le i \le N$)we want to know the largest $K &gt; 1$ (if there is one) such that the prefix of $S$ with length i can be written as $A^K$, that is A concatenated K times, for some string A. Of course, we also want to know the period K. InputThe input file consists of several test cases. Each test case consists of two lines. The first one contains $N$ ($2 \le N \le 1000000$) the size of the string $S$. The second line contains the string S. The input file ends with a line, having the number zero on it. OutputFor each test case, output ‘Test case #’ and the consecutive test case number on a single line; then, for each prefix with length i that has a period K &gt; 1, output the prefix size i and the period K separated by a single space; the prefix sizes must be in increasing order. Print a blank line after each test case. Sample Input123453aaa12aabaabaabaab0 Sample Output12345678Test case #12 23 3Test case #22 26 29 312 4 翻译(louhc自己翻译的啦 luogu ID Sinner也是我) 题意描述对于给定字符串S的每个前缀，我们想知道它是否为周期串。也就还是说，它是否为某一字符串重复连接而成（必须至少重复2次）（即循环节）。 输入多组数据。每组数据，第一行一个数字表示长度，第二行一个字符串S。 输出输出前缀长度与循环节数量。 说明字符串长度不超过1000000，仅由小写字母组成。对于每个前缀，只要输出长度最小的循环节 写在前面 Substr(i, j)表示s的子串s[i~j] 这里s的下标从1开始 i的上一个匹配：一个位置j,满足Substr(1, j) == Substr(i - j + 1,N) 下面黑线表示字符串，其中红框中包含的字符相等（这是自然，同一个字符串嘛）。 j还要满足 （注意啦 两条黑线表示同一个字符串，只是位置不同） （其实这也算是KMP的复习吧。。。） 下面图中红框中都表示相同 算法KMP。由于这不是KMP学习笔记，不仔细讲，请先学会KMP。 思路这题也可算是“拍大腿”系列了吧？其实你看看下面代码，真的很简单，关键就是如何推出这个结论。 （我不用next，用了f做数组名，希望大家不要看不习惯，意思是一样的） 粉色部分也表示相同。这很明显，因为字符是一一对应的嘛(同一个字符串位置相同、长度相同的字符串当然一样)。 由于红框内完全相同，还可以—— 继续对应！灰线表示在原字符串中是对应的。 还可以对应！ 可能就会出现这样的情况！(当然可能最前面不够长度) 因此，只要f[i]&gt;0，i前面肯定有循环节！（只不过不知道是否完整，bb|abb|abb|abb这样也看作是）而且循环节长度为i - f[i] + 1！。因此只要判断循环节长度能否将长度整除即可。具体请见代码（真的短）。 代码1234567891011121314151617181920212223#include&lt;cstdio&gt;using namespace std;#define MAXN 1000005int N, T;char s[MAXN];int f[MAXN];int main()&#123; while( ~scanf( "%d", &amp;N ) &amp;&amp; N )&#123; scanf( "%s", s + 1 ); T++; printf( "Test case #%d\n", T ); int t(0); f[1] = 0; for ( int i = 2; i &lt;= N; ++i )&#123; while ( s[i] != s[t + 1] &amp;&amp; t ) t = f[t]; if ( s[i] == s[t + 1] ) t++; f[i] = t; if ( f[i] != 0 &amp;&amp; i % ( i - f[i] ) == 0 ) printf( "%d %d\n", i, i / ( i - f[i] ) ); &#125; putchar('\n'); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>字符串</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P3931」 SAC E#1 - 一道难题 Tree]]></title>
    <url>%2F2019%2F01%2F23%2Fluogu3931-solution%2F</url>
    <content type="text"><![CDATA[P3931 SAC E#1 - 一道难题 Tree题目背景冴月麟和魏潇承是好朋友。 题目描述冴月麟为了守护幻想乡，而制造了幻想乡的倒影，将真实的幻想乡封印了。任何人都无法进入真实的幻想乡了，但是她给前来救她的魏潇承留了一个线索。 她设置了一棵树（有根）。树的每一条边上具有割掉该边的代价。 魏潇承需要计算出割开这棵树的最小代价，这就是冴月麟和魏潇承约定的小秘密。 帮帮魏潇承吧。 注：所谓割开一棵有根树，就是删除若干条边，使得任何任何叶子节点和根节点不连通。 输入输出格式输入格式：输入第一行两个整数n，S表示树的节点个数和根。 接下来n-1行每行三个整数a、b、c，表示a、b之间有一条代价为c的边。 输出格式：输出包含一行，一个整数，表示所求最小代价。 输入输出样例输入样例#1：12344 11 2 1 1 3 11 4 1 输出样例#1：13 输入样例#2：12344 11 2 32 3 13 4 2 输出样例#2：11 说明对于20%的数据，n &lt;= 10 对于50%的数据，n &lt;= 1000 对于100%的数据，n &lt;= 100000 写在前面lovny(YKJ):用树形DP呀？ Venus(LYT):还在做网络流？ 。。。 没必要！完全没必要！这道题DFS就够了！ 思路很明显，要使一个叶子节点到不了祖先，有两种选择： 他的某个祖先到不了根节点 它父亲-&gt;它 删了 然后我们可以遍历一遍树。 DFS( x, fa ) = $\Sigma$min(DFS( i, x ) ( 存在边x-&gt;i), val(x-&gt;i) ) fa是为了避免搜到父亲节点。 若x为叶子节点，直接返回INF 也就是说，要么断开x-&gt;i让i到不了根节点，下面就不用再删边了，要么让i到的了根节点，在下面某处再断开。 他没说c的范围，保险起见开long long 代码很短。。。真的很短。。。 代码12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;#define open(s) freopen( s".in", "r", stdin ), freopen( s".out", "w", stdout )#define MAXN 100005#define MAXM 200005#define LL long longint n, S;int hd[MAXN], to[MAXM], nxt[MAXM], tot(1);LL val[MAXM];void Add( int x, int y, int z )&#123; nxt[++tot] = hd[x]; hd[x] = tot; val[tot] = z; to[tot] = y; nxt[++tot] = hd[y]; hd[y] = tot; val[tot] = z; to[tot] = x;&#125;LL DFS( int x, int fa )&#123; LL ans(0); bool flg(0); for ( int i = hd[x]; i; i = nxt[i] ) if ( to[i] != fa ) ans += min( DFS( to[i], x ), val[i] ), flg = 1; if ( !flg ) return LONG_LONG_MAX; return ans;&#125;int main()&#123; scanf( "%d%d", &amp;n, &amp;S ); for ( int i = 1; i &lt; n; ++i )&#123; int x, y; LL z; scanf( "%d%d%lld", &amp;x, &amp;y, &amp;z ); Add( x, y, z ); &#125; printf( "%lld\n", DFS( S, S ) ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>深搜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P1198」 [JSOI2008]最大数 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fluogu1198-solution%2F</url>
    <content type="text"><![CDATA[P1198 [JSOI2008]最大数题目描述现在请求你维护一个数列，要求提供以下两种操作： 1、 查询操作。 语法：Q L 功能：查询当前数列中末尾L个数中的最大的数，并输出这个数的值。 限制：$L$不超过当前数列的长度。$(L &gt; 0)$ 2、 插入操作。 语法：A n 功能：将$n$加上$t$，其中$t$是最近一次查询操作的答案（如果还未执行过查询操作，则$t=0$)，并将所得结果对一个固定的常数$D$取模，将所得答案插入到数列的末尾。 限制：$n$是整数（可能为负数）并且在长整范围内。 注意：初始时数列是空的，没有一个数。 输入输出格式输入格式：第一行两个整数，$M$和$D$，其中$M$表示操作的个数$(M \le 200,000)$，$D$如上文中所述，满足$(0&lt;D&lt;2,000,000,000)$ 接下来的$M$行，每行一个字符串，描述一个具体的操作。语法如上文所述。 输出格式：对于每一个查询操作，你应该按照顺序依次输出结果，每个结果占一行。 输入输出样例输入样例#1：1234565 100A 96Q 1A 97Q 1Q 2 输出样例#1：123969396 说明[JSOI2008]本题数据已加强 思路很明显，这道题的一般思路是线段树。但是，这道题用ST表也可以做！！！ 一般来说，我们写ST表都是$f[i][j] =\max\text{ a[i] , a[i+1],······,a[i+j \times 2-1] }$ 但是，它是从后插入元素的，如果按照一般思路，正着做的话，最坏情况下就要改$nlgn$ 次，还不如暴力呢！但是，我们可以倒过来$f[i][j] = \max\text{a[i] , a[i-1] ,······, a[i - j \times 2 + 1]}$，这样，每次插入仅需修改$lgn$个元素了。 这种解法十分神奇，结束了“ST表不能修改”的历史。在这道题中，合理地使用ST表还是能得出很简洁的解法的。 代码1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 200005#define LL long longint M;LL D;char opt;LL t, x;LL a[MAXN], f[MAXN][20], N;int main()&#123; scanf( "%d%lld", &amp;M, &amp;D ); while ( M-- )&#123; while( ( opt = getchar() ) != 'A' &amp;&amp; opt != 'Q' ); scanf( "%lld", &amp;x ); if ( opt == 'A' )&#123; a[++N] = ( x + t ) % D; f[N][0] = a[N]; for ( int i = 1; ( 1 &lt;&lt; i ) &lt;= N; ++i ) f[N][i] = max( f[N][i - 1], f[N - (1 &lt;&lt; ( i - 1 ))][i - 1] ); &#125;else&#123; int len = min( x, N ); x = N - len + 1; int tt((LL)floor(log(len) / log(2))); printf( "%lld\n", ( t = max( f[N][tt], f[x + ( 1 &lt;&lt; tt ) - 1][tt] ) ) ); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>ST表</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P1262」间谍网络 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fluogu1262-solution%2F</url>
    <content type="text"><![CDATA[P1262 间谍网络题目描述由于外国间谍的大量渗入，国家安全正处于高度的危机之中。如果A间谍手中掌握着关于B间谍的犯罪证据，则称A可以揭发B。有些间谍收受贿赂，只要给他们一定数量的美元，他们就愿意交出手中掌握的全部情报。所以，如果我们能够收买一些间谍的话，我们就可能控制间谍网中的每一分子。因为一旦我们逮捕了一个间谍，他手中掌握的情报都将归我们所有，这样就有可能逮捕新的间谍，掌握新的情报。 我们的反间谍机关提供了一份资料，包括所有已知的受贿的间谍，以及他们愿意收受的具体数额。同时我们还知道哪些间谍手中具体掌握了哪些间谍的资料。假设总共有n个间谍(n不超过3000)，每个间谍分别用1到3000的整数来标识。 请根据这份资料，判断我们是否有可能控制全部的间谍，如果可以，求出我们所需要支付的最少资金。否则，输出不能被控制的一个间谍。 输入输出格式输入格式：第一行只有一个整数n。 第二行是整数p。表示愿意被收买的人数，1≤p≤n。 接下来的p行，每行有两个整数，第一个数是一个愿意被收买的间谍的编号，第二个数表示他将会被收买的数额。这个数额不超过20000。 紧跟着一行只有一个整数r，1≤r≤8000。然后r行，每行两个正整数，表示数对(A, B)，A间谍掌握B间谍的证据。 输出格式：如果可以控制所有间谍，第一行输出YES，并在第二行输出所需要支付的贿金最小值。否则输出NO，并在第二行输出不能控制的间谍中，编号最小的间谍编号。 输入输出样例输入样例#1：1234567321 102 10021 32 3 输出样例#1：12YES110 输入样例#2：1234567421 1004 20021 23 4 输出样例#2：12NO3 算法缩点 思路如果A掌握B的信息，那么我们就建有向边A-&gt;B，构成一个图。每个点的权值就是收买该间谍需要花的钱，如果不能收买，那就赋为$\infty$。我们的任务就是取Sum(点权)最少的若干个点，以这几个点为起点，能遍历整张图。当然，Sum(点权)不能为$\infty$。（注意下 $\infty + \infty = \infty ,\infty + x = \infty$） 因为在一个强连通分量中，任何一个点都能遍历到每个节点。所以，对于一个强连通分量，完全可以看成一个点，点权为该强连通分量包含的点的最小点权。 所以缩点即可。以下所说的点均为“缩”过的点。 入度为0的点绝对要取，而取来后绝对已经所有点都能访问到。 这个很好证明。入度为0的点绝对要取是不难理解的，因为它不可能被其他点访问。由于缩点后的图不可能构成环，所以入度不为0的点肯定可以被已经访问过的点访问到。 注意下不能被控制的(编号最小)点不一定入度为0。 如这组数据: Input Data12345678414 10042 42 14 31 3 Output Data12NO1 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 3005#define MAXM 8005int n, p, r;int hd[MAXN], nxt[MAXM], to[MAXM], tot(1);int dfn[MAXN], low[MAXN], num, stk[MAXN], tp, c[MAXN], cnt;int pr[MAXN], f[MAXN];int x, y;bool vs[MAXN], v[MAXN];void Add( int x, int y)&#123; nxt[++tot] = hd[x]; hd[x] = tot; to[tot] = y; &#125;void Tarjan( int x )&#123; dfn[x] = low[x] = ++tot; stk[++tp] = x; for ( int i = hd[x]; i; i = nxt[i] )&#123; if ( !dfn[to[i]] ) Tarjan( to[i] ), low[x] = min( low[x], low[to[i]] ); else if ( !c[to[i]] ) low[x] = min( low[x], dfn[to[i]] ); &#125; if ( low[x] == dfn[x] )&#123; c[x] = ++cnt; f[cnt] = pr[x]; while( stk[tp] != x ) f[cnt] = min( f[cnt], pr[stk[tp]] ), c[stk[tp--]] = cnt; tp--; &#125;&#125;//记忆化搜索//Memory search void DFS( int x )&#123; v[x] = 1; for ( int i = hd[x]; i; i = nxt[i] ) if ( !v[to[i]] ) DFS( to[i] );&#125;int main()&#123; scanf( "%d%d", &amp;n, &amp;p ); for ( int i = 1; i &lt;= n; ++i ) pr[i] = INT_MAX; for ( int i = 1; i &lt;= p; ++i ) scanf( "%d%d", &amp;x, &amp;y ), pr[x] = y; scanf( "%d", &amp;r ); for ( int i = 1; i &lt;= r; ++i ) scanf( "%d%d", &amp;x, &amp;y ), Add( x, y ); // 先判断是否能控制全部间谍,即把所有能收买的间谍都收买 // To see whether all spies can be under control. for ( int i = 1; i &lt;= n; ++i ) if ( pr[i] &lt; INT_MAX &amp;&amp; !v[i] ) DFS( i ); for ( int i = 1; i &lt;= n; ++i ) if ( !v[i] )&#123; printf( "NO\n%d\n", i ); return 0; &#125; //------------------判断结束 Ended-------------------- //因为已经确定所有间谍都能被控制,那就大胆地取来所有入度为0的节点(当然,是缩点后的图) // Because all spies can be controled, get all ponits which has no indegree(After Tarjan, certainly). for ( int i = 1; i &lt;= n; ++i ) if ( !c[i] ) Tarjan( i ); //当然, 并不需要建边，可以直接判断入度是否为0 //Certainly, it is unnecessary to connect edges.You can DIRECTLY know whether a point has no indegree. for ( int i = 1; i &lt;= n; ++i ) for ( int j = hd[i]; j; j = nxt[j] ) if ( c[i] != c[to[j]] ) vs[c[to[j]]] = 1; int ans(0); for ( int i = 1; i &lt;= cnt; ++i ) if ( !vs[i] ) ans += f[i]; printf( "YES\n%d\n", ans ); return 0;&#125; 注：为了防止中文乱码情况，代码注释给出英文版。]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>Tarjan</tag>
        <tag>缩点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「黑科技」增加栈的空间]]></title>
    <url>%2F2019%2F01%2F23%2Fblack-technology-add-stack%2F</url>
    <content type="text"><![CDATA[如果爆栈了。。。。试试这个？？ 我都没试过） 12345#pragma comment(linker, "/STACK:102400000,102400000")int size = 256 &lt;&lt; 20; // 256MBchar *p = (char*)malloc(size) + size;__asm__("movl %0, %%esp\n" :: "r"(p));]]></content>
      <tags>
        <tag>黑科技</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「整理」图论技巧]]></title>
    <url>%2F2019%2F01%2F23%2Fnotes-graph-theory-miscellaneous%2F</url>
    <content type="text"><![CDATA[待填坑目标：下个学期开学前填完坑！ I 网络流1 关于双向边当要求边是双向时，我们可以将正边、反向边的权值都赋为流量，而不必赋为0。这一点很明显，因为对于两条边，起始点fr、终点to相同，我们可以把这两条边合并。即变成一条权值为这两条边权之和的边。本来是这样——1234567void Add( int x, int y, int z )&#123; nxt[++tot] = hd[x]; hd[x] = tot; to[tot] = y; val[tot] = z; nxt[++tot] = hd[y]; hd[y] = tot; to[tot] = x; val[tot] = 0;&#125;Add( x, y, z );//step 1Add( y, x, z );//step 2 很明显，step 1建的正边与step 2建的反向边可以合并。合并后权值即为z。可以简写成这样——123456void Add( int x, int y, int z )&#123; nxt[++tot] = hd[x]; hd[x] = tot; to[tot] = y; val[tot] = z; nxt[++tot] = hd[y]; hd[y] = tot; to[tot] = x; val[tot] = z;&#125;Add( x, y, z ); 这样可以省一半空间，而达到的效果是相同的。]]></content>
      <tags>
        <tag>待填坑</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「整理」杂项]]></title>
    <url>%2F2019%2F01%2F23%2Fnotes-miscellaneous%2F</url>
    <content type="text"><![CDATA[壹对于一个坐标系中的两个矩形，左下角、右上角的坐标分别为(X1, Y1)(X2, Y2)(X3, Y3)(X4, Y4)。那么，如果这两个矩形相交，它们重叠部分矩形的左下角、右上角必为(min_2{X1~4}, min_2(Y1~4)),(min_3{X1~4}, min_3{Y1~Y4} )。其中，min_i表示第i小的数。 题目：CF1080C Masha and two friends 目标：30~50行代码之内解决了！@hovny童鞋弄了100多行）]]></content>
      <tags>
        <tag>待填坑</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「学习笔记」勾股数组]]></title>
    <url>%2F2019%2F01%2F23%2Fnotes-pythagorean-triple%2F</url>
    <content type="text"><![CDATA[本文(目前)进入洛谷日报2019-01-05队列洛谷日报126期 写在前面我们大概老早就知道勾股定理，它大概就长这样： a^2+b^2=c^2嗯，的确够简单的。 而且我们清楚地知道它的一个基本应用——知道$Rt\Delta$的两边长，求第三边。这大概初一就学了。 对于不知道勾股定理的童鞋们，不了解没关系，因为这里没有三角形，也不是探讨怎么求第三边，我们只探讨勾股数组。 这里的$a \equiv b(mod c)$其实就是$a\%c=b\%c$，a|b其实就是$b\%a=0$，希望小白们不要看不懂。 如果真的看不懂，可以先学习同余、约数、素数的知识。 勾股数组什么事都得从定义开始。来看看百度百科教会我们什么。 定义——勾股数组 一般地，若三角形三边长a，b，c都是正整数，且满足a，b的平方和等于c的平方，那么数组（a，b，c）称为勾股数组。勾股数组是人们为了解出满足勾股定理的不定方程的所有整数解而创造的概念。 嗯，够简单的。不过有些人总是喜欢把它弄得高大尚些，把它叫做“毕达哥拉斯三元组”，其实是一个玩意儿，只是后者听起来更加牛。这不必深究，知道它就是勾股数组即可。而勾股数组也就是把三个数a,b,c($a^2+b^2=c^2$)用小括号括起来而已。很简单吧？我们举几个栗子—— a b c 3 4 5 5 12 13 6 8 10 7 24 25 诶，(3,4,5)、(6,8,10)看着好像！emmm 实际上它们的本质都是勾三股四弦五 这样就不好玩了嘛）很明显，如果一个勾股数组中每个数同乘一个正整数，得到的三元组还是一个勾股数组。It’s very easy.这里省略证明过程。 所以说，勾股数组有无穷个。这就不好玩了嘛，只要知道一组勾股数组，就可以推出inf个勾股数组。。。 最有意义的勾股数组，就是其他勾股数组$\times d(d &gt; 1))$不能得到的勾股数组。只要找到它们，其他的勾股数组都可以由它们乘某个数表示出来。 因此，我们引入本原勾股数组的概念。不过很遗憾，百度百科词条里没有。 定义——本原勾股数组 本原勾股数组(简写为PPT)是一个三元组(a,b,c)，其中a,b,c没有公因数，且满足$a^2+b^2=c^2$ ——摘自Joseph H. Silverman《A Friendly Introduction To Number Theory》 $\small \text{插句小广告，这本书对于学习数论还是很不错的，中文译名为《数论概论》。}$ 给出一些本原勾股数组。 (3,4,5)(5,12,13)(8,15,17)(7,24,25)…… 它有一些有趣的性质。如果你仔细观察，你可能会发现前两个数似乎总是一奇一偶。。。 这个命题是正确的，来看看如何证明。 当a、b均为偶数时，c必然为偶数，它显然不是一个本原勾股数组，a、b、c有公因数2。当a、b均为奇数时，c必然为偶数，设$a=2x+1,b=2y+1,c=2z$。然后我们就可以通过$\frac{a^2+b^2}2$、$\frac{c^2}2$奇偶性得出这也不成立。请读者自行完成证明。 如何找本原勾股数组只要找出本原勾股数组，其它勾股数组都可以求出。如何找呢？ 为了便于大家理解，这里写的详细些） 为了方便，我们认为本原勾股数组(a,b,c)中，a为奇数，b为偶数，c为奇数。 $a^2+b^2=c^2$$a^2=c^2-b^2=(c+b)(c-b)$ 我们从这方面考虑。(c+b)与(c-b)不应该存在&gt;1的公约数。 证明：$\text{设}d|(c+b)\text{且}d|(c-b)$$\text{则}d|(c+b+c-b),d|(2c)$$d|(c+b-c+b),d|(2b)$$d^2|a^2\text{即}d|a$$\because c\%2=1,b\%2=0$$\therefore (b+c)\%2=1$$\therefore d\text{不可能为偶数，否则}d|(c+b)\text{不成立}$$\therefore d|b,d|c$$\because (a,b,c)\text{是本原勾股数组}$$\therefore gcd(a,b,c)=1$$\therefore d=1$ 我们知道，任何一个大于1的正整数都可以表示成固定几个素数的积，也就是长这模样—— $a=p_1^{k1}\times p_2^{k2}\times p_3^{k3}\times p_4^{k4}\text{……}$ $a^2$既然为平方数，那么如果把$a^2$分解质因数，对于任意ki，都有$ki \equiv0(mod 2)$。 前面提过，gcd((c+b),(c-b))=1，所以如果$p_1|(c+b)$，$p_1|(c-b)$是不可能成立的。 我们暂时抛开繁琐的证明，尝试想象。假设你的手里有一个数$a^2$。看看能不能把它分解成2个没有公因数的数。 啊，不错，分成的这两个数就是(c+b)与(c-b)。要怎么分呢？我们举个栗子。试试分解$10^2$? 先分解质因数。$10^2=2^2 \times 5^2$ 我们选取一些质数给(c+b)，剩下的质数全部给(c-b) $\color{red} \text{值得注意的是，我们仅探讨正整数范围内，分解要满足(c+b)&gt;(c-b),并且都是偶数}$ 嗯，这好像只有一种分法$\to c-b=2^2,c+b=5^2$ 大家可以自己再选几个数，动手尝试。我们可以发现，$c-b$如果含有质因数p,$c-b$肯定也含有因数$p^2$。$c+b$也是如此。所以，$(c-b)$与$(c+b)$一定是完全平方数。 来吧，冲向胜利！ 我们设$s^2=c+b,t^2=c-b(s&gt;b)$ 我们把上面俩式子加一加、减一减——哇！ $2c={s^2+t^2},c=\frac {s^2+t^2}2$$2b={s^2-t^2},b=\frac {s^2-t^2}2$ $\because a^2=(c+b)\times(c-b)$$\therefore a^2=s^2\times t^2$$\therefore a=st$ 勾股数组定理每个本原勾股数组(a,b,c)(其中a为奇数，b为偶数)，都可从如下公式得出。 $\large a=st,b=\frac {s^2-t^2}2,c=\frac {s^2+t^2}2$ 其中$s &gt;t \ge 0$是任意没有公因数的奇数。 当然，以上证明是不完整的。我们还要证明a、b、c没有公因数。 我们运用反证法，假设$gcd(st,\frac{s^2-t^2}2,\frac{s^2+t^2}2)\not=1$ 我们假设质数$p|(st)$,$p$肯定为$s$或$t$的一个质因数。 假设$p$为$s$的一个质因数，$p$肯定不为$t$的质因数。这十分明显，因为s、r互质嘛） $\frac{s^2-t^2}2=\frac{(s+t)(s-t)}2$ 由$s\%p=0,t\%p\not=0$可知$(s+t)\%p\not=0,(s-t)\%p\not=0$ $\therefore (\frac{s^2+t^2}2)\%p\not=0$ 若$p$为$t$的质因数，证明过程几乎和上面一模一样，请读者自行完成。 所以，对于$st$的任意质因数，都不能整除$\frac{s^2-t^2}2$,即$gcd(st,\frac{s^2-t^2}2)=1$ 综上所述，$gcd(st,\frac{s^2-t^2}2,\frac{s^2+t^2}2)\not=1$不成立，原命题正确。 QED. 如何找勾股数组我们会找本原勾股数组，自然找出了所有勾股数组。 不过，还有一种神奇的方法，已知$c$，可以在$O(\sqrt c)$的时间内求出满足$a^2+b^2=c^2$的$a$、$b$个数。 这里放个链接，里面讲的还是很不错的QAQ(肯定讲的比我好)，强烈建议童鞋们去Have a look。顺便切道紫题P2508 [HAOI2008]圆上的整点。 前置知识高斯整数 高斯整数（gaussian integer）是实数部分（实部）和虚数部分（虚部）都是整数的复数。也就是复平面中点集{a+bi|a,b 都是整数}。所有高斯整数组成了一个整环，写作Z。它是个不可以转成有序环的欧几里德整环，所以是唯一因子分解整环。 也就是在这个整环中，如同整数集一样，可以存在唯一因子分解定理。 ——摘自百度百科 费马平方和定理 奇素数p可以表示为两个正整数的平方和，当且仅当p是4k+1型的。并且在不考虑两个正整数顺序的情况下，这个表示方法唯一。——摘自上面链接的评论奇质数能表示为两个平方数之和的充分必要条件是该质数被4除余1——摘自百度百科 由于费马平方和定理证明比较复杂，我找到的一些简单的证明都是片面或错误的，完全的证明似乎要分5步，请自行了解，这里不仔细讲。 $a^2+b^2=c^2$，或者更广泛地，$a^2+b^2=c(\text{a、b、c都为整数(不一定是正的)})$(这里我们选后者为例)可以转换为在平面直角坐标系中，一个以O为圆心、以$\sqrt c$为圆心的圆经过几个格点。(这里为了更方便，a、b、c都为整数，不一定要正整数，可以是0、负整数)。 我们把圆放在复数平面中(x轴为实数轴，y轴为虚数轴)。 然后就有惊喜。注意：以下叙述都是在复数平面中，不再是平面直角坐标系） 我们举个例子——$c=25$ 在上面那个链接视频中提到XX的模，我的理解为XX与原点的距离） 很明显，以$ \sqrt c$为半径的圆经过的格点有$(0+5i),(3+4i),(4+3i),(5+0i),(4-3i),(3-4i),(0-5i),(-3-4i),(-4-3i),(-5+0i),(-4+3i),(-3+4i)$共12个。$(3+4i),(3-4i)$这类关于实数轴对称的点互为“复共轨”。$(3+4i)$的模是5，设它与实数轴呈$\alpha$,$(3-4i)$的模也是5，它与实数轴呈$-\alpha$，很明显，它们相乘得到的结果与实数轴呈$\alpha - \alpha=0$度，而$(3+4i)(3-4i)$的模(其实和数值是一样的)为$25$，也就是$c$。很明显，像这样格点(也就是(a+bi)(a-bi)=c)都是在圆上的。这样，问题就转换为多少个高斯整数与其复共轨之积为$c$。 怎么解决呢？这就用到前置知识中的费马平方和定理，不熟悉的童鞋可以再去看看。 我们把不能再分解的高斯整数称为“高斯素数”。事实上，高斯素数有3种： 4k+3型的素数 4k+1型素数分解出的两个高斯整数 2 根据费马平方和定理，一个4k+1型的素数可以分解成$(a+bi)(a-bi)$，很明显，这两个素数互为复共轨。 如果一个数质因子中只有4k+1型的素数，像我们举例的25，那就好办了。 像这样，将它分解成若干高斯素数的乘积(很明显，这是唯一的)，并将互为复共轨的一对高斯素数写两边，左边所有高斯素数的乘积与右边的乘积互为复共轨。要使左右乘积继续保持互为复共轨，只能交换一对互为复共轨的高斯素数的位置（这个不难理解）。我们可以这样考虑，对于相同的高斯素数(我指的是成对的)，（就比如$(1+2i)$），它在左边可以放0个，放1个，放2个……当然，不是你想放就随便放的，把1个放到左边的同时，要把它的复共轨移一个到右边，以保持左右乘积仍互为复共轨。这样，如果总共有p个，就有(p+1)种放法。然后继续处理下一个高斯素数(当然，处理过一个高斯素数，不必再处理它的复共轨)。最后，为了避免重复，我们只取左边的乘积作为结果。然鹅，事情并非这么简单。如果你这么算，25得到的结果为$(2+1)=3$。才这么点？事实上，如果你在左、右分别乘上-1与-1、i与-i、-i与i，得到的结果是不同的，而且很显然，它们都是对的。但是它们的本质是相同的。就好比$3\times4=12$，$(-3)\times(-4)=12$一样。所以，最后的结果要乘4。 4k+3型的素数已经是高斯素数，而且它的复共轨就是本身，因此，只能将它平均分配给左边和右边。如果某个这种素数有奇数个，不能平均分配给左右，那很遗憾，一个解也没有。 对于素数2，它能分解成两个高斯素数$(1-i)(1+i)$，但是，你会发现，$-i\times(1-i)=(1+i)$，如果将$(1-i)$与$(1+i)$互换位置，就相当于一个乘$-i$，另一个乘$i$，它们的本质还是没有变，所以，素数2不影响结果。 来看看[HAOI2008]圆上的整点，因为这题中半径r为正整数，所以$r^2$所含的$4k+3$都是成对出现的，也就是说如果$c^2\%p=0$，那么$c^2\%p^2=0$，所以直接忽略$2$与$4k+3$型素数。如何处理$4k+1$的素数，请参照上文。（找质因数不必讲了吧 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long longLL R, N, ans(1);int main()&#123; scanf( "%lld", &amp;R ); N = R; if ( R == 0 )&#123; printf( "1\n" ); return 0; &#125;//点圆 while( R % 2 == 0 ) R &gt;&gt;= 1;//质因数2不会影响答案 for ( LL i = 3; i * i &lt;= N; i += 2 )&#123; LL cnt(0); while( R % i == 0 ) cnt++, R /= i;//数出i的幂 if ( i % 4 == 1 ) ans *= ( cnt * 2 + 1 );//i是可以分解成2个高斯素数的质因数，而且在N中它的幂是cnt,它在N^2中它的幂就是2*cnt。 &#125; //很明显，&gt; sqrt(N) 的质因数最多有一个 if ( R &gt; 1 &amp;&amp; R % 4 == 1 ) ans *= 3; //3 = 1 * 2 + 1 printf( "%lld", ans &lt;&lt; 2 ); //*1, *(-1), *i, *(-i) return 0;&#125; 一些其他性质这里还是假设本原勾股数组(a,b,c)中，a为奇数。 $c-a=2t^2,t\text{为一整数}$ 这个证明思路与上面十分相似。只要把$a^2$移到右边instead of $b^2$ 即可。 Very easy. 给个开头，请自行证明。当然，这也能在所有勾股数组中适用) b^2=c^2-a^2=(c+a)(c-a) $a \equiv 0(mod 3)\text{或}b \equiv 0(mod 3)$ 这里感谢@LJC00118Rank1奆佬教会我如何证明。这里声明一下，我绝对没有照搬照抄) 证明：有一个定理$a^2\%3=0\text{或}1$，这十分好证，分类讨论即可，这里省略证明。 假设该定理不成立，即$a \not= 0\text{且}b\not=0$$\therefore a^2\%3=1$$b^2\%3=1$$\therefore(a^2+b^2)\%3=2$$\therefore c^2\%3=2$这与$c^2\%3=0\text{或}1$矛盾，因此该定理成立QED. 还有两条不常用的性质，了解即可。 $a^4b^4+b^4c^4+c^4a^4=L^2$ $a^8+b^8+c^8=2L^2$ 关于费马大定理费马在某本书的边沿上写道。 不可能将一个3次方分成两个3次方之和；一个4次方不可能写成两个4次方之和；一般地，任何高于2次的幂不可能写成两个同次幂之和.我已发现一个美妙的证明，这里空白太小写不下 也就是说，$a^n+b^n=c^n(n&gt;2)$没有正整数解。这就是赫赫有名的费马大定理。 W(￣_￣)W。。。这是一个世纪难题，1986年才被解决。。。大家了解即可，了解即可，如果您证出来了，我只能膜拜大仙。如果真的碰到类似于这样的式子，直接拿出来用就可以了，不要傻fufu地去证明。 最后的补充这里再增加一些知识点。这里，我们通过其他方法推出勾股数组定理。 $a^2+b^2=c^2 \to (\frac ac)^2+(\frac bc)^2=1$ 这样就转换为如何找出$x^2+y^2=1$的所有有理数解 我们以(0,0)为圆心，r=1为半径画圆。 很明显，点(1,0)是一个解。我们过点(1,0)作直线y=mx-m 然后就可以解方程组辣 $m(x-1)=y$ $x^2+y^2=1$ 得$(m^2+1)x^2-2m^2x+m^2-1=0$ 由于x=1是一个解，我们可以将式子分解。 得到$(x-1)[(m^2+1)x-(m^2 - 1)]$ 算了半天 呼。。。) $(m^2+1)x-(m^2-1)=0$ $(m^2+1)x=m^2-1$ $x=\frac{m^2-1}{m^2+1}$ $y=\frac {-2m}{m^2+1}$ 当然，如果选取(-1, 0)也是可以的，这样求出来的答案有点不一样。 $x=\frac{1-m^2}{1+m^2}$ $y=\frac {2m}{1+m^2}$ 这两个式子几乎是等效的。如果设前一个式子中的$m$为$m_1$，后一个为$m_2$ 当$m_1=-\frac 1 {m_2}$时，这两个式子求出的坐标是一样的。（当然，前提是m不为0） 十分神奇，right？通过这种方式，还可以用来描述所有勾股数组。 我们令$m=\frac vu$ 代入求值（下面的式子）—— $ \huge x=\frac{1-m^2}{1+m^2}=\frac{1-(\frac vu)^2}{1+(\frac vu)^2}=\frac{u^2-v^2}{u^2+v^2}$ $\huge y = \frac{2(\frac vu)}{1+(\frac vu)^2}=\frac{2uv}{u^2+v^2}$ 这样我们得到一组勾股数。 $(2uv,u^2-v^2,u^2+v^2)$ 之前忘了说明这是有理数，现在补上。 给大家一个表格(来源:https://www.bilibili.com/video/av29019452/?p=9)也就是说，有理数(RATIONAL)与有理数经过加减乘除运算后还是有理数，由于平方运算可以看成一个有理数自己乘自己，属于乘法 （整数次幂都可以看成乘法），所以，上述式子原来的变量只涉及实数的加、减、乘、除运算，得到的结果还是有理数。只要你定义的m满足是有理数，上面提及的所有变量都是有理数。 所有勾股数组都可以通过该式推出。当然，有一些限制） 我们发现，如果设$u=\frac{s+t}2,v=\frac{s-t}2$,又可以与之前的勾股数组定理相结合。 当然，更大的圆也可以算，请自己尝试—— 这些图除了“如何找勾股数组”那张 都是自己画的QAQ 用英文的主要原因是字体不支持中文QAQ Updata上面一共8张图，1张在“如何找勾股数组”，7张在“最后的补充”，图挂了请联系我QAQ。上面都是用sm.ms图床。 12345678910111213141516171819sm.ms图床链接https://i.loli.net/2018/12/30/5c285ea779436.pnghttps://i.loli.net/2018/12/30/5c285ea85c2bd.pnghttps://i.loli.net/2018/12/30/5c285ea8d289d.pnghttps://i.loli.net/2018/12/30/5c285ea8d5012.pnghttps://i.loli.net/2018/12/30/5c285ea90cb8e.pnghttps://i.loli.net/2018/12/30/5c285ea91d846.pnghttps://i.loli.net/2018/12/30/5c285ea950d09.png2019.1.1https://i.loli.net/2019/01/01/5c2b3ddc42c9a.png洛谷图床不知道出了什么bug或浏览器有啥问题，上传不了QAQ博客园图床链接https://img2018.cnblogs.com/blog/1431616/201812/1431616-20181230132203024-266798052.pnghttps://img2018.cnblogs.com/blog/1431616/201812/1431616-20181230125844216-71658072.pnghttps://img2018.cnblogs.com/blog/1431616/201812/1431616-20181230125847902-1635489484.pnghttps://img2018.cnblogs.com/blog/1431616/201812/1431616-20181230125853033-143786982.pnghttps://img2018.cnblogs.com/blog/1431616/201812/1431616-20181230125900917-1173607715.pnghttps://img2018.cnblogs.com/blog/1431616/201812/1431616-20181230125856960-1997045235.pnghttps://img2018.cnblogs.com/blog/1431616/201812/1431616-20181230125904730-441530535.png 最后的最后由于我很弱，所以可能会出错，欢迎指正错误QAQ。 今天就讲到这里了，这里骗个赞。]]></content>
      <tags>
        <tag>数学,数论</tag>
        <tag>勾股数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「学习笔记」同余]]></title>
    <url>%2F2019%2F01%2F23%2Fnotes-congruence-modulo%2F</url>
    <content type="text"><![CDATA[留坑中 基础同余这种东西还是十分基础的，内容比多项式简单多了。。。 基础部分也不多，只要掌握以下几个式子就OK了。 也比较好推，这里不再赘述。 如果$a \% p = b \% p$($\%$表示取模),我们就可以记作$a\equiv b (\mod p)$如果$a$与$b$互质,我们可以记作$a \perp b$我们把$a$与$b$的最大公约数记为$\gcd(a, b)$ \forall a \equiv b ( \mod p ), b \equiv c ( \mod p ),\text{有}a \equiv c ( \mod p )\\ \forall a \equiv b ( \mod p ),c \in \mathbb{Z},\text{有}a \pm c \equiv b \pm c ( \mod p )\\ \forall a \equiv b ( \mod p ),c \in \mathbb{Z},\text{有}a \times c \equiv b \times c ( \mod p )\\ \forall a \equiv b ( \mod p ),c \in \mathbb{Z},c \perp p,c |\gcd(a, b),\text{有}\frac ac \equiv \frac bc ( \mod p )\\ \forall a \equiv b ( \mod p ),c | \gcd( a, b, c ),\text{有}\frac ac \equiv \frac bc ( \mod \frac pc )欧几里得与扩展欧几里得(gcd&amp;exgcd)欧几里得算法欧几里得算法用于求最大公约数。 \forall \gcd( a, b ) = c, a > b,\text{有} \gcd( a - b, b ) = c证明: \because \gcd( a, b ) = c \\ \therefore c | a,c | b \\ \therefore c | ( a - b ), c | b \\ \therefore c | gcd( a - b, b ) \\ \text{此时我们已经完成一半了,接下来我们要证明不存在}(a-b)\text{和}b\text{之间没有更大的公约数} \\ \text{假设}d > c, d | ( a - b ), d | b \\ \therefore d | a \\ \therefore \gcd( a, b ) = d > c \therefore \text{假设不成立,原命题成立}然后我们就可以写代码辣qwq 1int gcd( int a, int b )&#123; return b ? gcd( b, a % b ) : a; &#125; 高精度怎么办呢？用python或java 就有一种神奇的操作叫更相减损术,就是$\gcd( a, b ) = \gcd( a - b, b )$ 但是你会发现,更相减损术的复杂度不太对,一个$gcd( 1, 1e9 )$就能卡得TLE。 还有一种算法叫stein,也避免了乘法、取余运算,写起来也很好写但是我不会。先留个坑,以后慢慢更(gu)。 根据裴蜀/贝祖定理(这个不懂没关系,知道结论就好),$\forall c = \gcd( a, b ), \text{存在} x, y \in \mathbb{Z}, \text{使得}ax + by = c$ 但是怎么求$x,y$呢？（先咕着。。。 扩展欧几里得算法练习CF510D 提示:裴蜀定理+DP 中国剩余定理与扩展中国剩余定理(crt&amp;excrt)乘法逆元乘法逆元是个十分神奇的东西$QwQ$ 说的通俗一点，整数$x$的逆元在模$p$意义下可以当做$\frac 1x$来使用，记做$x^{-1}(\mod p)$，或直接简写为$x^{-1}$。 很明显$x\times x^{-1}\equiv 1(\mod p)$，因此我们可以直接用扩欧或费马小定理求解（如果$p$是质数）即可。 还有，如果$x$与$p$不互质，$x^{-1}(\mod p)$是不存在的。 扩欧的代码就不给出了，自己解同余方程即可。 用费马小定理直接算$x^{p-2}$即可。因为$x^{p-1}\equiv 1(\mod p)$，所以$x^{p-2}\equiv x^{-1}(\mod p)$，但是p必须是质数,p必须是质数,p必须是质数 12#define LL long longinline LL inv( LL x )&#123; return Pow( x, p - 2 ); &#125; // Pow是快速幂,自己打 你以为逆元就这么完了吗？没有！ 线性求par1比如，让你求出$1…p-1$所有的逆元？ p \% i + i\times \lfloor \frac pi \rfloor \equiv 0(\mod p) (\text{十分基本的操作})\\ (p \% i)\times i^{-1} + \lfloor \frac pi \rfloor \equiv 0(\mod p)(\text{同乘}i^{-1})\\ i^{-1}\equiv -\lfloor \frac pi \rfloor \times (p \% i)^{-1}这样我们就得到递推式—— $inv[i]=(p - \lfloor \frac pi \rfloor)\times inv[p \% i]$ 然后$inv[1]=1$,就可以求解啦！ 12inv[1] = 1;for ( int i = 2; i &lt; p; ++i ) inv[i] = ( p - p / i ) * inv[p % i] % p; 很简单吧QwQ。 part2来个更通用的，O(N)求出N个数的逆元？(source) 先求出前缀积$s$,和前缀积的逆元$sv$。前缀积的逆元可以倒推求。 然后很明显，$a[i]$的逆元即为$s[i] \times sv[i-1]$。 123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long long#define rgt register#define p 1000000007#define MAXN 5000005#define getchar() ( ( p1 == p2 ? p2 = bf + fread( bf, 1, 1 &lt;&lt; 21, stdin ), p1 = bf : p1 ) == p2 ? EOF : *p1++ )char bf[1 &lt;&lt; 21], *p1, *p2;template&lt;typename T&gt;inline void read( rgt T &amp;x )&#123; x = 0; rgt char t(getchar()), flg(0); for ( ; !isdigit(t); t = getchar() ) flg = t == '-'; for ( ; isdigit(t); t = getchar() ) x = x * 10 + ( t &amp; 15 ); flg ? x = -x : 0;&#125;int N; LL a[MAXN], s[MAXN], sv[MAXN], ans(0);inline LL Pow( LL x, LL y )&#123; LL ans(1); for ( ; y; y &gt;&gt;= 1, x = x * x % p ) ( y &amp; 1 ) ? ans = ans * x % p : 0; return ans; &#125;int main()&#123; read(N), s[0] = 1; for ( rgt int i = 1; i &lt;= N; ++i ) read(a[i]), s[i] = a[i] * s[i - 1] % p; sv[N] = Pow( s[N], p - 2 ); for ( rgt int i = N - 1; i; --i ) sv[i] = sv[i + 1] * a[i + 1] % p; for ( rgt int i = 1; i &lt;= N; ++i ) ans = ( ans * 998244353 + s[i - 1] * sv[i] ) % p; printf( "%lld\n", ans ); return 0;&#125; 很简单吧QwQ。 模板loj #110. 乘法逆元 = luogu P3811 loj #152. 乘法逆元 2 …]]></content>
      <tags>
        <tag>数学,数论</tag>
        <tag>同余</tag>
        <tag>gcd,exgcd</tag>
        <tag>crt,excrt</tag>
        <tag>BSGS,exBSGS</tag>
        <tag>原根</tag>
        <tag>乘法逆元</tag>
        <tag>待填坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「学习笔记」 FHQ Treap]]></title>
    <url>%2F2019%2F01%2F23%2Fnotes-fhq-treap%2F</url>
    <content type="text"><![CDATA[FHQ TreapFHQ Treap （%%%发明者范浩强年年NOI金牌）是一种神奇的数据结构，也叫非旋Treap，它不像Treap zig zag搞不清楚（所以叫非旋嘛），也不像Splay完全看不懂，而且它能完成Treap与Splay能完成的所有事，代码短，理解也容易。 基本操作FHQ Treap和Treap很像，都是给每个节点一个随机的权值，使它满足堆的性质。建议先了解Treap（没必要实现，懂得原理即可）。不过，如果有两个节点值相同，FHQ Treap不会用一个数组cnt记录个数，而是直接再开一个节点。 FHQ的基本操作只有两个：Split与Merge。 Split表示把一棵树分成两棵，Merge表示把一棵树合并成一棵。 变量&amp;函数约定123456int L[MAXN], R[MAXN], sz[MAXN], rk[MAXN], val[MAXN], tot;int root;int New( int v )&#123; return val[++tot] = v, rk[tot] = rand(), L[tot] = R[tot] = 0, sz[tot] = 1, tot; &#125;#define Updata(x) sz[x] = sz[L[x]] + sz[R[x]] + 1 没写成结构体，没写成指针。 $L[i]$表示$i$的左儿子，$R[i]$表示$i$的右儿子，$sz[i]$表示以$i$为根的子树包含的节点数，$rk[i]$表示为了保持平衡随机赋予的权值，$val[i]$表示该节点保存的值，$tot$表示节点数，$root$表示当前的根节点。 $New(v)$表示新建一个值为$v$的节点（可以看成一棵只有一个节点平衡树） $Updata(x)$表示更新节点$x$的$sz$ 提醒：这里“值”与“权值”是不一样的，“值”表示节点保存的值，“权值“仅仅用于维持平衡，注意区分 Split怎么分割呢？ 常见的分割方法有两种，一种是按值分，一种是按排名分（实现差不多，这里只讲按值分）。 先来看看定义。 1void Split( int c, int k, int &amp;x, int &amp;y ); c表示当前要分割的树的根节点，并且把值$\le k$的节点分割出来，构成一棵树，把$x$赋为根节点，其他节点另外构成一棵树，把$y$赋为其根节点。$x$、$y$用引用(&amp;)更方便处理。 对于当前的树，如果根节点$c$的值$\le k$，$c$的左子树也全部$\le k$，所以我们可以把$x$赋为$c$，保留左子树，将右子树$\le k$的部分分割出来作为$x$的右子树。剩下的部分自然也就是在$&gt; k$的部分。$&gt;k$的情况同理。具体我们用递归实现。 123456void Split( int c, int k, int &amp;x, int &amp;y )&#123; if ( c == 0 )&#123; x = y = 0; return; &#125;//如果当前处理的树为空，分出的两个子树当然也为空，所以直接赋值返回。 if ( val[c] &lt;= k ) x = c, Split( R[c], k, R[x], y );//如果根节点值小于等于k，把x赋为c，继续处理右子树，并把小于等于k的部分分到x的右子树，其他分到y else y = c, Split( L[c], k, x, L[y] ); Updata(c);//别忘了更新sz&#125; Merge上面分割的操作不会改变堆的性质与二叉查找树的性质，但是在合并的时候要注意保持堆的性质。 1void Merge( int &amp;c, int x, int y ); 表示把以$x$和$y$为根节点的树合并，将$c$赋为根节点。 注意：上面分割时x的所有节点的值都小于y的，合并时也要注意x的所有节点小于等于y，否则会出错 由于$x$与$y$的权值在两颗树中是最大的，所以合并后的树根节点不是$x$就是$y$。所以比较$x$与$y$的权值就可以判断谁为根节点。 假设以$x$为根。因为保证$x$的所有节点的值都小于等于$y$的，所以$y$肯定会合并在$x$的右子树。所以，我们不用动$x$的左子树，合并$x$的右子树与$y$作为$x$的右子树。$y$为根时同理。这样，就巧妙完成了同时维护堆的性质与二叉查找树的性质。 我们还是用递归。 123456void Merge( int &amp;c, int x, int y )&#123; if ( !x || !y )&#123; c = x | y; return; &#125; if ( rk[x] &gt;= rk[y] ) c = x, Merge( R[x], R[c], y ); else c = y, Merge( L[y], x, L[c] ); Updata(c);&#125; 我刚开始也理解不了这两种操作。主要瓶颈在难以想象。其实可以看做只处理当前的，未处理的留到下一步，反正操作方法都一样。 剩下的都可以用这两种操作实现。 插入操作直接把它分成$\le v$的树和$&gt; v$的树，将新建的节点与$\le v$的树合并，再与$&gt;y$树合并即可。 1234567//opt 1void Ins( int v )&#123; int x, y, z(New(v)); Split( root, v, x, y ); Merge( x, x, z ); Merge( root, x, y );&#125; 删除操作分成$\le k$和$&gt; k$两颗树，再分成 $&lt; k$、 $=k$、 $&gt; k$三棵树，将$=k$左右子树合并，相当于删去$=k$的一个节点，然后将三棵树重新合并即可。 123456789// opt 2void Del( int v )&#123; int x, y, z; Split( root, v, x, y ); Split( x, v - 1, x, z ); Merge( z, L[z], R[z] ); Merge( x, x, z ); Merge( root, x, y );&#125; 查询排名其实可以用while循环，，，但是，，，我，，，懒，，，所，，，以，，，直，，，接，，，，，，， 12345678//opt 3int GetRankByVal( int v )&#123; int x, y, t; Split( root, v - 1, x, y ); t = sz[x]; Merge( root, x, y ); return t + 1;&#125; 查询值这真的不能用Split和Merge偷懒了，，，所以乖乖写个while吧~ 技术含量不高，自行理解。 12345678910//opt 4int GetValByRank( int rk )&#123; int c(root); while( c )&#123; if ( sz[L[c]] + 1 == rk ) return val[c]; else if ( sz[L[c]] &gt;= rk ) c = L[c]; else rk -= 1 + sz[L[c]], c = R[c]; &#125; return -1;//题目没要求。。。只是为了自己查错&#125; 查询前缀分成两颗树$&lt; v$与$\ge v$，在$&lt; v$树中找最大值即可。 12345678910//opt 5int GetPre( int v )&#123; int x, y, z; Split( root, v - 1, x, y ); z = x; while( R[z] ) z = R[z]; Merge( root, x, y ); return val[z];&#125;` 查询后缀与查询前缀同理。 123456789//opt 6int GetNxt( int v )&#123; int x, y, z; Split( root, v, x, y ); z = y; while( L[z] ) z = L[z]; Merge( root, x, y ); return val[z];&#125; 完整代码洛谷P3369 【模板】普通平衡树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 100005int L[MAXN], R[MAXN], sz[MAXN], rk[MAXN], val[MAXN], tot;int root;int New( int v )&#123; return val[++tot] = v, rk[tot] = rand(), L[tot] = R[tot] = 0, sz[tot] = 1, tot; &#125;#define Updata(x) sz[x] = sz[L[x]] + sz[R[x]] + 1void Split( int c, int k, int &amp;x, int &amp;y )&#123; if ( c == 0 )&#123; x = y = 0; return; &#125; if ( val[c] &lt;= k ) x = c, Split( R[c], k, R[x], y ); else y = c, Split( L[c], k, x, L[y] ); Updata(c);&#125;void Merge( int &amp;c, int x, int y )&#123; if ( !x || !y )&#123; c = x | y; return; &#125; if ( rk[x] &gt;= rk[y] ) c = x, Merge( R[x], R[c], y ); else c = y, Merge( L[y], x, L[c] ); Updata(c);&#125;//opt 1void Ins( int v )&#123; int x, y, z(New(v)); Split( root, v, x, y ); Merge( x, x, z ); Merge( root, x, y );&#125;// opt 2void Del( int v )&#123; int x, y, z; Split( root, v, x, y ); Split( x, v - 1, x, z ); Merge( z, L[z], R[z] ); Merge( x, x, z ); Merge( root, x, y );&#125;//opt 3int GetRankByVal( int v )&#123; int x, y, t; Split( root, v - 1, x, y ); t = sz[x]; Merge( root, x, y ); return t + 1;&#125;//opt 4int GetValByRank( int rk )&#123; int c(root); while( c )&#123; if ( sz[L[c]] + 1 == rk ) return val[c]; else if ( sz[L[c]] &gt;= rk ) c = L[c]; else rk -= 1 + sz[L[c]], c = R[c]; &#125; return -1;&#125;//opt 5int GetPre( int v )&#123; int x, y, z; Split( root, v - 1, x, y ); z = x; while( R[z] ) z = R[z]; Merge( root, x, y ); return val[z];&#125;//opt 6int GetNxt( int v )&#123; int x, y, z; Split( root, v, x, y ); z = y; while( L[z] ) z = L[z]; Merge( root, x, y ); return val[z];&#125;int T;int main()&#123; srand(time(0));//随机数种子别忘了 root = New(INT_MAX);//虚节点，避免一个节点都没有不方便合并。注意要用一个很大的数，查询排名时就不用-1 scanf( "%d", &amp;T ); while( T-- )&#123; int opt, x; scanf( "%d%d", &amp;opt, &amp;x ); switch( opt )&#123; case 1: Ins(x); break; case 2: Del(x); break; case 3: printf( "%d\n", GetRankByVal(x) ); break; case 4: printf( "%d\n", GetValByRank(x) ); break; case 5: printf( "%d\n", GetPre(x) ); break; case 6: printf( "%d\n", GetNxt(x) ); break; &#125; &#125; return 0;&#125; FHQ Treap还可以资瓷可持久化~比Treap、Splay好用多啦]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SP122」STEVE - Voracious Steve 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fspoj122-solution%2F</url>
    <content type="text"><![CDATA[SP122 STEVE - Voracious Steve题意翻译ProblemSteve和他的一个朋友在玩游戏,游戏开始前，盒子里有 n个甜甜圈，两个人轮流从盒子里抓甜甜圈，每次至少抓 1个，最多抓m个。 最后一次将当盒子的甜甜圈抓完的人是这一轮游戏胜利者，他可以将所有抓到的甜甜圈吃完，另外一个人是这轮的失败者，他抓到的所有甜甜圈要重新放到盒子里。 下一轮游戏由上一轮的失败者开始抓，游戏继续。直到若干轮后，所有的甜甜圈被吃完，游戏结束。 游戏的目标是吃到尽量多的甜甜圈。游戏最开始，由Steve先抓，两个人均采用最优策略，请问Steve最多可以吃到多少甜甜圈。 Input Data第一行输入t,表示有t组测试数据 第2~t行，两个整数n和m(1≤m≤n≤100) Output Data一行，一个整数，表示Steve最多可以吃到多少个甜甜 圈。 题目描述Steve and Digit bought a box containing a number of donuts. In order to divide them between themselves they play a special game that they created. The players alternately take a certain, positive number of donuts from the box, but no more than some fixed integer. Each player’s donuts are gathered on the player’s side. The player that empties the box eats his donuts while the other one puts his donuts back into the box and the game continues with the “loser” player starting. The game goes on until all the donuts are eaten. The goal of the game is to eat the most donuts. How many donuts can Steve, who starts the game, count on, assuming the best strategy for both players? TaskWrite a program that: reads the parameters of the game from the standard input, computes the number of donuts Steve can count on, writes the result to the standard output. 输入输出格式输入格式：The input begins with the integer t, the number of test cases. Then t test cases follow. For each test case the first and only line of the input contains exactly two integers n and m separated by a single space, 1 &lt;= m &lt;= n &lt;= 100 - the parameters of the game, where n is the number of donuts in the box at the beginning of the game and m is the upper limit on the number of donuts to be taken by one player in one move. 输出格式：For each test case the output contains exactly one integer equal to the number of donuts Steve can count on. 输入输出样例输入样例#1：1215 2 输出样例#1：13 思路$a[all][one][tho]$表示总共有$all$个甜甜圈，现在轮到的人已经取了$one$个甜甜圈，另一个人取了$tho$个甜甜圈，现在轮到的人最多能取到的甜甜圈数。 我们用记搜方式实现。 当$all=0$时，直接返回0。 当$all\not=0$时，我们枚举取的个数，从中选出最大值。 一些边界、细节请看代码。 代码123456789101112131415161718192021222324252627#include&lt;bits/stdc++.h&gt;using namespace std;int n, m;int a[205][205][205];int SG( int all, int one, int tho )&#123; if ( all == 0 ) return 0; if ( a[all][one][tho] ) return a[all][one][tho]; int ans(0);//ans为找出的最大值 for ( int i = 1; i &lt;= min( m, all - one - tho ); ++i )&#123; if ( one + tho + i == all ) ans = max( ans, all - SG( tho, 0, 0 ) );//取完了，把没取到最后一个的人的甜甜圈拿来继续取 else ans = max( ans, all - SG( all, tho, one + i ) );//没取玩，继续取 &#125; return a[all][one][tho] = ans;//记录答案&#125;int main()&#123; int T; scanf( "%d", &amp;T ); while( T-- )&#123; memset( a, 0, sizeof a );//每次的m都不同，所以别忘了初始化 scanf( "%d%d", &amp;n, &amp;m ); printf( "%d\n", SG( n, 0, 0 ) ); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>博弈论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「学习笔记」左偏树]]></title>
    <url>%2F2019%2F01%2F23%2Fnotes-leftist-tree%2F</url>
    <content type="text"><![CDATA[左偏树是一种可以合并的“堆”。这里打了引号，是因为左偏树并不是堆，但是能完成与堆类似的功能。而且还能支持可持久化。 在可合并对中，左偏树是最常用的。虽然它的效率不及斐波那契堆与配对堆，但是复杂度是同一个级别，单次操作最坏情况下都是$O(log_2n)$的。而且不像斐波那契堆，码量大，难理解，在竞赛中用太不合算了，配对堆不资瓷可持久化。。。。。 放张表格，看看你打算学哪种？这里（目前）只教左偏树。其他的除了二叉堆博主都不会 指标 二叉堆 左偏树/斜堆 二项堆 斐波那契堆 配对堆 建堆 $O(n)$ $O(n)$ $O(n)$ $O(n)$ $O(n)$ 插入节点 $O(log_2n)$ $O(log_2n)$ $O(log_2n)$ $O(1)$ $O(1)$ 取最值节点 $O(1)$ $O(1)$ $O(log_2n)$ $O(1)$ $O(1)$ 删除最值节点 $O(log_2n)$ $O(log_2n)$ $O(log_2n)$ $O(log_2n)$ $O(log_2n)$ 删除任意已知节点 $O(log_2n)$ $O(log_2n)$ $O(log_2n)$ $O(log_2n)$ $O(log_2n)$ 合并 $O(nlog_2n)$ $O(log_2n)$ $O(log_2n)$ $O(1)$ $O(1)$ 空间 $—$ $-$ $+$ $++$ $-$ 代码复杂度 $—$ $-$ $++$ $+++$ $-$ 已知：表示知道编号，而不是值。 $—$表示很小，$-$表示较小，$+$表示一般，$++$表示较大，$+++$表示很大。 左偏树的基本结构与堆有许多相似之处。它是一棵二叉树，对于一个节点$x$，设其左儿子为$ls$，右儿子为$rs$，值为$v_x$总是满足$v_x \le v_{ls},v_x\le v_{rs}$（如果存在左右儿子）。 再次明确一遍，左偏树不是堆，它不一定是完全二叉树。“左偏”的意义就在于保证时间复杂度（否则一条链就能把复杂度卡到$O(n^2)$）。来看看何为“左偏”。 先讲一讲外节点。如果一个节点没有左儿子或没有右儿子（或者都没有），那么这个节点被称为外节点。我们设$dis_{x}$表示$x$与最近的外节点之间的距离。（一条边的长度为1）。特别地，空节点0的$dis$为$-1$。（这样就可以自然地完成外节点的$dis$为0） 左偏即为对于任意节点$x$，满足$dis_{ls}\ge dis_{rs}$。（这样就可以得到$dis_x=dis_{rs}+1$） 为什么这样就可以保证复杂度呢？ 很明显，一般地，节点总是集中于左子树，我们就可以把操作集中于右子树来减少操作。 来看看更严谨的证明。 引理：最大dis为k的左偏树节点个数至少为$2^{k+1}-1$（满二叉树）。 我们运用反证法。我们将深度大于k的节点去除，得到树T，如果树T不是满二叉树，则树T中必定有一个外节点$x$深度小于k，与根节点dis为k矛盾，原命题成立。 定理： 由对于一个有$n$个节点的左偏树，最大距离不超过 $\log_2(n+1)-1$证明： 设 $max\{dist\}=k$ ，由引理得$n\geq 2^{k+1}-1$ ，移项得： $k\leq \log_2(n+1)-1$ 。 这就保证了$O(log_2n)$的复杂度。 如何实现合并合并操作与FHQ Treap十分类似，如果你会FHQ Treap，这将很好理解。 12345678int Merge( int x, int y )&#123; if ( !x || !y )&#123; return x | y; &#125;//如果有一个堆为0，直接返回这个堆 if ( val[x] &gt; val[y] || ( val[x] == val[y] &amp;&amp; x &gt; y ) ) swap( x, y );//使x的值小于y(将x做为根节点) R[x] = Merge( R[x], y ); fa[R[x]] = x;//R[x]可能已被更改，更新R[x]的父亲 if ( dis[L[x]] &lt; dis[R[x]] ) swap( L[x], R[x] );//维持左偏性质 dis[x] = dis[R[x]] + 1;//更新dis return x; &#125; val[x]记录该节点保存的值，L[x]表示$x$的左儿子（没有的话就为0），R[x]表示$x$的右儿子（没有的话就为0）。fa[x]记录该节点的父亲。 Merge的作用就是将两个堆（已知根节点）合并成一个并返回其根节点。由于要保持堆的性质，根节点的值肯定要是最小的。要合并的两个堆中，值最小的肯定是$x$与$y$，如果$y$的值比$x$小，那$x$肯定不能作为根节点，所以这时候$x$不能作为根节点，只能把$y$作为根节点了。为了方便处理，我们直接交换x与y（注意：不是val，交换的是两个堆的位置）。这样$x$就肯定为根节点了。我们不改变$x$的左子树（因为是左偏的嘛，左子树太费时），将原来$x$的右子树与$y$合并作为$x$的右子树。注意要更新$dis$与$fa$的值。 还有一个前面提到过的小细节：dis[0]在主程序中必须赋为-1 删除删除根节点操作就更简单了，直接合并左右儿子即可。 12#define Del(x) val[x] = -1, fa[L[x]] = fa[R[x]] = 0, Merge( L[x], R[x] )//注意先把父亲赋为0 会了这两个操作，就可以完成左偏树模板啦。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 100005int N, M;int L[MAXN], R[MAXN];int fa[MAXN], val[MAXN], dis[MAXN];int Merge( int x, int y )&#123; if ( !x || !y )&#123; return x | y; &#125; if ( val[x] &gt; val[y] || ( val[x] == val[y] &amp;&amp; x &gt; y ) ) swap( x, y ); R[x] = Merge( R[x], y ); fa[R[x]] = x; if ( dis[L[x]] &lt; dis[R[x]] ) swap( L[x], R[x] ); dis[x] = dis[R[x]] + 1; return x; &#125;#define Del(x) val[x] = -1, fa[L[x]] = fa[R[x]] = 0, Merge( L[x], R[x] )int find( int x )&#123; while( fa[x] ) x = fa[x]; return x;&#125;//fa表示直接父亲！这不是并查集！不要想着去路径压缩！int main()&#123; scanf( "%d%d", &amp;N, &amp;M ); for ( int i = 1; i &lt;= N; ++i ) scanf( "%d", &amp;val[i] ); dis[0] = -1;//重要！ for ( int i = 1; i &lt;= M; ++i )&#123; int opt, x, y; scanf( "%d", &amp;opt ); if ( opt == 1 )&#123; scanf( "%d%d", &amp;x, &amp;y ); if ( val[x] == -1 || val[y] == -1 ) continue;//有一个点被删除就不要操作了 x = find(x); y = find(y);//记得先找到根节点再合并 if ( x != y ) Merge( x, y ); &#125; else&#123; scanf( "%d", &amp;x ); if ( val[x] == -1 ) printf( "-1\n" );//用val=-1标记已被删除的节点（输入全是正整数，如果有负数可以用INT_MIN，反正视数据范围而定） else printf( "%d\n", val[x = find(x)] ), Del(x); &#125; &#125; return 0;&#125; 当然，操作远远不止这些~慢慢更 修改洛谷P1456 Monkey King 这题要修改值。。。其实暴力一点，直接删去，再合并就OK。。。 具体一点： 删去两个左偏树的根节点（用x、y保存编号，t1、t2保存删去x、y后的左偏树根节点编号）（删除方法同上） val[x]与val[y]减半 初始化x、y（L[x]=R[x]=fa[x]=0，y也一样） 合并x、y、t1、t2 返回val[根节点] 不难理解吧？注意一个小优化，先合并x、y。因为x、y都只剩一个根节点，合并复杂度是$O(1)$的。这只是优化常数，不优化也能过。 核心代码： 1234567891011int fight( int x, int y )&#123; x = find(x); y = find(y); if ( x == y ) return -1; fa[L[x]] = fa[R[x]] = fa[L[y]] = fa[R[y]] = 0; int t1, t2; t1 = Merge( L[x], R[x] ); t2 = Merge( L[y], R[y] ); val[x] &gt;&gt;= 1; val[y] &gt;&gt;= 1; L[x] = R[x] = L[y] = R[y] = dis[x] = dis[y] = 0; x = Merge( x, y ); x = Merge( x, t1 ); x = Merge( x, t2 ); return val[x];&#125; 还有一个猥琐的坑点：多组数据！记得初始化。 更新中。。。。]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>左偏树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「学习笔记」珂朵莉树 ODT]]></title>
    <url>%2F2019%2F01%2F23%2Fnotes-old-driver-tree%2F</url>
    <content type="text"><![CDATA[珂朵莉树，也叫ODT(Old Driver Tree 老司机树) 从前有一天，珂朵莉出现了。。。然后有一天，珂朵莉树出现了。。。 看看图片的地址 Codeforces可还行) 没错，珂朵莉树来自Codeforces 896C C. Willem, Chtholly and Seniorious 国外珂学家 滑稽） 1234567前置芝士：set的基本操作迭代器（跟指针差不多重载运算符、构造函数的简单了解mutable（下面也会讲暴力枚举常数优化（inline O2 O3 register大法好啊 够简单了吧？除了真正的小白，大家都应该有所了解。 废话完了，扯进正题（毕竟你不是珂学家，你是个O·I·E·R）。 珂朵莉树的适用范围（缺一不可，不然复杂度就是不正确的，很容易被卡）： 数据纯随机 有区间修改操作 大概就这两个吧。珂朵莉树毕竟是一种骗分算法（珂朵莉：我不服），想到正解尽量用正解。 珂朵莉树的主要思想就是用一个set来维护元素相同的区间。 这里我们以P2572 [SCOI2010]序列操作为例，讲一讲珂朵莉树。 先写个结构体。 123456#define Re register //卡常操作 struct node&#123; int l, r; mutable bool val; node( int L, int R = -1, int v = 0 ):l(L), r(R), val(v)&#123;&#125;//构造函数 bool operator &lt; ( const node t )const&#123; return l &lt; t.l; &#125;//重载运算符&#125;; l表示左边界，r表示右边界，val表示l~r保存的值都是val（当然，根据题目需要，val的类型可以改变）。 mutable的作用很简单。由于在set中，元素是以常量方式存储的，不能直接修改。在set中我们是按l排序的，修改val的值实际上没有关系，不会影响set中元素的顺序，把val的类型前加个mutable，就可以直接修改val，否则还要删除元素，再插入进去，降低了效率。因为珂朵莉树比较暴力，我们要尽可能优化复杂度。 建立你的珂朵莉树 1234ls = 1; for ( Re int i = 1; i &lt;= N; ++i ) scanf( "%d", &amp;a[i] );for ( Re int i = 2; i &lt;= N; ++i ) if ( a[i] ^ a[i - 1] ) S.insert( node( ls, i - 1, a[i - 1] ) ), ls = i;S.insert( node( ls, N, a[N] ) ); 直接把连续的一段段插进去即可。 举个例子： 1111001100011000 我们就会插入以下几个元素（以 l、r、val顺序 1234561 3 14 5 06 7 18 10 010 11 112 15 0 炒鸡简单对吧？ Split 学过FHQ Treap的童鞋听到这个很熟悉对吧？其实它们作用是差不多的，但是由于FHQ Treap是以二叉查找树结构存储的，但这里的珂朵莉树直接用set存，相对来说简单得多。 Split(pos)的作用就是在某个包含pos的区间[l,r]中，分成两个区间[l,pos - 1],[pos,r]。实现很简单，请看代码。 123456789inline IT Split( Re int pos )&#123; Re IT t(S.lower_bound(node(pos)));//找到左边界第一个大于等于它的元素 if ( t != S.end() &amp;&amp; t-&gt;l == pos ) return t; // 如果左边界就是这个元素，不用分了，直接返回[pos,r]也就是[l,r] t--;//前一个元素就是包含pos的区间 Re int L(t-&gt;l), R(t-&gt;r); Re bool v(t-&gt;val);//存下来把原来的信息 S.erase(t);//删了它！ S.insert( node( L, pos - 1, v ) );//插入区间[l,pos - 1] return S.insert( node( pos, R, v ) ).first;//插入区间[pos,r]并返回[pos,r]的迭代器&#125; 举例子： 12345如果把上面那个例子中，Split(2)t 指向[4,5](4是第一个大于等于2的)左边界不是2，t--，指向区间[1,3]分成两个区间[1,1][2,3]返回[2,3]的迭代器 Assign 这个操作用于区间修改元素。由于这个操作可以迅速减少set中元素的个数，所以这是珂朵莉树的复杂度保证。 也十分简单，就是把边界Split，中间全部删除再插入一个元素就好了。 12345inline void Assign( Re int l, Re int r, Re bool v )&#123;//把l到r所有元素统统变成v Re IT ed(Split(r + 1)), be(Split(l));//Split边界 分成[...l-1] &#123;[l...]...[..r]&#125; [r+1...] be指向;[l...],ed指向[r+1...] 大括号中间全部要删除 S.erase( be, ed );//删去be~ed-1的所有元素，就是大括号中间的部分 S.insert(node( l, r, v ));//插入区间[l,r]&#125; 有一个小细节，要先执行Split(r+1)，再执行Split(l) 为什么呢？ 举反例—— 1234567891011还是拿建树那里的例子Assign(2,2)假设先执行Split(2)第一个区间[1,3]变成了[1][2,3]be指向区间[2,3]再执行Split(3)时[2,3]变成了[2][3]ed指向[3]然后如果调用了bebe原指向的区间[2,3]已经被删除了然后RE*8+TLE*1+AC*1 没错反过来的目的就是避免Split右区间时把be指向的区间删了。 区间取反 暴力枚举即可（也要Split） 1234inline void Change( Re int l, Re int r )&#123; Re IT ed(Split(r + 1)), be(Split(l)); for ( Re IT it = be; it != ed; ++it ) it-&gt;val = !(it-&gt;val);&#125; 查询1的个数 也很暴力，一个个枚举 12345inline int Get1( Re int l, Re int r )&#123; Re IT ed(Split(r + 1)), be(Split(l)); Re int ans(0); for ( Re IT it = be; it != ed; ++it ) if ( it-&gt;val ) ans += (it-&gt;r) - (it-&gt;l) + 1; return ans;&#125; 查询最长连续1的个数 还是暴力 12345678inline int Get2( Re int l, Re int r )&#123; Re IT ed(Split(r + 1)), be(Split(l)); Re int ans(0), cur(0); for ( Re IT it = be; it != ed; ++it ) if ( it-&gt;val ) cur += (it-&gt;r) - (it-&gt;l) + 1; else ans = max( ans, cur ), cur = 0; ans = max( ans, cur ); return ans;&#125; 差不多就这些了。 骗分大法好啊！ 完整代码(https://www.luogu.org/problemnew/show/P2572) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;#define Re register struct node&#123; int l, r; mutable bool val; node( int L, int R = -1, int v = 0 ):l(L), r(R), val(v)&#123;&#125; bool operator &lt; ( const node t )const&#123; return l &lt; t.l; &#125;&#125;;#define IT set&lt;node&gt;::iteratorset&lt;node&gt; S;inline IT Split( Re int pos )&#123; Re IT t(S.lower_bound(node(pos))); if ( t != S.end() &amp;&amp; t-&gt;l == pos ) return t; t--; Re int L(t-&gt;l), R(t-&gt;r); Re bool v(t-&gt;val); S.erase(t); S.insert( node( L, pos - 1, v ) ); return S.insert( node( pos, R, v ) ).first;&#125;inline void Assign( Re int l, Re int r, Re bool v )&#123; Re IT ed(Split(r + 1)), be(Split(l)); S.erase( be, ed ); S.insert(node( l, r, v ));&#125;inline void Change( Re int l, Re int r )&#123; Re IT ed(Split(r + 1)), be(Split(l)); for ( Re IT it = be; it != ed; ++it ) it-&gt;val = !(it-&gt;val);&#125;inline int Get1( Re int l, Re int r )&#123; Re IT ed(Split(r + 1)), be(Split(l)); Re int ans(0); for ( Re IT it = be; it != ed; ++it ) if ( it-&gt;val ) ans += (it-&gt;r) - (it-&gt;l) + 1; return ans;&#125;inline int Get2( Re int l, Re int r )&#123; Re IT ed(Split(r + 1)), be(Split(l)); Re int ans(0), cur(0); for ( Re IT it = be; it != ed; ++it ) if ( it-&gt;val ) cur += (it-&gt;r) - (it-&gt;l) + 1; else ans = max( ans, cur ), cur = 0; ans = max( ans, cur ); return ans;&#125;int N, M, t, ls;int a[100005];int main()&#123; scanf( "%d%d", &amp;N, &amp;M ); ls = 1; for ( Re int i = 1; i &lt;= N; ++i ) scanf( "%d", &amp;a[i] ); for ( Re int i = 2; i &lt;= N; ++i ) if ( a[i] ^ a[i - 1] ) S.insert( node( ls, i - 1, a[i - 1] ) ), ls = i; S.insert( node( ls, N, a[N] ) ); for ( Re int i = 1; i &lt;= M; ++i )&#123; Re int op, a, b; scanf( "%d%d%d", &amp;op, &amp;a, &amp;b ); a++; b++; if ( op &lt; 2 ) Assign( a, b, op ); if ( op == 2 ) Change( a, b ); if ( op == 3 ) printf( "%d\n", Get1( a, b ) ); if ( op == 4 ) printf( "%d\n", Get2( a, b ) ); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>骗分</tag>
        <tag>珂朵莉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P2397」 yyy loves Maths VI (mode) 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fluogu2397-solution%2F</url>
    <content type="text"><![CDATA[P2397 yyy loves Maths VI (mode)题目背景自动上次redbag用加法好好的刁难过了yyy同学以后,yyy十分愤怒.他还击给了redbag一题,但是这题他惊讶的发现自己居然也不会,所以只好找你 题目描述udp2:第一题因为语言性质问题，比赛结束后将所有c/c++的程序的内存调为2.2mb后重测。他让redbag找众数 他还特意表示,这个众数出现次数超过了一半 一共n个数,而且保证有 n&lt;=2000000 而且每个数&lt;2^31-1 输入输出格式输入格式：第一行一个整数n 第二行n个整数 输出格式：一行,这个众数 输入输出样例输入样例#1：1252 3 3 3 3 输出样例#1：13 说明时间限制 1s 空间限制 3.5M(你没看错3.5M) 有人想水过,但我告诉你这空间是不够的 //kkksc03偷偷地说：你随便输出一个数字吧，都有1/2的几率。不过这可是乐多赛，值得不值得你看着办。所以最好想一想正解。 思路题目意思很简单，就是求众数。然鹅，，，，，空间贼小，，，， 这里的突破口就是这个众数出现次数超过了一半，所以我们可以运用一种神奇的方法。 我们不断将两个不同的数字删去，最后剩下的数肯定相同的，它就是众数。 为什么呢？假设最坏的情况——都是众数与其它数一起删去，但是这个众数出现次数超过了一半，所以众数不可能全部被消去，剩下的数就是众数。如果非众数与非众数相消去，众数剩下的会更多，会更优。 这好像叫摩尔投票法。 代码1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int n, a, b, t;int main()&#123; scanf( "%d", &amp;n ); scanf( "%d", &amp;a ); b = 1; for ( int i = 2; i &lt;= n; ++i )&#123; scanf( "%d", &amp;t ); if ( t == a ) b++; else if ( b ) b--; else a = t, b = 1; &#125; printf( "%d\n", a ); return 0;&#125; 拓展摩尔投票算法可以拓展到 出现次数超过1/3,甚至1/k的情况。只要把一次消掉2个数改成消掉k个数就可以了。]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>数学,数论</tag>
        <tag>神仙题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVA12004」 Bubble Sort 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fuva12004-solution%2F</url>
    <content type="text"><![CDATA[UVA12004 Bubble SortCheck the following code which counts the number of swaps of bubble sort. 123456789101112131415161718int findSwaps( int n, int a[] )&#123; int count = 0, i, j, temp, b[100000]; for( i = 0; i &lt; n; i++ ) &#123; b[i] = a[i]; &#125; for( i = 0; i &lt; n; i++ ) &#123; for( j = 0; j &lt; n - 1; j++ ) &#123; if( b[j] &gt; b[j+1] ) &#123; temp = b[j]; b[j] = b[j+1]; b[j+1] = temp; count++; &#125; &#125; &#125; return count;&#125; You have to find the average value of ’count’ in the given code if we run findSwaps()infinitely many times using constant ’n’ and each time some random integers (from 1 to n) are given in array a[]. You can assume that the input integers in array a[] are distinct. InputInput starts with an integer T (≤ 1000), denoting the number of test cases. Each test case contains an integer n (1 ≤ n ≤ 105) in a single line. OutputFor each case, print the case number and the desired result. If the result is an integer, print it. Otherwise print it in ‘p/q’ form, where p and q are relative prime. Sample Input123212 Sample Output12Case 1: 0Case 2: 1/2 思路一句话题意：求长度为n的排列的期望逆序对数。 很简单，$f(n)=f(n-1)+\frac{n-1}2=\frac{n\times(n-1)}4，f(1)=0$。 为什么呢？假设把$n$插入长度$(n-1)$的排列，有$n$种方法。期望增加的逆序对数就是$\frac{1+2+…n-1}n=\frac{n\times (n-1)}{2n}=\frac{n-1}2$ 所以$f(n)=f(n-1)+\frac{n-1}2$ 很简单吧？别忘了开long long 代码1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;#define LL long longint T, i;LL n;int main()&#123; scanf( "%d", &amp;T ); for ( int i = 1; i &lt;= T; ++i )&#123; scanf( "%lld", &amp;n ); n = n * ( n - 1 ) / 2; if ( n &amp; 1 ) printf( "Case %d: %lld/2\n", i, n ); else printf( "Case %d: %lld\n", i, n / 2 ); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>逆序对</tag>
        <tag>期望,概率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SP25784」BUBBLESORT - Bubble Sort 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fspoj25784-solution%2F</url>
    <content type="text"><![CDATA[SP25784 BUBBLESORT - Bubble Sort题目描述One of the simplest sorting algorithms, the Bubble Sort, can be expressed as (0-based array):123456789101112131415161718192021222324252627procedure bubbleSort( A : list of sortable items )n = length(A)repeatswapped = falsefor i = 1 to n-1 inclusive do/* if this pair is out of order */if A[i-1] &gt; A[i] then/* swap them and remember something changed */swap( A[i-1], A[i] )swapped = trueend ifend foruntil not swappedend procedure Now, given an array of N integers, you have to find out how many swap opeartions occur if the Bubble Sort algorithm is used to sort the array. 输入输出格式输入格式：Input begins with a line containing an integer T(1&lt;=T&lt;=100), denoting the number of test cases. Then T test cases follow. Each test case begins with a line containing an integer N(1&lt;=N&lt;=10000), denoting the number of integers in the array, followed by a line containing N space separated 32-bit integers. 输出格式：For each test case, output a single line in the format Case X: Y, where X denotes the test case number and Y denotes the number of swap operations needed modulo 10000007. 输入输出样例输入样例#1：123143 2 1 4 输出样例#1：1Case 1: 3 思路题目虽然是冒泡排序，但不可能模拟吧？$O(N^2\times T)$的算法是很难卡过去的。 冒泡排序的基本原理就是交换两个元素。我们发现，每交换一次，就可以消去一个逆序对。 所以，我们可以得出结论：冒泡排序的交换次数就是该序列的逆序对数。（这个结论在逆序对题中十分常见） 因此，运用归并排序，求出逆序对即可。（当然也可以用树状数组）具体看代码注释。 代码12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;#define mod 10000007#define MAXN 10005int T, N, ans;int a[MAXN], b[MAXN];void Merge_sort( int l, int r )&#123; if ( l == r ) return;//只有一个元素不用排序 int mid((l + r) &gt;&gt; 1); Merge_sort( l, mid );//左边排序 Merge_sort( mid + 1, r );//右边排序 int i1(l), i2(mid + 1), c(l);//把左右两边归并 while( i1 &lt;= mid &amp;&amp; i2 &lt;= r )&#123; if ( a[i1] &lt;= a[i2] ) b[c++] = a[i1++];//必须写&lt;= else b[c++] = a[i2++], ans = ( ans + mid - i1 + 1 ) % mod;//顺便统计逆序对个数（右边元素之前有mid-i1+1个比它大的） &#125; while( i1 &lt;= mid ) b[c++] = a[i1++];//剩余的元素排到后面 while( i2 &lt;= r ) b[c++] = a[i2++]; for ( int i = l; i &lt;= r; ++i ) a[i] = b[i], b[i] = 0;//复制回原数组&#125;int main()&#123; scanf( "%d", &amp;T ); for ( int Ti = 1; Ti &lt;= T; ++Ti )&#123; scanf( "%d", &amp;N ); for ( int i = 1; i &lt;= N; ++i ) scanf( "%d", &amp;a[i] ); ans = 0;//初始化很重要 Merge_sort( 1, N ); printf( "Case %d: %d\n", Ti, ans ); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>归并排序</tag>
        <tag>逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P1306」斐波那契公约数 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fluogu1306-solution%2F</url>
    <content type="text"><![CDATA[P1306 斐波那契公约数题目描述对于Fibonacci数列：1,1,2,3,5,8,13……大家应该很熟悉吧~~~但是现在有一个很“简单”问题：第n项和第m项的最大公约数是多少？ 输入输出格式输入格式：两个正整数n和m。（n,m&lt;=10^9）注意：数据很大 输出格式：Fn和Fm的最大公约数。由于看了大数字就头晕，所以只要输出最后的8位数字就可以了。 输入输出样例输入样例#1：14 7 输出样例#1：11 说明用递归&amp;递推会超时用通项公式也会超时 前置芝士矩阵快速幂，更相减损术，欧几里得算法。 思路初看此题，毫无头绪，其实并不难。 结论很简单，设$f[i]$表示斐波那契数列第$i$个，则有$\gcd(f[i],f[j])=f[\gcd(i,j)]$。 为什么呢？ 显然，当$i=j$时，结论成立。 假设$i&lt; j$，我们设$f[i]=a,f[i+1]=b,f[i+2]=a+b…$ 很明显，$f[j]=f[j-i]\times b+f[j-i-1]\times a$ 因此$\gcd(f[i],f[j])=\gcd(f[i],f[j-i]\times f[i+1]+f[j-i-1]\times f[i])$ 即$\gcd(f[i],f[j])=\gcd(f[i],f[j-i]\times f[i+1])$ 引理：$\gcd(f[i],f[i+1])=1$ 证明： 显然，$\gcd(f[1],f[2])=1$成立。 $\gcd(f[2],f[3])=\gcd(f[2],f[3]-f[2])=\gcd(f[2],f[1])=1$ $\gcd(f[3],f[4])=\gcd(f[3],f[4]-f[3])=\gcd(f[3],f[2])=1$ … QED. 回到$\gcd(f[i],f[j])=\gcd(f[i],f[j-i]\times f[i+1])$这个式子，因为$\gcd(f[i],f[i+1])=1$，因此$\gcd(f[i],f[j])=\gcd(f[i],f[j-i]\times f[i+1])=\gcd(f[i],f[j-i])$ 发现了吧？这和更相减损术的$\gcd(i,j)=\gcd(i,i-j)$蜜汁相似，没错，就是公约数！$\gcd(f[i],f[j])$就等于$f[\gcd(i,j)]$！ 然后用矩阵快速幂求出$f[\gcd(n,m)]$即可。 代码123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;#define Re registerint N, M;int gcd( int x, int y )&#123; return y ? gcd( y, x % y ) : x; &#125;int a[3][3], b[3][3], c[3][3];inline void Times( int a[3][3], int b[3][3] )&#123; memset( c, 0, sizeof c ); for ( int i = 1; i &lt;= 2; ++i ) for ( int k = 1; k &lt;= 2; ++k ) for ( int j = 1; j &lt;= 2; ++j ) c[i][j] = (int)( ( c[i][j] + 1ll * a[i][k] * b[k][j] ) % 100000000 );&#125;int main()&#123; scanf( "%d%d", &amp;N, &amp;M ); N = gcd( N, M ) - 2; if ( N &lt;= 0 )&#123; printf( "1\n" ); return 0; &#125; a[1][1] = a[1][2] = b[1][1] = b[1][2] = b[2][1] = 1; for ( int i = N; i; i &gt;&gt;= 1 )&#123; if ( i &amp; 1 ) Times( a, b ), memcpy( a, c, sizeof a ); Times( b, b ), memcpy( b, c, sizeof b ); &#125; printf( "%d\n", a[1][1] ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>数学,数论</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P2906」[USACO08OPEN]牛的街区Cow Neighborhoods 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fluogu2906-solution%2F</url>
    <content type="text"><![CDATA[P2906 [USACO08OPEN]牛的街区Cow Neighborhoods题目描述Those Who Know About Cows are aware of the way cows group into ‘Cow Neighborhoods’. They have observed Farmer John’s N (1 &lt;= N &lt;= 100,000) cows (conveniently numbered 1..N) as they graze, each at her own unique integer rectilinear coordinate, on a pasture whose X and Y coordinates are in the range 1..1,000,000,000. Two cows are neighbors if at least one of two criteria is met: 1) If the cows are no further than some integer Manhattan distance C (1 &lt;= C &lt;= 1,000,000,000) apart, they are neighbors. [Manhattan distance is calculated as d = |x1-x2| + |y1-y2|.] 2) If cow A is a neighbor of cow Z and cow B is a neighbor of cow Z, then cow A is a neighbor of cow B (the ‘transitive closure of neighbors’). Given the locations of the cows and the distance C, determine the the number of neighborhoods and the number of cows in the largest neighborhood. By way of example, consider the pasture below. When C = 4, this pasture has four neighborhoods: a big one on the left, two neighborhoods of size 1 (the lonesome cows), and a huge neighborhood on the right with 60 different cows. 123456789101112.....................................*................. ....*...*..*.......................***................. ......*...........................****................. ..*....*..*.......................*...*.******.*.*..... ........................*.............***...***...*.... *..*..*...*..........................*..*...*..*...*... .....................................*..*...*..*....... .....................................*..*...*..*....... ...*................*.................................. .*..*............................*.*.*.*.*.*.*.*.*.*.*. .*.....*..........................*.*.*.*.*.*.*.*.*.*.* ....*.................................................. The input file describes cow locations by integer X,Y coordinates, where the lower left corner is (1,1) and cows close to that corner appear at both (2,2) and (5,1) in the example above. For a given pasture, determine both the number of cow neighborhoods and the number of cows resident in the largest cow neighborhood. The above picture is sample test case 2, which will be evaluated for you upon submission. Partial feedback for some test cases will be provided on the first 10 submissions. Time Limit: 2 seconds Memory Limit: 32MB 了解奶牛们的人都知道，奶牛喜欢成群结队．观察约翰的N(1≤N≤100000)只奶牛，你会发现她们已经结成了几个“群”．每只奶牛在吃草的时候有一个独一无二的位置坐标$X_i$,$Y_i$($1\leq X_i,Y_i\leq [1 \cdots 10^9]$；$X_i,Y_i \in \text{整数}$．当满足下列两个条件之一，两只奶牛i和j是属于同一个群的： 两只奶牛的曼哈顿距离不超过$C(1\leq C\leq 10^9)$，即$|X_i - x_i|+|Y_i - y_i|\leq C$. 两只奶牛有共同的邻居．即，存在一只奶牛$k$，使$i$与$k$，$j$与$k$均同属一个群． 给出奶牛们的位置，请计算草原上有多少个牛群，以及最大的牛群里有多少奶牛 输入输出格式输入格式：* Line 1: Two space-separated integers: N and C * Lines 2..N+1: Line i+1 describes cow i’s location with two space-separated integers: $X_i$ and $Y_i$ 输出格式：* Line 1: A single line with a two space-separated integers: the number of cow neighborhoods and the size of the largest cow neighborhood. 输入输出样例输入样例#1：123454 2 1 1 3 3 2 2 10 10 输出样例#1：12 3 说明There are 2 neighborhoods, one formed by the first three cows and the other being the last cow. The largest neighborhood therefore has size 3. 思路有思考深度的好题呀！（注意下$X_i$与$x_i$表示的意义是不同的 我们观察两个点$i$、$j$的曼哈顿距离$|X_i-X_j|+|Y_i-Y_j|$。 如果$X_i-X_j$与$Y_i-Y_j$同号，曼哈顿距离为$|X_i+Y_i-(X_j+Y_j)|$，且$|X_i-Y_i-(X_j-Y_j)|$偏小 如果异号，曼哈顿距离为$|X_i-Y_i-(X_j-Y_j)|$，且$|X_i+Y_i-(X_j+Y_j)|$偏小 因此，我们发现，如果设$x_i=X_i+Y_i$，$y_i=X_i-Y_i$，$i$、$j$之间的曼哈顿距离即为$\max(|x_i-x_j|,|y_i-y_j|)$ 然后用平衡树multiset一通乱搞就可以啦！ 我们按照$x_i$为第一关键字，$y_i$为第二关键字排序，依次处理每个点。设当前处理的点为$i$。我们用并查集维护一个个群。 首先把所有$x$值小于$x_i-C$的点全部$erase$（删除）掉。 寻找第一个大于等于$y_i$的点$j$(lower_bound)。如果$y_j-y_i\le C$，很明显，$j$与$i$是同一个群的。 但是如果还有大于$y_i$的点$k$也满足条件呢？很明显，如果$y_k-y_i\le C$，那么$y_k-y_j\le y_k-y_i\le C$，在处理$j$或$k$的时候已经将它们合并（这取决于$x$的大小），不必再管。 然后再康康小于$y_i$的点有没有符合条件的就好啦！ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;bits/stdc++.h&gt;using namespace std;#define IT multiset&lt;pi&gt;::iterator#define MAXN 100005#define LL long long#define pi pair&lt;LL, int&gt;struct node&#123; int x, y; bool operator &lt; ( const node &amp;t )const&#123;//重载运算符 if ( x == t.x ) return y &lt; t.y; return x &lt; t.x; &#125; void input()&#123; scanf( "%d%d", &amp;x, &amp;y ); x = x + y, y = x - y - y;//读入并把X、Y转换成x、y &#125;&#125;a[MAXN];multiset&lt;pi&gt; s;//因为要合并，还得记录编号（排序后的）。。所以用了个pairIT p[MAXN];//迭代器数组，用于删除x过小的元素int f[MAXN], sm[MAXN];//并查集、记录每个群的牛数（最后再处理int find( int x )&#123; return x == f[x] ? x : ( f[x] = find(f[x]) ); &#125;void Merge( int x, int y )&#123; x = find(x); y = find(y); f[x] = y;&#125;int N, C, x, y;int main()&#123; scanf( "%d%d", &amp;N, &amp;C ); for ( int i = 1; i &lt;= N; ++i ) a[i].input(), f[i] = i; sort( a + 1, a + N + 1 ); s.insert( make_pair( 1ll &lt;&lt; 60, -1 ) ); s.insert( make_pair( -( 1ll &lt;&lt; 60 ), -1 ) );//避免边界问题 p[1] = s.insert(make_pair( a[1].y, 1 )); int tmp(1);//第一个点直接插入即可。 for ( int i = 2; i &lt;= N; ++i )&#123; while( a[i].x - a[tmp].x &gt; C ) s.erase(p[tmp++]);//把不满足要求的点删除 IT t(s.lower_bound(make_pair( a[i].y, -1 )));//找第一个大于等于y的 if ( t-&gt;first - a[i].y &lt;= C ) Merge( i, t-&gt;second );//满足要求，合并 t--;//找第一个小于y的 if ( a[i].y - t-&gt;first &lt;= C ) Merge( i, t-&gt;second );//满足要求，合并 p[i] = s.insert( make_pair( a[i].y, i ) );//插入点并记录迭代器 &#125; int ans1(0), ans2(0); for ( int i = 1; i &lt;= N; ++i )&#123; if ( find(i) == i ) ans1++; ans2 = max( ans2, ++sm[find(i)] ); &#125; printf( "%d %d\n", ans1, ans2 ); return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>STL</tag>
        <tag>神仙题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷P3202」[HNOI2010]弹飞绵羊 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fluogu3202-solution%2F</url>
    <content type="text"><![CDATA[P3203 [HNOI2010]弹飞绵羊题目描述某天，Lostmonkey发明了一种超级弹力装置，为了在他的绵羊朋友面前显摆，他邀请小绵羊一起玩个游戏。游戏一开始，Lostmonkey在地上沿着一条直线摆上n个装置，每个装置设定初始弹力系数ki，当绵羊达到第i个装置时，它会往后弹ki步，达到第i+ki个装置，若不存在第i+ki个装置，则绵羊被弹飞。绵羊想知道当它从第i个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣，Lostmonkey可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。 输入输出格式输入格式：第一行包含一个整数n，表示地上有n个装置，装置的编号从0到n-1。 接下来一行有n个正整数，依次为那n个装置的初始弹力系数。 第三行有一个正整数m， 接下来m行每行至少有两个数i、j，若i=1，你要输出从j出发被弹几次后被弹飞，若i=2则还会再输入一个正整数k，表示第j个弹力装置的系数被修改成k。 输出格式：对于每个i=1的情况，你都要输出一个需要的步数，占一行。 输入输出样例输入样例#1：12345641 2 1 131 12 1 11 1 输出样例#1：1223 说明对于20%的数据n,m&lt;=10000，对于100%的数据n&lt;=200000,m&lt;=100000 思路我们运用分块思想，把序列分成$\sqrt{n}$块，每个点$i$计录两个值$c[i],s[i]$，表示再弹$s[i]$次第一次落到该块外，且落到$c[i]$的位置。预处理是$O(N)$的，每次修改、查询都是$O(\sqrt N)$的，所以复杂度是正确的（虽然8e7有点悬）。具体看代码。 代码1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;#define MAXN 200005int N, M;int a[MAXN], b[MAXN], n;int c[MAXN], s[MAXN];int main()&#123; scanf( "%d", &amp;N ); n = (int)sqrt(N); for ( int i = 1; i &lt;= N; ++i ) scanf( "%d", &amp;a[i] ), b[i] = ( i - 1 ) / n + 1;//记录每个点所属的块 for ( int i = N; i &gt;= 1; )&#123;//倒序复杂度是O(N)，正序是O(n^1.5) int t(b[i]), j(i); while( b[j] == t )&#123; if ( j + a[j] &gt; i ) c[j] = j + a[j], s[j] = 1;//一次就弹出该块 else c[j] = c[j + a[j]], s[j] = s[j + a[j]] + 1;//递推思想 j--; &#125; i = j; &#125; int op, x, y; scanf( "%d", &amp;M ); while ( M-- )&#123; scanf( "%d%d", &amp;op, &amp;x ); x++; if ( op &amp; 1 )&#123; int ans(0); for ( int i = x; i &lt;= N; ) ans += s[i], i = c[i];//只要一直弹即可。每次弹都会经过一整个块，因此每次复杂度为O(N^0.5) printf( "%d\n", ans ); &#125;else&#123; scanf( "%d", &amp;y ); a[x] = y; int t(b[x]), j(x); while( b[j] == t )&#123;//只要修改该块内即可，复杂度也为O(N^0.5) if ( j + a[j] &gt; x ) c[j] = j + a[j], s[j] = 1; else c[j] = c[j + a[j]], s[j] = s[j + a[j]] + 1; j--; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「UVA1185」Big Number 解题报告]]></title>
    <url>%2F2019%2F01%2F23%2Fuva1185-solution%2F</url>
    <content type="text"><![CDATA[UVA1185 Big NumberIn many applications very large integers numbers are required. Some of these applications are using keys for secure transmission of data, encryption, etc. In this problem you are given a number, you have to determine the number of digits in the factorial of the number. InputInput consists of several lines of integer numbers. The first line contains an integer n, which is the number of cases to be tested, followed by n lines, one integer 1 ≤ n ≤ 107 on each line. OutputThe output contains the number of digits in the factorial of the integers appearing in the input. Sample Input12321020 Sample Output12719 题意求出$n!$有几位数。 思路我们考虑用log解决。 $log_{10}ab=log_{10}a+log_{10}b$ 因此$log_{10}n!=log_{10}1+log_{10}2+……+log_{10}n$ $floor(log_{10}n!)+1$即为$n!$的位数。 代码12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;#define Re register#define MAXN 10000005#define LD long doubleint f[MAXN];LD c;int n, t;int main()&#123; for ( int i = 1; i &lt;= 10000000; ++i )&#123; c += log10(i); f[i] = (int)floor(c) + 1; &#125; scanf( "%d", &amp;n ); while( n-- )&#123; scanf( "%d", &amp;t ); printf( "%d\n", f[t] ); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
        <tag>数学,数论</tag>
        <tag>神仙题</tag>
      </tags>
  </entry>
</search>
